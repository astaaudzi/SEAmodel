---
title: "SEA_bentPelModel"
author: "Asta Audzijonyte et al."
date: "7 November 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

### READ ME: explanation

This code shows simulation setup for productivity x warming x fishing scenarios 
We have three types of productivity changes: increased amount (intercept), decreased total amount, and steeper slope
Each of these three changes are applied to pelagic and benthic resource spectrum separately. Together with the baseline this gives 7 scenarios 

For each of the seven scenarios we run two levels of fishing: no fishing and low fixed fishing 
And for all of these scenarios we run two levels of warming: no warming and warming by 2.5C as predicted in the RCP4.5 scenario. The high emission scenario (RCP85) predicts 4C of warming in SE Australia by 2100, which is scary and too hard to accept :(

The warming effect is modelled through changes in intake and metabolism rates, using activation energy of 0.63, according to the Brown et al. 2004 Metabolic theory of ecology. There are many ways how warming might affect species, but here we will use only a simple approach, that is used in many other models. 

Finally, I have 29 parameter combinations selected through the uncertainty evalutation procedure (runining 2.2mln combinations and rejecting all runs that do not satisfy certain criteria). So all 28 scenarios are run 29 times to get uncertainty values around them. 

All runs usually stabilise over the 100 year time frame, so we are dealing here with equlibrium conditions, not with transient dynamics. In some parameter combinations some species go extinct with low plankton or low benthos scenarios. Further, in high plankton and high benthos scenarios we often get regular oscilations, especially when fishing is applied. 

For each run I save these outputs (average of the last 30 years to account for the possible effect of oscilations)
- biomasses of all species
- numbers at size for all species
- number at size for the three background spectra (plankton, benthos and algae)
- mean weight of fish using different minimum size thresholds: mean weight of fish above the maturation size, above the 5cm lenght, and above the 10cm lenght. These can be used to see how our findings compare with the NEE findings about chaning mean sizes of fish
- Community slopes for various species combinations: all species, fish only (exclude lobsters and urchins), and for four functional groups (benthivores, planktivores, predators, herbivores)
- Proportion of fish above the maturation size
- Yields 

The output datafiles are available in three formats: 
1) the original data.frames saved from the simulations (29x17x28 or similar)
2) original dataframes turned into a long format for ANOVA analyses with added columns to identify treatment effect. The columns identify fishing (1,0), warming (1,0), benthos (1- some changes in benthos spectrum), plankton (1 - some changes in plantkon), kappaUp (1 - either plankton or benthos increase in abundance), kappaDown, slopes (1 - either plankton or benthos slope gets steeper)
3) difference between the first baseline scenario and all other scenarios for each parameter combination. So here we want to see how the scenarios differ. We don't plot all values for each parameter combination, but the difference from the baseline. This way, even if uncertainty in the original range is high, we want to know whether ALL parameter combinations behave in a same way. For example, they might ALL suggest that biomass goes up or down. This difference is what we want to use for plots. 

### ####################
### clear memory

```{r}

rm(list=ls())

```

### Load libraries

```{r warning=FALSE, message=FALSE, warning=FALSE, echo=F}
#list.files()

#remotes::install_github("astaaudzi/mizer", ref = "temp-model-comp")
library(mizerRewire)
list.of.packages <- c("tidyverse", "dplyr", "ggplot2", "ggmap", "vegan", "reshape2", "cowplot", "factoextra", "data.table", "cowplot", "ggeffects")

new.packages<- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, require, character.only = TRUE)

#install.packages("viridis")
library(viridis)
library(knitr)
library(lattice)
library(effects)
library(MuMIn)
library(MASS)
#library(hrbrthemes)
library(emmeans)
library(lme4)
library(sjPlot)
library(merTools)
library(ggpubr)
#install.packages("fishualize")
library(fishualize)
#install.packages("glmmTMB")
library(glmmTMB)

library(tidyverse)

```

### ####################
### EXPLORING THE MODEL

The chunks below allow you to explore the model. You can load the main set of parameters as indicated below. If you want to explore other parameter sets (we have 29 combinations of gamma, rmax and interaction matrix parameters that are all considered suitable), you can load the dataframe modelParams/params28ms.RData (commented out below)

### Load params

```{r}
### Load params, data & senescence mort

  load(file = "modelParams/mariaParamsMs.RData") #species parameter file 
  load(file = "modelParams/paramsMs.RData") #built params file
  load(file = "modelParams/inter_N19.RData") #interaction matrix (it is also included in the params file)
  # now load stable numbers at size for all species. I start the runs from equilibrium abundances 
  load(file = "modelParams/abund_N19.RData")
  load(file = "modelParams/npp_N19.RData")
  load(file = "modelParams/nbb_N19.RData")
  load(file = "modelParams/naa_N19.RData")
  
  ## data for invertebrate abundances
  load(file = "modelParams/BenticInvAbund_Tasm.RData")

  #load empirical size spectra in underwater visual survey length bins. Species are grouped as in model groups. Their length-weight conversion is included, and weights per size bins are also calculated. Not sure this is the best way to compare observed spectra to model spectra. Either way we need to bin model size spectra into similar bins. How? 
  load(file = "modelParams/empSizes.RData")
  
## also load senescence mortality function (it is not currently in mizerRewire but is added separately)

 #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }

```


### Load background spectra

```{r warning=T, message=FALSE, echo=T}

#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

## resource params
kappa = 2#intercept assuming g/m2
lambda = 2.15 # 
w_pp_cutoff = 1 #g
r_pp = 1 # rate of regeneration
min_w_pp = 1e-10 #g

kappa_ben = 6 
lambda_ben = 1.9 # this slope does not include urchins and lobsters
w_bb_cutoff = 5 #
r_bb = 1 # 
min_w_bb = 0.001 #

kappa_alg = 16 #
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
w_aa_cutoff = 50 
r_aa = 2 #
min_w_aa = 0.001

```


### Basic run

```{r warning=FALSE, message=FALSE, echo=T}

### setup 
params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg
## add senescence mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) 

## setup run time 
tmax = 100
tasm1 <- mizerRewire::project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)
plot(tasm1)

## comnpare model biomasses to observed biomasses 
getBiomass(tasm1)[tmax,]/mariaParams$BioM2

## check whether relative biomasses are similar to the observed relative biomasses
relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
relbio

#check observed invertebrate abundances
obsInvAb <- sum(InvData$meanAb[which(InvData$wgt > min_w_bb & InvData$wgt < w_bb_cutoff)])
modelInvAb <- sum(tasm1@n_bb[tmax,]*params@dw_full)
#ratio of model vs observed inv abundances (benthic spectrum) in the relevant range
modelInvAb/obsInvAb

### Lots more can be explored and checked 

```


### Growth curves

```{r}
model <- tasm1

max_age = c(15, 20, 10, 10, 10, 10, 80, 40, 10, 20, 10, 15, 10, 10, 20, 10, 20)

par(mfrow = c(4,5))

## growth curves

#pdf("growthCurves.pdf", onefile = T)

for (i in 1:17) {
  
  plotGrowthCurves(model, species = params@species_params$species[i], percentage = F)
  geom_vline(xintercept = max_age[i])
  
}

#dev.off()


```


### Diet 

Why doesn't the plot work from mizer??? 

####Function
```{r}

 plotDiet <- function(object, diettime = tmax) {
  model <- object
  diet <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = T)
  prey <- dimnames(diet)$prey
  predator <- dimnames(diet)$predator
  prey <- factor(prey, levels = rev(prey))
  predator <- factor(predator, levels = (predator))
  w.temp = rep(params@w, each = length(predator))
  w = rep(w.temp, times = length(prey))
  plot_dat <- data.frame(
    Proportion = c(diet),
    w = w,
    Prey = rep(prey, each = (length(params@w)*length(predator))),
#    Predator = rep(predator, each = (length(params@w)*length(prey))))
    Predator = rep(predator))
  plot_dat <- plot_dat[plot_dat$Proportion > 0, ]
#  colorvalues <- c(params@linecolour[c(1:length(params@species_params$species))])
#  colorvalues <- c(colorvalues,"green","brown","yellow")
  ggplot(plot_dat) +
    geom_area(aes(x = w, y = Proportion, fill = Prey)) +
    facet_wrap(~ Predator, ncol=5) +
    scale_x_log10() +
    labs(x = "Size [g]") 
}

```

####diet graphs

```{r}

diettime <- tmax # year to get diet


## diet function can give output as proportion or as total consumed weight, depending on the "proportion" parameter
diet <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = T)

#Plot diet  
plotDiet(model, diettime = tmax)

plotPPMR(model) #plot realised PPMR - this is also a function Jon wrote and they are now all incorporated into rewire-temp

#if you want to look specifically at the diet proportions of certain predator 
# which size class to check the diets for (500g for example)

#to look at what species we have 
params@species_params$species
#Notolabrus       L_forsteri       T_caudimaculatus C_rasor          D_lewini         leatherjack      C_spectabilis    C_laticeps       P_laticlavius    Boarfish         M_freycineti     P_bachus         O_cyanomelas     A_arctidens   predator         urchins          lobsters 

predatorSize = 1000
dietsize = max(which(params@w < predatorSize))
round(diet[which(params@species_params$species == "Notolabrus"),dietsize,],3)

```



### Alternative parameters 

```{r}
## Now if you want to look at all 29 parameter combinations, they are saved here 

  load(file = "modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)

  ## chose which combination of parameters you want to explore (first one is the same as the baseline)
  # for example I want to check parameter combination 2
  iter = 2
  
  #update Rmax params
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  #update gamma params
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  
  #update 3 terms of the interaction matrix
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with updated params (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e)

  ## do runs as before ...


```

$### Fig. S2: model and observed biomases

```{r}

# Observations 
load(file = "modelParams/AllSppStatisticsYear.RData")

#model outputs 
load(file = "outputs/biom.RData")

# observation data. Note for these results I assumed 
# MeanLobWeight = 150 #assume mean lobster weighs 150g
# MeanUrcWeight = 5 # mean urchin 5g
# the data frame has mean abundances, so could be easily recalculated with different mean weights 

plot_obs <- AllSppStatisticsYear %>% filter (year < 2000)  #only take the 1990s
plot_obs20 <- AllSppStatisticsYear %>% filter (year > 1999 & year < 2010)  #only take the 1990s


### model results for the 29 parameter combinations 
plot_mod <- as.data.frame(t(biom_all[19,,])) # only take the baseline scenario with fishing; at this stage we do not work with no-fishing scenarios at all 
colnames(plot_mod) <- mariaParams$species
# reshape model data into long format
library(tidyr)
plot_mod_l <- plot_mod %>% gather(group, value)

## Plot 

logplot <- ggplot(plot_mod_l, aes(x = group, y = log10(value))) +
  geom_boxplot(notch = F, fill = "grey", outlier.colour = 'black', outlier.shape = 1, outlier.fill = 'black' , alpha = 0.5) + 
  geom_boxplot(data=plot_obs, aes(x = modelName, y = log10(meanBio/500)), notch = F, fill = "red", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
  geom_boxplot(data=plot_obs20, aes(x = modelName, y = log10(meanBio/500)), notch = F, fill = "orange", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
    theme_bw() +
 # ylim(-1, 1.5) + 
     theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(angle = 90, vjust = 0.5), 
    legend.position="none",
    axis.text=element_text(size=14)
  ) +
  labs(x = "Model group", y = "Log10(Biomass, g/m2)") 
#  ggtitle("Modelled and observed biomass") 


plot90s <- ggplot(plot_mod_l, aes(x = group, y = value)) +
  geom_boxplot(notch = F, fill = "grey", outlier.colour = 'black', outlier.shape = 1, outlier.fill = 'black' , alpha = 0.5) + 
  geom_boxplot(data=plot_obs, aes(x = modelName, y = meanBio/500), notch = F, fill = "red", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
 # geom_boxplot(data=plot_obs20, aes(x = modelName, y = meanBio/500), notch = F, fill = "orange", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
    theme_bw() +
 # ylim(-1, 1.5) + 
     theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(angle = 90, vjust = 0.5), 
    legend.position="none",
    axis.text=element_text(size=14)
  ) +
  labs(x = "Model group", y = "Biomass, g/m2") 
#  ggtitle("Modelled and observed biomass") 

plot00s <- ggplot(plot_mod_l, aes(x = group, y = value)) +
  geom_boxplot(notch = F, fill = "grey", outlier.colour = 'black', outlier.shape = 1, outlier.fill = 'black' , alpha = 0.5) + 
  #geom_boxplot(data=plot_obs, aes(x = modelName, y = meanBio/500), notch = F, fill = "red", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
  geom_boxplot(data=plot_obs20, aes(x = modelName, y = meanBio/500), notch = F, fill = "red", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
    theme_bw() +
 # ylim(-1, 1.5) + 
     theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(angle = 90, vjust = 0.5), 
    legend.position="none",
    axis.text=element_text(size=14)
  ) +
  labs(x = "Model group", y = "Biomass, g/m2") 
#  ggtitle("Modelled and observed biomass") 

#garrange(linearplot, logplot, labels = c("linear scale", "log10 scale"), ncol = 2, nrow = 1)
ggarrange(plot90s, plot00s, labels = c("1990s", "2000s"), ncol = 2, nrow = 1)

```


### ####################
### ANALYSING SCENARIO RESULTS

Here we load various scenario outputs dataframes and analysing them

First, load species and scenario information 

### Load general data 

```{r}
## if starting from this chunk load mariaParams to have species information 
load(file = "modelParams/mariaParamsMs.RData")

scenarios<-c("baseline_12_f0", "more_plankt_12_f0", "less_plankt_12_f0","small_plankt_12_f0","large_plankt_12_f0", "more_benth_12_f0","less_benth_12_f0", "small_benth_12_f0","large_benth_12_f0", "baseline_14_f0", "more_plankt_14_f0", "less_plankt_14_f0", "small_plankt_14_f0","large_plankt_14_f0", "more_benth_14_f0","less_benth_14_f0","small_benth_14_f0","large_benth_14_f0","baseline_12_f2", "more_plankt_12_f2", "less_plankt_12_f2","small_plankt_12_f2","large_plankt_12_f2", "more_benth_12_f2","less_benth_12_f2", "small_benth_12_f2","large_benth_12_f2", "baseline_14_f2", "more_plankt_14_f2", "less_plankt_14_f2", "small_plankt_14_f2","large_plankt_14_f2", "more_benth_14_f2","less_benth_14_f2","small_benth_14_f2", "large_benth_14_f2")

species <- as.character(mariaParams$species)
func_group <- as.character(mariaParams$funcgr)

#identify various scenarios
warm_sc <- scenarios[c(10:18, 28:36)] #scenarios with warming
fish_sc <- scenarios[c(19:36)] #scenarios with fishing
pla_sc <- scenarios[c(2,3,4,5, 11,12,13,14, 20,21,22,23, 29,30,31,32 )] #those that involve changes in plankton (all changes)
ben_sc <- scenarios[c(6,7,8,9, 15,16,17,18, 24,25,26,27, 33,34,35,36)] #those that involve changes in benthos (all changes)
kappaUp_sc <- scenarios[c(2,6,11,15,20,24,29,33)] #kappa going up - for either plankton or benthos
kappaDown_sc <- scenarios[c(3,7,12,16,21,25,30,34)] #kappa going down - for either plankton or benthos
slopeUp_sc <- scenarios[c(4,8,13,17,22,26,31,35)] #plankton or benthos slopes getting steeper
slopeDown_sc <- scenarios[c(5,9,14,18,23,27,32,36)] #plankton or benthos slopes getting less shallow


```

### Load model outputs

!!! - Here I use files where for each parameter combination we calculate difference from the baseline as (scenario-baseline)/baseline - !!!

```{r, eval = F}
## This is the data we have: 

load(file = "plotData/biom_relative.RData") # biomasses of species relative to the baseline scenario 
load(file = "plotData/prolarfish_relative.RData") # relative proportion of large fish (above maturation weight)
load(file = "plotData/yield_relative.RData") #mean weight of fish above the maturation weight - relative
load(file = "plotData/size_relative.RData") 

# load(file = "plotData/size_tozero.RData") # mean weight of fish above 5cm lenght - relative
# load(file = "plotData/biom_tozero.RData") #mean weight above 10am length
##load(file = "plotData/yield_diff.RData") ## this one has a bug so don't use it (division by 0)
 
#various community slopes: CHECK THAT I DID NOT MIX INTERCEPT AND SLOPE!!! 
#load(file = "plotData/commSlope_diff.RData")
#load(file = "plotData/commSlopeFish_diff.RData")
#load(file = "plotData/commSlopeBent_diff.RData")
#load(file = "plotData/commSlopePred_diff.RData")
#load(file = "plotData/commSlopePlan_diff.RData")
#load(file = "plotData/commSlopeHerb_diff.RData")

```

### Biomass in each species

!!! Here I use files where for each parameter combination we calculate difference from the baseline as (scenario-baseline)/baseline !!!

We have various statistics that we can plot to illustrate differences from the baseline scenario 
Remember we have 9 productivity scenarios x 2 warming levels x 2 fishing levels x 17 species x 29 parameter combinations
The first three terms are all grouped into 36 scenarios


```{r}
#once the dataframe is ready make a plot with it
load(file = "plotData/biom_relative.RData")

#list of species 
mariaParams$species
#their maximum sizes 
mariaParams$w_inf
#funtional groups 
mariaParams$funcgr

# I save all 17 plots in a list and then we can plot them on a grid
plots <- list()

for (i in 1:17) {

sp_name <- as.character(mariaParams$species[i])
df_sp <- biomass_df %>% filter(species == sp_name)

#title = "Relative mean weight of mature fish"
title = "Biomass"

plots[[i]] <- ggplot(df_sp, aes(x = prodScen, y =value, color = warming)) +
#  geom_boxplot(notch = T, fill = "grey", outlier.colour = 'black', outlier.shape = 1) + 
  geom_boxplot(notch = F, outlier.shape = NA, alpha = 1) + 
  facet_grid(~fishing, scale = "fixed",labeller = label_both) +
    theme_bw() +
  ylim(-1, 1.5) + 
  scale_colour_manual(values=c("blue", "red")) +
     theme(
 #   panel.grid.major = element_blank(), 
 #  panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position="none",
    axis.text=element_text(size=12)
  ) +
 # theme_minimal() +
   # labs(x = "productivity scenario",         y = "relative change",
   #       fill = "") +
  geom_hline(yintercept = 0) +
  #ggtitle(paste(title, ":", sp_name)) +
  ggtitle(sp_name)
}

#now plot benthivores 
which(mariaParams$funcgr == "omni")

#now plot them 
plot_grid(plots[[1]], plots[[2]], plots[[6]], plots[[7]], plots[[8]], plots[[9]], plots[[10]], plots[[11]], ncol =4, nrow = 2)

#which are planktivores? 
which(mariaParams$funcgr == "plankt") #3 4
#and herbivores?
which(mariaParams$funcgr == "herbi") #13 14 16

#now plot them 
plot_grid(plots[[3]], plots[[4]], plots[[13]], plots[[14]], plots[[16]], ncol =3, nrow = 2)

#and predators?
which(mariaParams$funcgr == "predat") #5 12 15 17

plot_grid(plots[[5]], plots[[12]], plots[[15]], plots[[17]], ncol =2, nrow = 2)

```

### Mean weight in each species

Here we plot mean size of all individuals above 5cm threshold. This uses the same code as above for the biomass except we use a different dataframe, where I saved mean size (from mizer function getMeanWeight)  using the minimum threshold of 5cm length. To convert 5cm to weight (used in mizer) I used RLS length_weight relationships (can be found in mariaParams$a and mariaParams$b)

```{r}

## load the dataframe with biomass differences from baseline
load(file = "plotData/meanwgt5_df.RData")

# I save all 17 plots in a list and then we can plot them on a grid
plots <- list()

for (i in 1:17) {

sp_name <- as.character(mariaParams$species[i])
df_sp <- meanwgt5_df %>% filter(species == sp_name)

#title = "Relative mean weight of mature fish"
title = "Biomass"

plots[[i]] <- ggplot(df_sp, aes(x = prodScen, y =value, color = warming)) +
#  geom_boxplot(notch = T, fill = "grey", outlier.colour = 'black', outlier.shape = 1) + 
  geom_boxplot(notch = F, outlier.shape = NA, alpha = 1) + 
  facet_grid(~fishing, scale = "fixed",labeller = label_both) +
    theme_bw() +
  scale_colour_manual(values=c("blue", "red")) +
     theme(
 #   panel.grid.major = element_blank(), 
 #  panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position="none",
    axis.text=element_text(size=12)
  ) +
 # theme_minimal() +
   # labs(x = "productivity scenario",         y = "relative change",
   #       fill = "") +
  geom_hline(yintercept = 0) +
  #ggtitle(paste(title, ":", sp_name)) +
  ggtitle(sp_name)
}

#now plot benthivores 
#which(mariaParams$funcgr == "omni")

#now plot them 
plot_grid(plots[[1]], plots[[2]], plots[[6]], plots[[7]], plots[[8]], plots[[9]], plots[[10]], plots[[11]], ncol =4, nrow = 2)

#which are planktivores? 
#which(mariaParams$funcgr == "plankt") #3 4
#and herbivores?
#which(mariaParams$funcgr == "herbi") #13 14 16

#now plot them 
plot_grid(plots[[3]], plots[[4]], plots[[13]], plots[[14]], plots[[16]], ncol =3, nrow = 2)

#and predators?
#which(mariaParams$funcgr == "predat") #5 12 15 17

plot_grid(plots[[5]], plots[[12]], plots[[15]], plots[[17]], ncol =2, nrow = 2)

```

### Biomass per scenario 

Alternatively we plot one scenario only and order species in a nice way
Scenarios are: 
0 - baseline 
1 - more plankton 
2 - more benthos 
3 - less plankton 
4 - less benthos 
5 - steeper plankton slope
6 - steeper benthos slope 
7 - shallower plankton slope 
8 - shallower benthos slope

```{r}

load(file = "plotData/biomass_df.RData")

## select scenario 

## for now filter fishing scenarios out 

#put plots in a list
plots <- list()

for (i in 1:length(unique(biomass_df$prodScen))) {
df_sc <- biomass_df %>% filter (fishing == 0) %>% filter (prodScen == i-1)

plots[[i]] <- 
  ggplot(df_sc, aes(x = species, y =value, color = warming)) +
  geom_boxplot(notch = F, outlier.shape = NA, alpha = 1) + 
  facet_grid(~prodScen, scale = "fixed",labeller = label_both) +
    theme_bw() +
  scale_colour_manual(values=c("blue", "red")) +
    ylim(-0.5, 0.75) +   # add ylim to remove the outlier 
     theme(
 #   panel.grid.major = element_blank(), 
 #  panel.grid.minor = element_blank(),
    axis.text.x  = element_text(angle=90,hjust = 1, vjust=0.5,size=8),   
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position="none",
    axis.text=element_text(size=12)) +
 # theme_minimal() +
   # labs(x = "productivity scenario",         y = "relative change",
   #       fill = "") +
  geom_hline(yintercept = 0) 
}


plot_grid(plots[[2]], plots[[3]], plots[[4]],plots[[5]], plots[[6]], plots[[7]], plots[[8]], plots[[8]], ncol =2, nrow = 4)

plots[[1]]


```

### Mean size per scenario

```{r}

load(file = "plotData/meanwgt5_df.RData")

## select scenario 

## for now filter fishing scenarios out 

#put plots in a list
plots <- list()

for (i in 1:length(unique(biomass_df$prodScen))) {
 df_sc <- meanwgt5_df %>% filter (fishing == 1) %>% filter (prodScen == i-1)
  
plots[[i]] <- 
  ggplot(df_sc, aes(x = species, y =value, color = warming)) +
  geom_boxplot(notch = F, outlier.shape = NA, alpha = 1) + 
  facet_grid(~prodScen, scale = "fixed",labeller = label_both) +
    theme_bw() +
  scale_colour_manual(values=c("blue", "red")) +
    ylim(-0.25, 0.5) +   # add ylim to remove the outlier 
     theme(
 #   panel.grid.major = element_blank(), 
 #  panel.grid.minor = element_blank(),
    axis.text.x  = element_text(angle=90,hjust = 1, vjust=0.5,size=8),   
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position="none",
    axis.text=element_text(size=12)) +
 # theme_minimal() +
   # labs(x = "productivity scenario",         y = "relative change",
   #       fill = "") +
  geom_hline(yintercept = 0) 
}


plot_grid(plots[[2]], plots[[3]], plots[[4]],plots[[5]], plots[[6]], plots[[7]], plots[[8]], plots[[8]], ncol =2, nrow = 4)

plots[[1]]


```

### Yield in each species

```{r}
#once the dataframe is ready make a plot with it
load(file = "plotData/yield_tozero.RData") #this is scaled to zero not to 1

# I save all 17 plots in a list and then we can plot them on a grid

speciesList <- mariaParams$species[c(1,2,4:17)]
plots <- list()

for (i in 1:16) {

sp_name <- as.character(speciesList[i])
df_sp <- biomass_df %>% filter(species == sp_name)

#title = "Relative mean weight of mature fish"
title = "Yield"

plots[[i]] <- ggplot(df_sp, aes(x = prodScen, y =value, color = warming)) +
#  geom_boxplot(notch = T, fill = "grey", outlier.colour = 'black', outlier.shape = 1) + 
  geom_boxplot(notch = F, outlier.shape = NA, alpha = 1) + 
 # facet_grid(~fishing, scale = "fixed",labeller = label_both) +
    theme_bw() +
  ylim(-1, 1.5) + 
  scale_colour_manual(values=c("blue", "red")) +
     theme(
 #   panel.grid.major = element_blank(), 
 #  panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position="none",
    axis.text=element_text(size=12)
  ) +
 # theme_minimal() +
   # labs(x = "productivity scenario",         y = "relative change",
   #       fill = "") +
  geom_hline(yintercept = 0) +
  #ggtitle(paste(title, ":", sp_name)) +
  ggtitle(sp_name)
}

#plot benthivores = NOTE, numbers are changed because we don't have T_caudimaculatus here 
plot_grid(plots[[1]], plots[[2]], plots[[5]], plots[[6]], plots[[7]], plots[[7]], plots[[9]], plots[[10]], ncol =4, nrow = 2)

#remaining ones, except T_caudimaculatus
plot_grid(plots[[3]], plots[[12]], plots[[13]], plots[[15]], plots[[4]], plots[[11]], plots[[14]], plots[[16]], ncol =4, nrow = 2)

#and predators?
which(mariaParams$funcgr == "predat") #5 12 15 17

plot_grid(plots[[5]], plots[[12]], plots[[15]], plots[[17]], ncol =2, nrow = 2)

```

### ###################### 
### ANOVA

### packages

```{r}
library(knitr)
library(lattice)
library(effects)
library(MuMIn)
library(MASS)
#library(hrbrthemes)
library(emmeans)
library(lme4)
library(sjPlot)
library(merTools)
library(ggpubr)
#install.packages("fishualize")
library(fishualize)
#install.packages("glmmTMB")
library(glmmTMB)

library(tidyverse)

```

### main analyses

After various explorations (see in the leftover section) it was found that mixed effect model with two-way anova is the way to go

```{r}
#ptest <- df_be_bio %>% filter(funcgr == "predat") %>% filter (warming == 1)
## these are the three response variable datasets:
load(file = "plotData/biom_relative.RData") # biomasses of species relative to the baseline scenario 
load(file = "plotData/yield_relative.RData") #mean weight of fish above the maturation weight - relative
load(file = "plotData/size_relative.RData") 
load(file = "plotData/size_relativeN.RData") 
load(file = "plotData/size_relativeMat.RData")

# function to make it easier to extract and re-filter the data, assume only kappas here but could easily add slope if needed

getData <- function(dat=biom_relative,resource="benthic",slopes=F) {
  df <- dat
 
   if (resource == "benthic" & slopes ==F) {
  df <- df %>% filter (prodScen == 0 | prodScen == 2 | prodScen == 4)   %>%
      filter (fishing == 1)
  df$backgr <- df$product
  }

  if (resource == "benthic" & slopes ==T) {
  df <- df %>% filter (prodScen == 0 | prodScen == 6 | prodScen == 8) %>% filter (fishing == 1)
  df$backgr <- df$slopeChange
  }

  if (resource == "plankton" & slopes ==F) {
  df <- df %>% filter (prodScen == 0 | prodScen == 1 | prodScen == 3)   %>%     filter (fishing == 1)
  df$backgr <- df$product
  }
  
   if (resource == "plankton" & slopes ==T) {
  df <- df %>% filter (prodScen == 0 | prodScen == 5 | prodScen == 7) %>% filter (fishing == 1)
  df$backgr <- df$slopeChange
  }
  
 df   
 
}

### FUNCTIONAL GROUPS -  MIXED EFFECTS MODEL

options(na.action = na.fail)

### kappas
# these data now all need separate anovas
df_be_bio<-getData(dat=biom_relative,resource="benthic")
df_pl_bio<-getData(dat=biom_relative,resource="plankton")

df_be_size<-getData(dat=size_relative,resource="benthic")
df_pl_size<-getData(dat=size_relative,resource="plankton")

df_be_sizeN<-getData(dat=size_relativeN,resource="benthic")
df_pl_sizeN<-getData(dat=size_relativeN,resource="plankton")

df_be_sizeMat<-getData(dat=size_relativeMat,resource="benthic")
df_pl_sizeMat<-getData(dat=size_relativeMat,resource="plankton")

df_be_yield<-getData(dat=yield_relative,resource="benthic")
df_pl_yield<-getData(dat=yield_relative,resource="plankton")

# df_be_sizeMat<-getData(dat=size_relativeMat,resource="benthic")
# df_pl_sizeMat<-getData(dat=size_relativeMat,resource="plankton")

# We don't do lambdas at the moment
### lambdas
# these data now all need separate anovas
# df_be_bio<-getData(dat=biom_relative,resource="benthic",slopes=T)
# df_pl_bio<-getData(dat=biom_relative,resource="plankton",slopes=T)
# 
# df_be_size<-getData(dat=size_relative,resource="benthic",slopes=T)
# df_pl_size<-getData(dat=size_relative,resource="plankton",slopes=T)
# 
# df_be_yield<-getData(dat=yield_relative,resource="benthic",slopes=T)
# df_pl_yield<-getData(dat=yield_relative,resource="plankton",slopes=T)

####### benthic models

# to be consistent across groups and datatypes we use two-way anova with species as random effect 

#mbe_bio <- lmer(value ~ 1 + warming*backgr*funcgr + (1|funcgr:species), data = df_be_bio, REML = F)
# refit best model
#mbe_bio <- lmer(value ~ 1 + funcgr*backgr*warming + (1|funcgr:species), data = df_be_bio, REML = T)

#mbe_bio <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_be_bio, REML = T)
mbe_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_bio, REML = T)
#mbe_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_be_bio, REML = T)
#dredge(mbe_bio) # check
#plot_model(mbe_bio,type="diag") # check

t1 <- data.frame(coef(summary(mbe_bio)))
t2 <- data.frame(confint(mbe_bio))
t_mbe_bio <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

#write.table(t, file = "model_out.txt", sep = ", ", quote = FALSE, row.names = F)

anova(mbe_bio)
plot_model(mbe_bio,type="pred",terms=c("funcgr","backgr","warming")) # check
summary(mbe_bio)

#three way interaction is needed, model without it is worse. Same results if using nested or non nested random effects
# mbe_bio2 <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_bio, REML = T)
# anova(mbe_bio, mbe_bio2)

# mbe_size <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_be_sizeN, REML = F)
# mbe_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_size, REML = F)
 mbe_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_sizeN, REML = F)
# mbe_sizeMat <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_sizeMat, REML = F)

 #mbe_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_be_size, REML = F)
#dredge(mbe_size) # check
#plot_model(mbe_size,type="diag") # check
#refit best model

# mbe_size_2 <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_size, REML = T)
# anova(mbe_size, mbe_size_2) #here we don't need 3 way interaction

# mbe_sizeMat <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_sizeMat, REML = F)
#
 
plot_model(mbe_size,type="pred",terms=c("funcgr","backgr","warming")) 
#plot_model(mbe_sizeN,type="pred",terms=c("funcgr","backgr","warming")) 
#plot_model(mbe_sizeMat,type="pred",terms=c("funcgr","backgr","warming")) 
#plot_model(mbe_size_2,type="pred",terms=c("funcgr","backgr","warming")) - but results are very similar 

t1 <- data.frame(coef(summary(mbe_size)))
t2 <- data.frame(confint(mbe_size))
t_mbe_size <- cbind(t1[,1], t2[-c(1,2),], t1[,3])



# mbe_yield <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_be_yield, REML = F)
 mbe_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_yield, REML = F)
# mbe_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_be_yield, REML = F)

#dredge(mbe_yield) # check
#plot_model(mbe_yield,type="diag")# check
#refit best model
# mbe_yield_2 <- lmer(value ~ 1 + backgr*funcgr + backgr*warming + funcgr*warming+ (1|species), data = df_be_yield, REML = T)
# anova(mbe_yield, mbe_yield_2) #again 3way interaction not significant, but again in model predictions effects are very minor

plot_model(mbe_yield,type="pred",terms=c("funcgr","backgr","warming")) 
#plot_model(mbe_yield_2,type="pred",terms=c("funcgr","backgr","warming")) 

t1 <- data.frame(coef(summary(mbe_yield)))
t2 <- data.frame(confint(mbe_yield))
t_mbe_yield <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

knitr::kable(list(t_mbe_bio, t_mbe_yield, t_mbe_size), format = "simple", digits = 3, col.names = c("Estimate", "2.5%CI", "97.5%CI", "t-value"))
write.table(rbind(t_mbe_bio, t_mbe_yield, t_mbe_size), file = "temp.csv", sep = ",", quote = FALSE, row.names = F)

####### plankton models

#mpl_bio <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_pl_bio, REML = T)
mpl_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_bio, REML = T)
#mpl_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_pl_bio, REML = T)
#dredge(mpl_bio) # check
#plot_model(mpl_bio,type="diag") # check
# refit best model
#mpl_bio <- lmer(value ~ 1 + funcgr*backgr*warming + (1|funcgr:species), data = df_pl_bio, REML = T)
anova(mpl_bio)
plot_model(mpl_bio,type="pred",terms=c("funcgr","backgr","warming")) # check

t1 <- data.frame(coef(summary(mpl_bio)))
t2 <- data.frame(confint(mpl_bio))
t_mpl_bio <- cbind(t1[,1], t2[-c(1,2),], t1[,3])


#mpl_size <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_pl_sizeN, REML = T)
mpl_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_sizeN, REML = T)
#mpl_sizeN <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_sizeN, REML = T)
#mpl_sizeMat <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_sizeMat, REML = T)

#mpl_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_pl_size, REML = T)
dredge(mpl_size) # check
#plot_model(mpl_size,type="diag") # check
#refit best model
#mpl_size <- lmer(value ~ 1 + backgr*funcgr + backgr*warming + (1|funcgr:species), data = df_pl_size, REML = T)
anova(mpl_size)
plot_model(mpl_size,type="pred",terms=c("funcgr","backgr","warming")) # check
#plot_model(mpl_sizeN,type="pred",terms=c("funcgr","backgr","warming")) # check
#plot_model(mpl_sizeMat,type="pred",terms=c("funcgr","backgr","warming")) # check

t1 <- data.frame(coef(summary(mpl_size)))
t2 <- data.frame(confint(mpl_size))
t_mpl_size <- cbind(t1[,1], t2[-c(1,2),], t1[,3])


#mpl_yield <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_pl_yield, REML = T)
mpl_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_yield, REML = T)
#mpl_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_pl_yield, REML = T)
dredge(mpl_yield) # check
#plot_model(mpl_yield,type="diag")# check
#refit best model
#mpl_yield <- lmer(value ~ 1 + backgr*funcgr*warming + (1|funcgr:species), data = df_pl_yield, REML = T)
anova(mpl_yield)
plot_model(mpl_yield,type="pred",terms=c("funcgr","backgr","warming")) # check

t1 <- data.frame(coef(summary(mpl_yield)))
t2 <- data.frame(confint(mpl_yield))
t_mpl_yield <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

knitr::kable(list(t_mpl_bio, t_mpl_yield, t_mpl_size), format = "simple", digits = 3, col.names = c("Estimate", "2.5%CI", "97.5%CI", "t-value"))


### combine model results into a table format
sstable<-rbind(anova(mpl_bio), anova(mpl_yield), anova(mpl_size), anova(mbe_bio), anova(mbe_yield), anova(mbe_size))

sstable <- anova(mbe_bio)

sstable$pes <- c(sstable$'Sum Sq'[-nrow(sstable)], NA)/(sstable$'Sum Sq' + sstable$'Sum Sq'[nrow(sstable)]) # SS for each effect divided by the last SS (SS_residual)
sstable
kable(sstable, digits = 2, knitr.kable.NA = " ") # the digits argument controls rounding

sstable$pes <- c(sstable$'Sum Sq'[-nrow(sstable)], NA)/(sstable$'Sum Sq' + sstable$'Sum Sq'[nrow(sstable)]) # SS for each effect divided by the last SS (SS_residual)

# 
# myTable <- dredge(m1)
# myTable$`(Intercept)`<-round(myTable$`(Intercept)`,digits = 2)
# myTable$logLik <- round(myTable$logLik, digits = 2)
# myTable$AICc <- round(myTable$AICc, digits = 2)
# myTable$delta <- round(myTable$delta, digits =2)
# myTable$weight <- round(myTable$weight, digits = 2)
# myTable <- myTable[1:10,]
# colnames(myTable)[2:8] <- c("fsh","prd","sp","fsh:prd","fsh:sp","prd:sp","f:p:s")
# saveRDS(myTable, file = "ModelSelectionTable.rds")
#  
# kable(dredge(m1), digits = 3,knitr.kable.NA = '') # the digits argument controls rounding


```

### Get and save model predictions

```{r,warnings=F}

### extract predictions ... predict works ok for this, because we dont need 95CIs for this plot (eg. fixed effects only)

library(ggeffects)
# get predicted values for each model

#### plankton models
pred <- rbind(
as.data.frame(ggpredict(mpl_bio, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mpl_size, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mpl_sizeN, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mpl_sizeMat, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mpl_yield, terms =c("funcgr","backgr","warming"))))

names(pred)<- c("funcgr"     ,    "fit", "stderror" ,"conflow" , "confhigh" ,"backgr"  ,   "warming")

pred$index <- rep(c("bio","size","sizeN","sizeMat","yield"),each=24)

predn <- pred

save(predn, file = "plotData/anovaPredPlan2wayNotNested_big.RData")

#### benthic models
predb <- rbind(
as.data.frame(ggpredict(mbe_bio, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mbe_size, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mbe_sizeN, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mbe_sizeMat, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mbe_yield, terms =c("funcgr","backgr","warming"))))

names(predb)<-c("funcgr"     ,    "fit", "stderror" ,"conflow" , "confhigh" ,"backgr"  ,   "warming")
predb$index <- rep(c("bio","size","sizeN","sizeMat","yield"),each=24)

predbn <- predb

save(predbn, file = "plotData/anovaPredBent2wayNotNested_big.RData")
```

### Fig 4: anova plot

```{r}

load(file = "anovaNew/anovaBenthos.RData") #dataframe predbn
load(file = "anovaNew/anovaPlankton.RData") #dataframe predn

head(predbn) #benthos
head(predn) #plankton

library(ggplot2)
library(tidyverse)

plotThis<-function(predn){
  
  #predn<-predbn
  
  # functional group vs anova fit
  predn$index<-as.factor(predn$index)
  predn$index <- ordered(predn$index, levels = c("bio", "yield", "size", "sizeN", "sizeMat"))
  # new facet label names
  temp.labs<- c("BIOMASS", "YIELD", "SIZE","SIZE N", "SIZE MAT") # for MS where you show only kappa
  names(temp.labs) <- c("B","Y", "S","sizeN","sizeMat")
  
  # y axis 
  predn$funcgr<-as.factor(predn$funcgr)
  predn$funcgr <- ordered(predn$funcgr, levels = c("predat", "herbi", "plankt","omni"))
  #labely = c("Predators","Herbivores", "Planktivores", "Benthivores")
  
  #Names list for the facet:
  names2 <- c('Predators','Herbivores','Planktivores','Benthivores')
  names(names2) <- c( 'predat', 'herbi', 'plankt','omni')
  
  # x axis  
  title<-"ANOVA fit"
  
  # legend
  predn <-predn %>% 
    mutate(backgr = ifelse(backgr == 0, "no change", ifelse(backgr == 1, "increase", "decrease")), 
           warming = ifelse(warming == 0, "no warming", "warming"), 
           new = as.factor(paste(backgr, warming, sep = " ")))
  
  predn$new <- ordered(predn$new, levels = c("increase no warming", "decrease no warming", "increase warming", "decrease warming", "no change warming", "no change no warming")) # plots 
  label1 <- c("Increase", "Decrease", "Increase & warming","Decrease & warming","Warming", "No changes")
  color1<-c("#9ecae1", "#3182bd", "#fdd0a2", "#fd8d3c", "red","black")
  shape1<-c(19, 17, 19, 17, 18, 19)
  
  predn2<-predn %>% 
    filter(index %in% c("bio","sizeN","yield")) %>% 
    filter(new !=  "no change no warming") # this is just on the 1 line 
  
  # explore limits for each trophic group + index (min and max, for the arrows)
  # min(predn2$fit) # 0.24
  # max(predn2$fit) # 2.23
  
  #Create a dataframe for the arrows: 
  arrow_frame  <- data.frame(
                    y1 = c(0.65,0.65,0.65,0.65), #y axis (slightly left of the biomass y)
                    x1 = c(1,1,1,1), #starting point for the arrow
                    #end point of the arrow+direction:
                    x2 = c(max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='predat'&predn2$backgr=='increase']), max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='herbi'&predn2$backgr=='increase']), max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='plankt'&predn2$backgr=='increase']),max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='omni'&predn2$backgr=='increase'])),
                    funcgr = (levels(predn2$funcgr))) #assign the functional group
  
  pd<-position_dodge(0.3)
  
  plot<-ggplot(predn2, aes(x=fit, y=index, group=new, colour=new, shape=new))+
    geom_vline(xintercept = 1, linetype = "dashed", color='darkgrey')+
    geom_hline(yintercept = 3.6, linetype = "dashed", color='grey85')+
    geom_errorbar(aes(xmin=conflow, xmax=confhigh), width=0.1, position=pd, alpha=0.5)+
    geom_point(position=pd, size=2)+
    
    #add arrows that indicate an increase in biomass, when benthos/plankton increases. From 1 to light blue dot. Positive when >0, negative when <0
    #each geom_segment creates own arrow for each facet (functional group in this case)
    geom_segment(data=arrow_frame,   
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05), 
                 lineend = "butt", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    geom_segment(data=arrow_frame,
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05),
                 lineend = "round", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    geom_segment(data=arrow_frame,
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05),
                 lineend = "round", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    geom_segment(data=arrow_frame, 
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05), 
                 lineend = "round", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    
    #no more missing values when set to 0.5 to 1.7 (only the two outliers from 1.9-2.4 for plankton + 2 from 0-0.5, all for Planktivores/Yield)
    scale_x_continuous(name = "Relative change", limit=c(0.6,1.6))+ # , breaks=c(0.6,1,1.6), labels=c("0.6"="-0.6","1"="0","1.6"="0.6")) +
    scale_y_discrete(name = NULL, labels = names(temp.labs))+
    scale_color_manual(values = color1,
                       name = "Scenario",
                       labels = label1)+
    scale_shape_manual(values = shape1,
                       name = "Scenario",
                       labels = label1)+ 
    theme_bw()+
    theme(text = element_text(size=10),
          legend.key.size = unit(0.4, "cm"),
          axis.title.y = element_text(vjust=0.4, size = 8),
          axis.title.x = element_text(vjust=0.5, size = 12),
          axis.text.x = element_text(hjust=0.5, size = 8),
          axis.text.y = element_text(size = 8),
          plot.margin = unit(c(0, 0, 0, 0), "cm"), #top, right, bottom, left
          strip.background = element_rect(color = "white", fill = "lightgrey"), 
          # Remove panel border
          panel.border = element_blank(),  
          # Remove panel grid lines
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          # Remove panel background
          panel.background = element_rect(fill = "grey99"),
          # Add axis line
          axis.line = element_line(colour = "grey"))+
     facet_wrap(~funcgr,
               labeller = labeller(funcgr = names2), 
               nrow = 1)+
    coord_flip() #flip the axes, having Anova fit on the x-axis for better readability

  return(plot = plot)
}

plot1 <- plotThis(predbn) #benthos
plot2 <- plotThis(predn) #plankton

#3. plot showing the upper outliers (will get stagged on the other plot)
plot3 <- plot2 + 
          scale_x_continuous(name = "Relative change", limit=c(1.9,2.4), breaks=c(1.9,2.4)) + #adapting the scale for the staggered plot
          theme( #remove axis labels, text + line
            axis.title.x=element_blank(),
            axis.title.y=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank(),
            axis.line.x = element_blank(),
            plot.margin = unit(c(0, 0, 0.5, 0), "cm")) #add some space to the other plot

#remove the strip text for the facets, will only be on the second plot
plot1 <- plot1 + theme(
          strip.background = element_blank(),
          strip.text.x = element_blank())
plot2 <- plot2 + theme(
          strip.background = element_blank(),
          strip.text.x = element_blank())

#Libraries for the final plot arrangement & pictures:
library(patchwork)
library(png)
library(grid)

#Load images and safe them as plots:

herbi <- png::readPNG("anovaNew/herbivore2.png")
plankt <- png::readPNG("anovaNew/planktivore2.png")
benthi <- png::readPNG("anovaNew/benthivore2.png")
predat <- png::readPNG("anovaNew/predator2.png")

plot_h <- ggplot()+ annotation_custom(rasterGrob(herbi,width = unit(1,"npc"), height = unit(1,"npc")),  -Inf, Inf, -Inf, Inf) 
plot_p <- ggplot()+ annotation_custom(rasterGrob(plankt, width = unit(1,"npc"), height = unit(1,"npc")), -Inf, Inf, -Inf, Inf) 
plot_b <- ggplot()+ annotation_custom(rasterGrob(benthi, width = unit(1,"npc"), height = unit(1,"npc")), -Inf, Inf, -Inf, Inf) 
plot_pred <-  ggplot()+ annotation_custom(rasterGrob(predat, width = unit(1,"npc"), height = unit(1,"npc")), -Inf, Inf, -Inf, Inf) 

#Add the plankton/benthos image above legends. Maybe raster package? Adding image into the PDF... 

#plankton <- png::readPNG("plankton-01.png")
#benthos <- png::readPNG("benthos-01.png")
#plot_plankton <- ggplot()+ annotation_custom(rasterGrob(plankton,width = unit(1,"npc"), height = unit(1,"npc")),  -Inf, Inf, -Inf, Inf) 
#plot_benthos <- ggplot()+ annotation_custom(rasterGrob(benthos,width = unit(1,"npc"), height = unit(1,"npc")),  -Inf, Inf, -Inf, Inf) 

#put all plots in one. Fish pictures in between the two plots. The legends are collected in one. Heights specified. 

patchwork <- (plot3/plot2/(plot_pred|plot_h|plot_p|plot_b)/plot1)+
             plot_layout(guides = 'collect', height=c(3,8,2,8,2))
patchwork

pdf("Fig4.pdf",width=9)
patchwork
dev.off()


```

### Numbers at size for one species

```{r}


#load(file = "modelParams/empSizes.RData") #empirical numbers at size and weight
load(file = "outputs/numb.RData")
#also load params@ file for w and dw information 
load(file = "modelParams/params_N19.RData")
load(file = "modelParams/mariaParamsMs.RData")
mariaParams$cm2_5 <- mariaParams$a *2.5^mariaParams$b 

#load(file ="plotData/numb_tozero.RData")

#for (g in 1:17){

### Need to chose which species will be used here to illustrate the effects 

#  [1] "baseline_12_f0"     "more_plankt_12_f0"  "less_plankt_12_f0"  "small_plankt_12_f0" "large_plankt_12_f0" "more_benth_12_f0"   "less_benth_12_f0"   "small_benth_12_f0" 
#  [9] "large_benth_12_f0"  "baseline_14_f0"     "more_plankt_14_f0"  "less_plankt_14_f0"  "small_plankt_14_f0" "large_plankt_14_f0" "more_benth_14_f0"   "less_benth_14_f0"  
# [17] "small_benth_14_f0"  "large_benth_14_f0"  "baseline_12_f2"     "more_plankt_12_f2"  "less_plankt_12_f2"  "small_plankt_12_f2" "large_plankt_12_f2" "more_benth_12_f2"  
# [25] "less_benth_12_f2"   "small_benth_12_f2"  "large_benth_12_f2"  "baseline_14_f2"     "more_plankt_14_f2"  "less_plankt_14_f2"  "small_plankt_14_f2" "large_plankt_14_f2"
# [33] "more_benth_14_f2"   "less_benth_14_f2"   "small_benth_14_f2"  "large_benth_14_f2" 

mariaParams$species
#select species number
sp_number <- 1
sp_name <- as.character(mariaParams$species[sp_number])
numb_sp <- numb_all[,sp_number,,]

#sp1emp <- empSizes %>% filter(modelName == params@species_params$species[sp_number]) #%>% filter (wgt >9)

#select which scenarios to plot
base <- numb_sp[1,,]
scen1  <- numb_sp[which(fish_sc == "more_benth_12_f2"),,] #more benthos no warming
scen2  <- numb_sp[which(fish_sc == "less_benth_12_f2"),,] #less benthos no warming
scen3  <- numb_sp[which(fish_sc == "baseline_14_f2"),,] #baseline with warming
#scen4  <- numb_sp[which(scenarios == "less_benth_14_f2"),,] #less benthos with warming


##
par(mfrow = c(1,3))

# plot baseline for all 29 parameter combinations 
plot(log10(params@w), log10(base[,1]*params@dw), type = 'l', col = "grey", ylim = c(-5, -2), main = params@species_params$species[sp_number], xlab = "log10size, g", ylab = "numbers ")
for (i in 2:29) {
  points(log10(params@w), log10(base[,i]*params@dw), type = 'l', col = "darkgrey")
  
}
#more benthos
for (i in 1:29) {
  points(log10(params@w), log10(scen1[,i]*params@dw), type = 'l', col = "skyblue")
  
}
abline(v = log10(mariaParams$cm2_5[sp_number]), lty = 2)
abline(v = log10(mariaParams$cm5[sp_number]), lty = 2)
#abline(v = log10(mariaParams$cm10[sp_number]), lty = 2)
abline(v = log10(mariaParams$w_mat[sp_number]), lty = 2, col = "blue")



# plot baseline for all 29 parameter combinations 
plot(log10(params@w), log10(base[,1]*params@dw), type = 'l', col = "grey", ylim = c(-5, -2), main = params@species_params$species[sp_number], xlab = "log10size, g", ylab = "numbers ")
for (i in 2:29) {
  points(log10(params@w), log10(base[,i]*params@dw), type = 'l', col = "darkgrey")
  
}
#less benthos
for (i in 1:29) {
  points(log10(params@w), log10(scen2[,i]*params@dw), type = 'l', col = "lightgreen")
}
abline(v = log10(mariaParams$cm2_5[sp_number]), lty = 2)
abline(v = log10(mariaParams$cm5[sp_number]), lty = 2)
#abline(v = log10(mariaParams$cm10[sp_number]), lty = 2)
abline(v = log10(mariaParams$w_mat[sp_number]), lty = 2, col = "blue")



# plot baseline for all 29 parameter combinations 
plot(log10(params@w), log10(base[,1]*params@dw), type = 'l', col = "grey", ylim = c(-5, -2), main = params@species_params$species[sp_number], xlab = "log10size, g", ylab = "numbers ")
for (i in 2:29) {
  points(log10(params@w), log10(base[,i]*params@dw), type = 'l', col = "darkgrey")
  
}
#warming
 for (i in 1:29) {
   points(log10(params@w), log10(scen3[,i]*params@dw), type = 'l', col = "pink")
   
 }
abline(v = log10(mariaParams$cm2_5[sp_number]), lty = 2)
abline(v = log10(mariaParams$cm5[sp_number]), lty = 2)
#abline(v = log10(mariaParams$cm10[sp_number]), lty = 2)
abline(v = log10(mariaParams$w_mat[sp_number]), lty = 2, col = "blue")



```


```{r}
spec = "T_caudimaculatus"

df <- numbers_plot %>% filter(species == spec)
#df <- numbers_plot %>% filter(funcgr == "omni")

df1 <- df %>% filter (scenario == "more_plankt" | scenario == "less_plankt" | scenario == "small_plankt")

p1 <- ggplot(df1, aes(x = log(sizegroup), y = value, color = scenario)) +
  geom_point(alpha = 0.1) + 
  scale_color_manual(values = c("deepskyblue", "navy", "darkmagenta", "gold", "darkorange2", "red"),
                     labels=c("more plankton", "less plankton", "small plankton", "more benthos", "less benthos", "small benthos"),
                     guides(name = "CC scenario")) + 
  scale_y_continuous(name = spec, limits = c(-1, 2)) + 
  scale_x_continuous(name = "log10(size), g") + 
  ggtitle("plankton") + 
  theme_bw() +
  theme(panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"), 
   #     axis.text.x = element_text(angle = 90, vjust = 0.5), 
        legend.position = "none") +
  geom_hline(yintercept = 0)

df1 <- df %>% filter (scenario == "more_benth" | scenario == "less_benth" | scenario == "small_benth")

p2 <- ggplot(df1, aes(x = log(sizegroup), y = value, color = scenario)) +
  geom_point(alpha = 0.1) + 
  scale_color_manual(values = c("gold", "darkorange2", "red"),
                     labels=c("more benthos", "less benthos", "small benthos"),
                     guides(name = "CC scenario")) + 
  scale_y_continuous(name = NULL, limits = c(-1, 2)) + 
  scale_x_continuous(name = "log10(size), g") + 
  ggtitle("benthos") + 
  theme_bw() +
  theme(panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"), 
   #     axis.text.x = element_text(angle = 90, vjust = 0.5), 
        legend.position = "none") +
  geom_hline(yintercept = 0)

plot_grid(p1, p2)

```


### ####################
### ACTUAL SCENARIO RUNS

### Load params, data & senescence mort

Don't change anything here, these are fixed parameters

```{r}
  load(file = "modelParams/mariaParamsMs.RData") #species parameter file 
  load(file = "modelParams/paramsMs.RData") #built params file
  load(file = "modelParams/inter_N19.RData") #interaction matrix (it is also included in the params file)
  # now load stable numbers at size for all species. I start the runs from equilibrium abundances 
  load(file = "modelParams/abund_N19.RData")
  load(file = "modelParams/npp_N19.RData")
  load(file = "modelParams/nbb_N19.RData")
  load(file = "modelParams/naa_N19.RData")
  
  #load(file = "../modelParams/params194.RData")
  load(file = "modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)
  
#add another column to the parameter file defining weight above 5cm and weight above 10cm in case we want to study changes of mean size above a certain length
      
#weight at 5 cm - we will calculate mean weight of all fish above 5 cm length to compare with observed trends  
mariaParams$cm5 <- mariaParams$a * 5^mariaParams$b 
mariaParams$cm10 <- mariaParams$a * 10 ^mariaParams$b   

## Just in case a wrong parameter file is read, make sure we set mortality activation energy to 0
#mariaParams$ea_mor <- 0
mariaParams$ea_mor <- NA

## also load senescence mortality function (it is not currently in mizerRewire but is added separately)

 #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
  ## we will need to apply temperature scaling to senescence mortality as well, so load the temperature function separatly
  tempFun <- function(temperature, t_ref, Ea, c_a, w) {
  # tempFun returns a matrix with w (size) as columns and temperature as rows

  temperature <- temperature + 273 # converting to Kelvin from Celcius
  t_ref <- t_ref + 273

  temperatureScalar <- t(sapply(w,FUN = function(x){x^(c_a*(temperature-(t_ref)))}) *exp((-Ea/8.617332e-5)*((1/temperature) - (1/(t_ref))))) 

                         return(temperatureScalar)
}


```

### Load scenarios

List of seven productivity scenarios. Each of them will be run 4 times: with and without fishing, with and without heating. 
Note, I used very approximate array of fishing mortality (shown below). This can be updated 

```{r}
#Notolabrus       L_forsteri       T_caudimaculatus C_rasor          D_lewini         leatherjack      C_spectabilis    C_laticeps       P_laticlavius    Boarfish   M_freycineti     P_bachus         O_cyanomelas     A_arctidens      predator         urchins          lobsters  

mariaParams$fishmort <- c(0.15, 0.15, 0, 0.1, 0.15, 0.1, 0.15, 0.1, 0.1, 0.15, 0.15, 0.15, 0.15, 0.15, 0.1, 0.15, 0.15)

#if no fishing is applied 
fish.mort.0 <- rep(0, times = 17)
#a vector of low fishing mortalities
fish.mort.v <- mariaParams$fishmort

  prod_scen<-list( 
  "baseline_12_f0"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "more_plankt_12_f0"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "less_plankt_12_f0"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "small_plankt_12_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "large_plankt_12_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "more_benth_12_f0"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "less_benth_12_f0"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "small_benth_12_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 12, "fmort" = fish.mort.0),
  "large_benth_12_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 12, "fmort" = fish.mort.0),
  
  "baseline_14_f0"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "more_plankt_14_f0"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "less_plankt_14_f0"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "small_plankt_14_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "large_plankt_14_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "more_benth_14_f0"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "less_benth_14_f0"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "small_benth_14_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 14.5, "fmort" = fish.mort.0), 
  "large_benth_14_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 14.5, "fmort" = fish.mort.0), 
  
  "baseline_12_f2"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "more_plankt_12_f2"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "less_plankt_12_f2"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "small_plankt_12_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "large_plankt_12_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "more_benth_12_f2"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "less_benth_12_f2"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "small_benth_12_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 12, "fmort" = fish.mort.v),
  "large_benth_12_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 12, "fmort" = fish.mort.v),
  
  "baseline_14_f2"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "more_plankt_14_f2"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "less_plankt_14_f2"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "small_plankt_14_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "large_plankt_14_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "more_benth_14_f2"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "less_benth_14_f2"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "small_benth_14_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 14.5, "fmort" = fish.mort.v), 
  "large_benth_14_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 14.5, "fmort" = fish.mort.v)) 
 
   
```

### Setup run parameters 

We will heat the model by 2C.5, from tref 12 and constant temperature of 12, to increased temperature of 14.5

```{r}   

## do you want a plot for each run, while the simulations are going? This takes more time but is sometimes fun to watch and keep an eye if there are oscillating dynamics 

showplot = F

  ## setup run time 
  tmax = 100
  #number of size groups 
  no_size_groups = 200
  #timestep used in the integration 
  dt = 0.2
  #our reference temperature 
  temp_ref = 12
  
## fixed background params- THESE ARE NOT CHANGING IN SCENARIOS
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  w_bb_cutoff = 5 #
  r_bb = 1 # 
  min_w_bb = 0.001 # 0.01
  
  #algae are not really size structured food resources, but are treated as such here for now 
  kappa_alg = 16 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 
  min_w_aa = 0.001

## IF calculating diet statistics and food web stats set diet_steps to 2 and storekernel to T. This makes runs MUCH Longer 
  ## Here we are not focusing on diet statistics so we don't use this functionality 

  diet_steps = 0 # this should be 0 or 2
  storekernel = F

```

### Setup arrays to store data 

We will store data on: 
1) Numbers at size to look at species spectra and so on
2) Numbers at size for all background spectra, just in case we need it
3) Proportion of Large fish indicator 
4) Mean weight above some thresholds: two thresholds used are MeanWeight of mature fish (maturation size is a threshold) and MeanWeight of fish above 5cm in length
5) Calculate community slopes: for all species, for fish only (exclude lobsters and urchins), and for four functional groups separately - benthivores, planktivores, herbivores (includes urchins) and predators (includes lobsters)

```{r, eval = F, echo = F, warning=F}  

#setup arrays to store results 

#number of scenarios in a list
scen_num <- length(lengths(prod_scen))
n_spp <- length(params@species_params$species)

numb_all <-array(data=NA,c(scen_num,n_spp,200,dim(params28)[1])) ## 200, 326 or 120 in these dataframes refers to the numbers of size groups in different arrays
biom_all <- array(data=NA, c(scen_num,n_spp, dim(params28)[1]))
plankt_all <- array(data=NA, c(scen_num,326, dim(params28)[1]))
bent_all <- array(data=NA, c(scen_num,120, dim(params28)[1]))
alg_all <- array(data=NA, c(scen_num,153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
Yield_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
#Yield_all[c(1:14),,] <- 0 #no fishing scenarios will have zero yield naturally
MeanWgtMat_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
#MeanWgtHalfMat_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
MeanWgtAbove5_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
MeanWgtAbove10_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
CommSlope_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeFish_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeBent_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopePred_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopePlan_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeHerb_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))

## setup different species groups for community slope calcualtions
  fishonly <- as.character(mariaParams$species[c(1:15)])
  bentiv <- as.character(mariaParams$species[which(mariaParams$funcgr == "omni")])
  plankt <- as.character(mariaParams$species[which(mariaParams$funcgr == "plankt")])
  predat <- as.character(mariaParams$species[which(mariaParams$funcgr == "predat")])
  herbiv <- as.character(mariaParams$species[which(mariaParams$funcgr == "herbi")])


```

### All simulations

This will run 36 scenarios with 29 parameter combinations each and save outputs into data arrays

```{r, eval = F, echo = F, warning = F}
## loop through 36 scenarios

for (scen in 1:scen_num) {
  
## resource params
  kappa = as.numeric(prod_scen[[scen]][1])
  kappa_ben = as.numeric(prod_scen[[scen]][2])  
  lambda = as.numeric(prod_scen[[scen]][3])
  lambda_ben = as.numeric(prod_scen[[scen]][4])
  

#set up the effort array - NOT DONE yet
  fish.mort <- as.numeric(prod_scen[[scen]][6:22])
# fish.mort <- c(0.3, 0.2, 0, 0.1, 0.2, 0.1, 0.3, 0.1, 0.1, 0.2, 0.2, 0.1, 0.1, 0.2, 0.1, 0, 0.3)
  eff_arr <- matrix(rep(fish.mort, times = tmax), nrow = tmax, byrow = TRUE)
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  
## get temperature value for the scenario 
  temp_run <- as.numeric(prod_scen[[scen]][5])

## for each scenario loop through 29 parameter combinations   
    for (iter in 1:dim(params28)[1]) {

  print("scenario = ")
  print (scen)
  print(prod_scen[scen])
  print("iteration out of 29")
  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = storekernel, t_ref = temp_ref)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## because senescence mortality is not in the actual code, but we add it separately, we also need to scale it with temperature manually. Here we assume that all processes scale identically across species and sizes, so we only need to get one scalar value for the activation energy of 0.63. In reality the scaling should probably be size dependent, but we will explore it in future studies. Therefore size dependency of temperature scaling (c_a) is set to 0
  
  senMortScalar <- tempFun(temperature = temp_run, t_ref = temp_ref, Ea = 0.63, c_a = 0, w = params@w)[1,1]
  
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e)*senMortScalar 

  #run the model
  tasm1 <- mizerRewire::project(params, t_max = tmax, effort= eff_arr, dt = dt, temperature = rep(temp_run, 100), diet_steps = diet_steps)

  ### Calculate various statistics inside the run to avoid saving massive model objects
  if (showplot == T) {
      plot(tasm1)
    }
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((mizerRewire::getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtAbove5 <- rep(NA,17)
  MeanWgtAbove10 <- rep(NA,17)

      for (xx in 1:length(mariaParams$species)) {
        PropLarFish[xx] <- mean(mizerRewire::getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[(tmax-29):tmax])
        MeanWgtMat[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[(tmax-29):tmax])
        MeanWgtAbove5[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, min_w = mariaParams$cm5[xx], max_w = mariaParams$w_inf[xx])[(tmax-29):tmax])
        MeanWgtAbove10[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, min_w = mariaParams$cm10[xx], max_w = mariaParams$w_inf[xx])[(tmax-29):tmax])

      }

    
    
  #get mean values of various statistics over the last 30 years and save them in arrays 
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[scen,,iter] <- apply(ttemp, 2, mean)
  numb_all[scen,,,iter] <- numbers
  biom_all[scen,,iter] <- biomass
  PropLarFish_all[scen,,iter] <- PropLarFish
  MeanWgtMat_all[scen,,iter] <- MeanWgtMat
  MeanWgtAbove5_all[scen,,iter] <- MeanWgtAbove5
  MeanWgtAbove10_all[scen,,iter] <- MeanWgtAbove10
  Yield_all[scen,,iter] <- as.numeric(apply((mizerRewire::getYield(tasm1)[c((tmax-29):tmax),]),2,mean))
  CommSlope_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1)[c((tmax-29):tmax),]),2,mean))
  CommSlopeFish_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = fishonly)[c((tmax-29):tmax),]),2,mean))
  CommSlopeBent_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = bentiv)[c((tmax-29):tmax),]),2,mean))
  CommSlopePlan_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = plankt)[c((tmax-29):tmax),]),2,mean))
  CommSlopeHerb_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = herbiv)[c((tmax-29):tmax),]),2,mean))
  CommSlopePred_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = predat)[c((tmax-29):tmax),]),2,mean))
  
      if (storekernel == T) {
        foodWebStats <- getFoodWebStats(tasm1, diet_steps = diet_steps)
        filename <- paste("fw_sc",scen,"par", iter, ".rds", sep = "")
        saveRDS(foodWebStats, file = filename)
#        foodWebStats <- append(foodWebStats, food.t)
        }
  
  }

}


```

### Save results

```{r}

save(numb_all, file = "outputs/numb.RData")
save(biom_all, file = "outputs/biom.RData")
save(plankt_all, file = "outputs/plankt.RData")
save(bent_all, file = "outputs/bent.RData")
save(alg_all, file = "outputs/alg.RData")
save(PropLarFish_all, file = "outputs/PropLargFish.RData")
save(MeanWgtMat_all, file = "outputs/MeanWgtMat.RData")
save(MeanWgtAbove5_all, file = "outputs/MeanWgtAbove2_5.RData")
save(MeanWgtAbove10_all, file = "outputs/MeanWgtAbove10.RData")
save(Yield_all, file = "outputs/Yield.RData")
save(CommSlope_all, file = "outputs/CommSlope.RData")
save(CommSlopeFish_all, file = "outputs/CommSlopeFish.RData")
save(CommSlopeBent_all, file = "outputs/CommSlopeBent.RData")
save(CommSlopePlan_all, file = "outputs/CommSlopePlan.RData")
save(CommSlopeHerb_all, file = "outputs/CommSlopeHerb.RData")
save(CommSlopePred_all, file = "outputs/CommSlopePred.RData")

#saveRDS(foodWebStats, file = "../altRuns28/foodwebstats.rds")

```


### ####################
### DATA TRANSFORMATION

what kind of outputs to show 
1. Relative changes in biomasses 
2. Total fish community biomass? 
3. Relative changes in size-at-age 
4. Relative changes in mean size (above 2 cm in length)
5. Entire community size spectrum 
6. Production to biomass ratio

### Load saved results 

```{r}

# load(file = "outputs/numb.RData")
# load(file = "outputs/biom.RData")
# load(file = "outputs/plankt.RData")
# load(file = "outputs/bent.RData")
# load(file = "outputs/alg.RData")
# load(file = "outputs/PropLargFish.RData")
# load(file = "outputs/MeanWgtMat.RData")
# load(file = "outputs/MeanWgtAbove5.RData")
# load(file = "outputs/MeanWgtAbove10.RData")
# load(file = "outputs/CommSlope.RData")
# load(file = "outputs/CommSlopeFish.RData")
# load(file = "outputs/CommSlopeBent.RData")
# load(file = "outputs/CommSlopePlan.RData")
# load(file = "outputs/CommSlopeHerb.RData")
# load(file = "outputs/CommSlopePred.RData")

## if starting from this chunk also load mariaParams to have species information 
load(file = "modelParams/mariaParamsMs.RData")

scenarios<-c("baseline_12_f0", "more_plankt_12_f0", "less_plankt_12_f0","small_plankt_12_f0","large_plankt_12_f0", "more_benth_12_f0","less_benth_12_f0", "small_benth_12_f0","large_benth_12_f0", "baseline_14_f0", "more_plankt_14_f0", "less_plankt_14_f0", "small_plankt_14_f0","large_plankt_14_f0", "more_benth_14_f0","less_benth_14_f0","small_benth_14_f0","large_benth_14_f0","baseline_12_f2", "more_plankt_12_f2", "less_plankt_12_f2","small_plankt_12_f2","large_plankt_12_f2", "more_benth_12_f2","less_benth_12_f2", "small_benth_12_f2","large_benth_12_f2", "baseline_14_f2", "more_plankt_14_f2", "less_plankt_14_f2", "small_plankt_14_f2","large_plankt_14_f2", "more_benth_14_f2","less_benth_14_f2","small_benth_14_f2", "large_benth_14_f2")

species <- as.character(mariaParams$species)
func_group <- as.character(mariaParams$funcgr)

#identify various scenarios
warm_sc <- scenarios[c(10:18, 28:36)] #scenarios with warming
fish_sc <- scenarios[c(19:36)] #scenarios with fishing
pla_sc <- scenarios[c(2,3,4,5, 11,12,13,14, 20,21,22,23, 29,30,31,32 )] #those that involve changes in plankton (all changes)
ben_sc <- scenarios[c(6,7,8,9, 15,16,17,18, 24,25,26,27, 33,34,35,36)] #those that involve changes in benthos (all changes)
kappaUp_sc <- scenarios[c(2,6,11,15,20,24,29,33)] #kappa going up - for either plankton or benthos
kappaDown_sc <- scenarios[c(3,7,12,16,21,25,30,34)] #kappa going down - for either plankton or benthos
slopeUp_sc <- scenarios[c(4,8,13,17,22,26,31,35)] #plankton or benthos slopes getting steeper
slopeDown_sc <- scenarios[c(5,9,14,18,23,27,32,36)] #plankton or benthos slopes getting less shallow

```

### Make dataframes without scaling

melt saved dataframes into a long format, but include the original values, NOT the difference between baseline and changed scenario

#### dataframes 29x17x28

```{r}
### The part below is to be run with all 28x17x29 dataframes to transform them into long format for anova

 load(file = "outputs/biom.RData")
# load(file = "outputs/Yield.RData")
# load(file = "outputs/PropLargFish.RData")
# load(file = "outputs/MeanWgtMat.RData")
# load(file = "outputs/MeanWgtAbove5.RData")
# load(file = "outputs/MeanWgtAbove10.RData")

input_data <- biom_all
#input_data <- Yield_all
#input_data <- PropLarFish_all
#input_data <- MeanWgtMat_all
#input_data <- MeanWgtAbove5_all
#input_data <- MeanWgtAbove10_all


#biomass <- temp
#save(biomass, file = "nonTrData/biomass.RData")
yield <- temp
save(yield, file = "nonTrData/yield.RData")
# proplarfish <- temp
# save(proplarfish, file = "nonTrData/proplarfish.RData")
# meanSize <- temp
# save(meanSize, file = "nonTrData/meanSize.RData")


```

```{r}

temp <- reshape2::melt(input_data, id =1) # reshape into a long format
temp <- cbind(temp, rep(scenarios, length.out = length(temp[,1]))) #add scneario names
temp <- cbind(temp, rep(rep(species, each = length(scenarios)), times = 29)) #add species names
temp <- cbind(temp, rep(rep(func_group, each = length(scenarios)), times = 29)) #add functional group names

#temp <- temp[,-c(1:2)]
colnames(temp) <- c("scen_num", "spp_num", "paramset", "value", "scenario","species", "funcgr")
```

### add qualifiers

```{r}

temp$warming <- 0
temp$warming[which(temp$scenario %in% warm_sc)] <- 1
temp$fishing <- 0
temp$fishing[which(temp$scenario %in% fish_sc)] <- 1
temp$plankt <- 0
temp$plankt[which(temp$scenario %in% pla_sc)] <- 1
temp$bent <- 0
temp$bent[which(temp$scenario %in% ben_sc)] <- 1
temp$kappaUp <- 0
temp$kappaUp[which(temp$scenario %in% kappaUp_sc)] <- 1
temp$kappaDown <- 0
temp$kappaDown[which(temp$scenario %in% kappaDown_sc)] <- 1
temp$slopesUp <- 0
temp$slopesUp[which(temp$scenario %in% slopeUp_sc)] <- 1
temp$slopesDown <- 0
temp$slopesDown[which(temp$scenario %in% slopeDown_sc)] <- 1

temp$product <- 0
temp$product[which(temp$kappaUp == "1")] <- 1
temp$product[which(temp$kappaDown == "1")] <- -1

temp$slopeChange <- 0
temp$slopeChange[which(temp$slopesUp == "1")] <- 1
temp$slopeChange[which(temp$slopesDown == "1")] <- -1

#define productivity scenarios - we have 7 of them, so it is a question on how to rank them
temp$prodScen <- 0
temp$prodScen[which(temp$kappaUp == "1" & temp$plankt == 1)] <- 1
temp$prodScen[which(temp$kappaDown == "1" & temp$plankt == 1)] <- 3
temp$prodScen[which(temp$slopesUp == "1" & temp$plankt == 1)] <- 5
temp$prodScen[which(temp$slopesDown == "1" & temp$plankt == 1)] <- 7
temp$prodScen[which(temp$kappaUp == "1" & temp$bent == 1)] <- 2
temp$prodScen[which(temp$kappaDown == "1" & temp$bent == 1)] <- 4
temp$prodScen[which(temp$slopesUp == "1" & temp$bent == 1)] <- 6
temp$prodScen[which(temp$slopesDown == "1" & temp$bent == 1)] <- 8

temp$prodScen <- as.factor(temp$prodScen)
temp$warming <- as.factor(temp$warming)
temp$product <- as.factor(temp$product)
temp$fishing <- as.factor(temp$fishing)
temp$slopeChange <- as.factor(temp$slopeChange)


```

#### dataframes 28x3x29: community slopes

```{r}
### The part below is to be run with all 28x3x29 dataframes to transform them into long format for anove
#load(file = "outputs/CommSlope.RData")
#load(file = "outputs/CommSlopeFish.RData")
# load(file = "outputs/CommSlopeBent.RData")
# load(file = "outputs/CommSlopePlan.RData")
# load(file = "outputs/CommSlopeHerb.RData")
# load(file = "outputs/CommSlopePred.RData")

#input_data <- CommSlope_all
input_data <- CommSlopeFish_all
#input_data <- CommSlopeBent_all
#input_data <- CommSlopePlan_all
#input_data <- CommSlopeHerb_all
#input_data <- CommSlopePred_all

temp <- reshape2::melt(input_data, id =1) # reshape into a long format
temp <- cbind(temp, rep(scenarios, length.out = length(temp[,1]))) #add scneario names
temp <- cbind(temp, rep(rep(c("slope", "intercept", "coeff"), each = length(scenarios)), times = 29)) #add species names
#temp <- temp[,-c(1:2)]
colnames(temp) <- c("scen_num", "stats_num", "paramset", "value", "scenario", "statsname")
#now add separate columns indicating different treatments for anova
## Add qualifyers from the chunk above!

# commSlope <- temp
# save(commSlope, file = "nonTrData/commSlope.RData")

commSlopeFish <- temp
save(commSlopeFish, file = "nonTrData/commSlopeFish.RData")


```

### Make scaled dataframes 

here we want to get the difference from the baseline

#### dataframes 29x17x28: by species

```{r}

# load(file = "outputs/biom.RData")
# load(file = "outputs/PropLargFish.RData")
 load(file = "outputs/MeanWgtMat.RData")
# load(file = "outputs/MeanWgtAbove5.RData")
# load(file = "outputs/MeanWgtAbove2_5.RData")
# load(file = "outputs/MeanWgtAbove10.RData")
# load(file = "outputs/Yield.RData")

#turn biom plot into a long data frame
#input_data <- biom_all[c(19:36),,] # only use scenarios with fishing
#input_data <- Yield_all[c(19:36),,] # only use scenarios with fishing
#input_data <- PropLarFish_all[c(19:36),,] # only use scenarios with fishing
input_data <- MeanWgtMat_all[c(19:36),,] # only use scenarios with fishing
# input_data <- MeanWgtAbove5_all[c(19:36),,] # only use scenarios with fishing, use this also for meanWgt above 2.5cm, as this is how the dataframe is named
#input_data <- MeanWgtAbove10_all[c(19:36),,] # only use scenarios with fishing
```

```{r}
temp <- data.frame()
#for (scen in 1:length(scenarios)) {
for (scen in 1:length(fish_sc)) {   #if using yield data
  
  #if scaled to zero  
  tt <- (input_data[scen,,] - input_data[1,,])/input_data[1,,]
  #if relative
  #tt <- input_data[scen,,] / input_data[1,,]
  temp2 <- reshape2::melt(tt, id =1)
#  temp3 <- cbind(temp2, rep(scenarios[scen], times = length(temp2[,1])))
    temp3 <- cbind(temp2, rep(fish_sc[scen], times = length(temp2[,1])))    #for yield data
    temp <- rbind(temp, temp3)
}

#temp <- cbind(temp, rep(species, times = 29*length(scenarios)), rep(func_group, times = 29*length(scenarios)))
#or for yield data 
temp <- cbind(temp, rep(species, times = 29*length(fish_sc)), rep(func_group, times = 29*length(fish_sc)))

temp <- temp[,-1]
colnames(temp) <- c("paramset", "value", "scenario","species", "funcgr")

#if using yield data remove T_caudimaculatus species, as it is not fished 
#temp <- temp %>% filter (species != "T_caudimaculatus")

## add various qualifyers
temp$warming <- 0
temp$warming[which(temp$scenario %in% warm_sc)] <- 1
temp$fishing <- 0
temp$fishing[which(temp$scenario %in% fish_sc)] <- 1
temp$plankt <- 0
temp$plankt[which(temp$scenario %in% pla_sc)] <- 1
temp$bent <- 0
temp$bent[which(temp$scenario %in% ben_sc)] <- 1
temp$kappaUp <- 0
temp$kappaUp[which(temp$scenario %in% kappaUp_sc)] <- 1
temp$kappaDown <- 0
temp$kappaDown[which(temp$scenario %in% kappaDown_sc)] <- 1
temp$slopesUp <- 0
temp$slopesUp[which(temp$scenario %in% slopeUp_sc)] <- 1
temp$slopesDown <- 0
temp$slopesDown[which(temp$scenario %in% slopeDown_sc)] <- 1

temp$product <- 0
temp$product[which(temp$kappaUp == "1")] <- 1
temp$product[which(temp$kappaDown == "1")] <- -1

temp$slopeChange <- 0
temp$slopeChange[which(temp$slopesUp == "1")] <- 1
temp$slopeChange[which(temp$slopesDown == "1")] <- -1

#define productivity scenarios - we have 7 of them, so it is a question on how to rank them
temp$prodScen <- 0
temp$prodScen[which(temp$kappaUp == "1" & temp$plankt == 1)] <- 1
temp$prodScen[which(temp$kappaDown == "1" & temp$plankt == 1)] <- 3
temp$prodScen[which(temp$slopesUp == "1" & temp$plankt == 1)] <- 5
temp$prodScen[which(temp$slopesDown == "1" & temp$plankt == 1)] <- 7
temp$prodScen[which(temp$kappaUp == "1" & temp$bent == 1)] <- 2
temp$prodScen[which(temp$kappaDown == "1" & temp$bent == 1)] <- 4
temp$prodScen[which(temp$slopesUp == "1" & temp$bent == 1)] <- 6
temp$prodScen[which(temp$slopesDown == "1" & temp$bent == 1)] <- 8

temp$prodScen <- as.factor(temp$prodScen)
temp$warming <- as.factor(temp$warming)
temp$product <- as.factor(temp$product)
temp$fishing <- as.factor(temp$fishing)
temp$slopeChange <- as.factor(temp$slopeChange)

```

```{r}
# biom_relative <- temp
# save(biom_relative, file = "plotData/biom_relative.RData")

#biom_tozero <- temp
#save(biom_tozero, file = "plotData/biom_tozero.RData")

 # size_tozero <- temp
 # save(size_tozero, file = "plotData/size_tozero.RData")

# size_relative <- temp
# save(size_relative, file = "plotData/size_relative.RData")

# size_relativeN <- temp
# save(size_relativeN, file = "plotData/size_relativeN.RData")

# size_tozeroN <- temp
# save(size_tozeroN, file = "plotData/size_tozeroN.RData")

# size_relativeMat <- temp
# save(size_relativeMat, file = "plotData/size_relativeMat.RData")

# size_tozeroMat <- temp
# save(size_tozeroMat, file = "plotData/size_tozeroMat.RData")
 
# prolarfish_relative <- temp
# save(prolarfish_relative, file = "plotData/prolarfish_relative.RData")

# prolarfish_tozero <- temp
# save(prolarfish_tozero, file = "plotData/prolarfish_tozero.RData")
 
# yield_relative <- temp
# save(yield_relative, file = "plotData/yield_relative.RData")

# yield_tozero <- temp
# save(yield_tozero, file = "plotData/yield_tozero.RData")


#MeanWgtMat_diff <- temp
#save(MeanWgtMat_diff_plot, file = "plotData/MeanWgtMat_diff.RData")

#MeanWgtAb5_diff <- temp
#save(MeanWgtAb5_diff_plot, file = "plotData/MeanWgtAb5_diff.RData")

#MeanWgtAb10_diff <- temp
#save(MeanWgtAb10_diff, file = "plotData/MeanWgtAb10_diff.RData")

```

#### dataframes 29x17x200x28 - size spectra
not sure any of these will be used but the option is here 

Remember we only scale to the baseline scenario WITH fishing
Runs without fishing are not used at the moment at all

```{r}
load(file = "outputs/numb.RData")

## numbers at weight difference 
dim(numb_all)

input_data <- numb_all[c(19:36),,,]

### if transforming into a long format
temp <- data.frame()
for (scen in 1:length(fish_sc)) {

  #tt <- (input_data[scen,,,] - input_data[1,,,])/input_data[1,,,]
  tt <- input_data[scen,,,]/input_data[1,,,]
  temp2 <- reshape2::melt(tt, id =1)
  #temp3 <- cbind(temp2, rep(scenarios[scen], times = length(temp2[,1])))
  temp3 <- cbind(temp2, rep(fish_sc[scen], times = length(temp2[,1])))
  temp <- rbind(temp, temp3)
}


# ## or if just scaling by first scenario
# new_data <- array(data= NA, c(18,17,200,29))
# 
# for (scen in 1:length(fish_sc)) {
# 
#   #tt <- (input_data[scen,,,] - input_data[1,,,])/input_data[1,,,]
#   new_data[scen,,,] <- input_data[scen,,,]/input_data[1,,,]
#  
# }
# rel_numb <- new_data
# save(rel_numb, file = "plotData/rel_numb.RData")

#temp <- temp[,-1]
colnames(temp) <- c("sppnum", "sizegroup", "paramset", "value", "scenario","species", "funcgr")


## add various qualifiers
temp$warming <- 0
temp$warming[which(temp$scenario %in% warm_sc)] <- 1
temp$fishing <- 0
temp$fishing[which(temp$scenario %in% fish_sc)] <- 1
temp$plankt <- 0
temp$plankt[which(temp$scenario %in% pla_sc)] <- 1
temp$bent <- 0
temp$bent[which(temp$scenario %in% ben_sc)] <- 1
temp$kappaUp <- 0
temp$kappaUp[which(temp$scenario %in% kappaUp_sc)] <- 1
temp$kappaDown <- 0
temp$kappaDown[which(temp$scenario %in% kappaDown_sc)] <- 1
temp$slopesUp <- 0
temp$slopesUp[which(temp$scenario %in% slopeUp_sc)] <- 1
temp$slopesDown <- 0
temp$slopesDown[which(temp$scenario %in% slopeDown_sc)] <- 1

temp$product <- 0
temp$product[which(temp$kappaUp == "1")] <- 1
temp$product[which(temp$kappaDown == "1")] <- -1

temp$slopeChange <- 0
temp$slopeChange[which(temp$slopesUp == "1")] <- 1
temp$slopeChange[which(temp$slopesDown == "1")] <- -1

#define productivity scenarios
temp$prodScen <- 0
temp$prodScen[which(temp$kappaUp == "1" & temp$plankt == 1)] <- 1
temp$prodScen[which(temp$kappaDown == "1" & temp$plankt == 1)] <- 3
temp$prodScen[which(temp$slopesUp == "1" & temp$plankt == 1)] <- 5
temp$prodScen[which(temp$slopesDown == "1" & temp$plankt == 1)] <- 7
temp$prodScen[which(temp$kappaUp == "1" & temp$bent == 1)] <- 2
temp$prodScen[which(temp$kappaDown == "1" & temp$bent == 1)] <- 4
temp$prodScen[which(temp$slopesUp == "1" & temp$bent == 1)] <- 6
temp$prodScen[which(temp$slopesDown == "1" & temp$bent == 1)] <- 8

temp$prodScen <- as.factor(temp$prodScen)
temp$warming <- as.factor(temp$warming)
temp$product <- as.factor(temp$product)
temp$fishing <- as.factor(temp$fishing)
temp$slopeChange <- as.factor(temp$slopeChange)

# numb_relative <- temp
# save(numb_relative, file = "plotData/numb_relative.RData")

# numb_tozero <- temp
# save(numb_tozero, file = "plotData/numb_tozero.RData")


```


