---
title: "SEA_bentPelModel"
author: "Asta Audzijonyte et al."
date: "7 November 2019"
output: html_document
---
### clear memory

```{r}

rm(list=ls())

```

### Load libraries

```{r warning=FALSE, message=FALSE, warning=FALSE, echo=F}
#list.files()

#devtools::install_github("james-thorson/FishLife")
#devtools::install_github("astaaudzi/mizer-rewiring", ref = "rewire-temp")
library(mizerRewire)
list.of.packages <- c("tidyverse", "dplyr", "ggplot2", "ggmap", "vegan", "reshape2", "cowplot", "factoextra", "data.table", "googleway", "ggrepel", "ggspatial", 
    "libwgeom", 
    "sf", 
    "rnaturalearth", 
    "rnaturalearthdata",
    "rgeos")

new.packages<- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, require, character.only = TRUE)

```

### Install mizer, load libraries 

For this model we are using an extended version of mizer which includes some experimental features
See https://github.com/sizespectrum/mizerExperimental
Standard mizer does not have starvation mortality included. This model uses starvation
https://github.com/sizespectrum/mizerStarvation

And finally a critical aspect of this model is multiple background resources, now implemented in mizerMR
https://github.com/sizespectrum/mizerMR

```{r warning=F, message=FALSE, echo=T}
#rm(list=ls())
#library(devtools)
#install.packages(vegan)
#devtools::install_github("astaaudzi/mizer", ref = "rewire-temp")
#library(mizerRewire)


library(mizer)
# remotes::install_github("sizespectrum/mizerExperimental")
# remotes::install_github("sizespectrum/mizerStarvation")
# remotes::install_github("sizespectrum/mizerMR")
library(tidyverse)
library(mizerExperimental)
library(mizerStarvation)
library(mizerMR)

```

### Background spectra

The slope for the plankton spectrum is assumed to be 2.1. 
For the benthic spectrum I use AbNoUr <- 0.8 - 0.85*log10(InvDataBinned$wgtGroup) equation and calibrate the kappa to ensure initial abundances are within the range of observed abundances per m2 (Freddie's and Kate's data used to get equation, see above)
May2 optimisation: 
after optim parallel runs I still can't get Trachinops to exist and predators don't get enough food. Decreasing kappa_ben from 4 to 2 actually helps, predators grow better and there is more Trachinops (increasing kappa_ben makes things worse)

```{r warning=T, message=FALSE, echo=T}

#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

## resource params
kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
lambda = 2.15 #2.1 # 
w_pp_cutoff = 1 #g
r_pp = 1 #2 # rate of regeneration
min_w_pp = 1e-10 #g

kappa_ben = 6 #2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
w_bb_cutoff = 5 #
r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
min_w_bb = 0.001 # 0.01

kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
w_aa_cutoff = 50 
r_aa = 2 #1 #something to be calibrated
min_w_aa = 0.001

```

### setup mizer to run with Tasmanian model

 In this file we are setting up the functions for
 - the dynamics of the resources
 - the contribution of the resources to the encounter rate
 - the senescence mortality
 and provide a function for setting up Tasmanian model with  benthos and algae.

TODO - can we make sure parameters are set separately and not hardcoded in functions 

```{r, eval = T, echo = F}
#
# This file is sourced by the file run.R that runs the 
# climate change scenarios

#parameters for senescence mortality as used in Law et al. 2009
k.sm <- 0.1 # mortality per year at the threshold size (should be 0.5 originally)
xsw <- 0.95 # proportion of w_inf at which mortality is at k.sm (should be 0.9)
sen.e <- 3  # exponent of the senescence mortality (larger value will give 
# steeper increase in the last few sizes) (should be 3)

sen_mort <- function(sppParams, params, k.sm, xsw, sen.e) {
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    for (i in 1:length(sppParams$species)) {
        mu_Sen = k.sm * 10^(sen.e*(log(params@w) - log(xsw*sppParams$w_inf[i])))
        sen.mort.m[i,] <- mu_Sen    
    }
    # For really small species, like Trachinops, Pictilabrus and urchins 
    # predation mortality will be so high that senescence mortality is unlikely 
    # to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    return(sen.mort.m)
}

newAstaParams <- function(sp, interaction, 
                          temperature = 12,
                          Ea = 0.63,
                          t_ref = 12,
                          no_w = 200, 
                          kappa = 2,
                          lambda = 2.15,
                          kappa_ben = 6, 
                          lambda_ben = 1.9,
                          stable_abund,
                          stable_pl,
                          stable_ben,
                          stable_alg) {
    # temperature factor
    temperature <- temperature + 273 # converting to Kelvin from Celsius
    t_ref <- t_ref + 273
    temperatureScalar <- exp(-Ea / 8.617332e-5 * (1/temperature - 1/t_ref))
    
    # We rescale rates. Mortality is rescaled further down
    sp$ks <- sp$ks * temperatureScalar
    sp$h <- sp$h * temperatureScalar
    sp$gamma <- sp$gamma * temperatureScalar
    
    # We are choosing the smallest plankton size to agree with what Asta's
    # setup function produces
    min_w_pp <- 0.95e-10
    
    params <- newMultispeciesParams(
        sp, interaction = interaction, no_w = no_w, min_w_pp = min_w_pp,
        n = 2/3)
    
    # Add starvation mortality with default parameter
    params <- setStarvation(params)
    
    # Add senescence mortality and rescale with temperature factor 
    z0 <- getExtMort(params) + 
        sen_mort(mariaParams, params, k.sm, xsw, sen.e)
    params <- setExtMort(params, z0 = z0 * temperatureScalar)
    
    # Set up resources
    resource_params(params) <- data.frame(
        resource = c("pl", "aa", "bb"),
        lambda = c(lambda, 1.6, lambda_ben),
        kappa = c(kappa, 16, kappa_ben),
        r_pp = c(1, 2, 1),
        w_min = c(NA, 1e-3, 1e-3),
        w_max = c(1, 50, 5)
    )
    resource_interaction(params)[, 1] <- sp$avail_PP
    resource_interaction(params)[, 2] <- sp$avail_AA
    resource_interaction(params)[, 3] <- sp$avail_BB
    
    # Update initial abundances 
    initialN(params) <- stable_abund
    initialNResource(params)[1, ] <- stable_pl
    initialNResource(params)[2, ] <- stable_alg
    initialNResource(params)[3, ] <- stable_ben
    
    params
}



```

### Baseline run with standard mizer

Previously runs were done with mizer rewiring fork. 
To adapt them to standar mizer we adjust a few parameters. 

First, Tasmanian model follows DEB and optimal allocation models and assumes a cost of growth, i.e. growth inefficiency. This means that in addition to assimilation efficiency parameter (0.6), converting net energy to growth also incurs growth cost. Such growth cost is most sensible in two pool models (e.g. Audzijonyte & Richards, 2018) where allocation to growth incurs costs while allocation to reserve does not. In standard mizer, which only tracks total weight this is now incorporated in other parameters. 
We also update reproductive allocation function 

```{r}
# The code is mostly copied from the "Actual scenario runs" section of
# Asta's "BenPel_SEAmodel_dbV2.Rmd" file, just slightly adjusted to run
# with standard mizer. Places where I made importantchanges are marked with 
# comments starting with GWD

# We source the functions needed to set up Asta's model in standard mizer
#source("standard_mizer/setup_mizerMR.R")


# Species params ----
# GWD: We have to make some changes to Asta's species parameter file
# to absorb the growth efficiency into the existing parameters
load(file = "modelParams/mariaParamsMs.RData") #species parameter file 

# Growth inefficiency is assumed in the mod

mariaParams <- mariaParams %>% 
    # get rid of separate growth efficiency
    mutate(alpha = alpha * alpha_g,
           ks = ks * alpha_g,
           erepro = erepro / alpha_g)

# GWD: We change the maturity curve to correspond to an exponent u = 5 
mariaParams$w_mat25 <- mariaParams$w_mat/3^(1/5)

# We load interaction matrix and add rownames
load(file = "modelParams/inter_N19.RData")
dimnames(inter)[[1]] <- dimnames(inter)[[2]]

# Load initial values
load(file = "modelParams/naa_N19.RData")
load(file = "modelParams/nbb_N19.RData")
load(file = "modelParams/abund_N19.RData")
load(file = "modelParams/npp_N19.RData")

# Make a run with the base scenario just to check that things are working

params <- newAstaParams(mariaParams, interaction = inter,
                        stable_abund = stable_abund,
                        stable_pl = stable_pl,
                        stable_ben = stable_ben,
                        stable_alg = stable_alg)

tasm1 <- project(params, t_max = 10, effort = 0, dt = 0.2)

plot(tasm1)
plotSpectra(tasm1)

```

### Run climate scenarios

```{r}

# In this file we are running the climate change scenarios
### Load scenarios ----

load(file = "modelParams/params28ms.RData")
accepted1 <- as.data.frame(params28)

# List of seven productivity scenarios. Each of them will be run 4 times: with
# and without fishing, with and without heating. Note, I used very approximate
# array of fishing mortality (shown below). This can be updated

#if no fishing is applied 
fish.mort.0 <- rep(0, times = 17)
#a vector of low fishing mortalities
fish.mort.v <-  c(0.15, 0.15, 0, 0.1, 0.15, 0.1, 0.15, 0.1, 0.1, 0.15, 0.15, 
                  0.15, 0.15, 0.15, 0.1, 0.15, 0.15)


prod_scen<-list( 
    # "baseline_12_f0"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
    # "more_plankt_12_f0"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
    # "less_plankt_12_f0"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
    # "small_plankt_12_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
    # "large_plankt_12_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
    # "more_benth_12_f0"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
    # "less_benth_12_f0"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
    # "small_benth_12_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 12, "fmort" = fish.mort.0),
    # "large_benth_12_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 12, "fmort" = fish.mort.0),
    # 
    # "baseline_14_f0"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "more_plankt_14_f0"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "less_plankt_14_f0"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "small_plankt_14_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "large_plankt_14_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "more_benth_14_f0"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "less_benth_14_f0"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "small_benth_14_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 14.5, "fmort" = fish.mort.0), 
    # "large_benth_14_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 14.5, "fmort" = fish.mort.0), 
    # 
    "baseline_12_f2"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
    "more_plankt_12_f2"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
    "less_plankt_12_f2"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
    "small_plankt_12_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
    "large_plankt_12_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
    "more_benth_12_f2"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
    "less_benth_12_f2"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
    "small_benth_12_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 12, "fmort" = fish.mort.v),
    "large_benth_12_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 12, "fmort" = fish.mort.v),
    
    "baseline_14_f2"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
    "more_plankt_14_f2"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
    "less_plankt_14_f2"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
    "small_plankt_14_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
    "large_plankt_14_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
    "more_benth_14_f2"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
    "less_benth_14_f2"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
    "small_benth_14_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 14.5, "fmort" = fish.mort.v), 
    "large_benth_14_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 14.5, "fmort" = fish.mort.v)) 

### Setup run parameters ----

## do you want a plot for each run, while the simulations are going? This takes
## more time but is sometimes fun to watch and keep an eye if there are
## oscillating dynamics
showplot = F

## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2
#our reference temperature 
temp_ref = 12

## fixed background params- THESE ARE NOT CHANGING IN SCENARIOS
w_pp_cutoff = 1 #g
r_pp = 1 # rate of regeneration
min_w_pp = 1e-10 #g

w_bb_cutoff = 5 #
r_bb = 1 # 
min_w_bb = 0.001 # 0.01

#algae are not really size structured food resources, but are treated as such here for now 
kappa_alg = 16 #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
w_aa_cutoff = 50 
r_aa = 2 
min_w_aa = 0.001

### Setup arrays to store data ----

# We will store data on: 
# 1) Numbers at size to look at species spectra and so on
# 2) Numbers at size for all background spectra, just in case we need it
# 3) Proportion of Large fish indicator 
# 4) Mean weight above some thresholds: two thresholds used are MeanWeight of 
#    mature fish (maturation size is a threshold) and MeanWeight of fish above 
#    5cm in length
# 5) Calculate community slopes: for all species, for fish only 
#    (exclude lobsters and urchins), and for four functional groups 
#    separately - benthivores, planktivores, herbivores (includes urchins) 
#    and predators (includes lobsters)

#number of scenarios in a list
scen_num <- length(lengths(prod_scen))
n_spp <- length(params@species_params$species)

## 200, 326 or 120 in these dataframes refers to the numbers of size groups 
# in different arrays
numb_all <-array(data=NA,c(scen_num,n_spp,200,dim(params28)[1])) 
biom_all <- array(data=NA, c(scen_num,n_spp, dim(params28)[1]))
plankt_all <- array(data=NA, c(scen_num,326, dim(params28)[1]))
bent_all <- array(data=NA, c(scen_num,120, dim(params28)[1]))
alg_all <- array(data=NA, c(scen_num,153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
Yield_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
#Yield_all[c(1:14),,] <- 0 #no fishing scenarios will have zero yield naturally
MeanWgtMat_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
#MeanWgtHalfMat_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
MeanWgtAbove5_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
MeanWgtAbove10_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
CommSlope_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeFish_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeBent_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopePred_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopePlan_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeHerb_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))

## setup different species groups for community slope calcualtions
fishonly <- as.character(mariaParams$species[c(1:15)])
bentiv <- as.character(mariaParams$species[which(mariaParams$funcgr == "omni")])
plankt <- as.character(mariaParams$species[which(mariaParams$funcgr == "plankt")])
predat <- as.character(mariaParams$species[which(mariaParams$funcgr == "predat")])
herbiv <- as.character(mariaParams$species[which(mariaParams$funcgr == "herbi")])


### All simulations ----

# This will run 36 scenarios with 29 parameter combinations each and save
# outputs into data arrays

## loop through 36 scenarios

for (scen in 1:scen_num) {
    
    ## resource params
    kappa = as.numeric(prod_scen[[scen]]["kappa"])
    kappa_ben = as.numeric(prod_scen[[scen]]["kappa_ben"])  
    lambda = as.numeric(prod_scen[[scen]]["lambda"])
    lambda_ben = as.numeric(prod_scen[[scen]]["lambda_ben"])
    
    ## get temperature value for the scenario 
    temp_run <- as.numeric(prod_scen[[scen]]["temp"])
    
    ## for each scenario loop through 29 parameter combinations   
    for (iter in 1:dim(params28)[1]) {
        
        print("scenario = ")
        print (scen)
        print(prod_scen[scen])
        print("iteration out of 29")
        print(iter)  
        ## update parameters
        
        mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
        mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
        availUr <- as.numeric(accepted1[iter,35])
        availUrLob <- as.numeric(accepted1[iter,36])
        availSchooling <- as.numeric(accepted1[iter,37])
        
        # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
        inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
        inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
        inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
        inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
        inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
        
        
        ### setup again with new parameter values
        # GWD: We use our own setup function here, which already
        # implements the temperature rescalings as well as setting up
        # the resource parameters, adding the senescence mortality,
        # and setting initial abundances.
        params <- newAstaParams(mariaParams, 
                                interaction = inter,
                                temperature = temp_run,
                                no_w = no_size_groups, 
                                kappa = kappa, 
                                lambda = lambda, 
                                kappa_ben = kappa_ben, 
                                lambda_ben = lambda_ben,
                                stable_abund = stable_abund,
                                stable_pl = stable_pl,
                                stable_ben = stable_ben,
                                stable_alg = stable_alg)
        # GWD: Rather than having one gear per species and setting a different
        # effort for each, we set the fishing mortality via the catchability
        # and then use effort 1.
        # set catchability
        fish.mort <- array(as.numeric(prod_scen[[scen]][6:22]), dim = c(1, 17))
        # fish.mort <- c(0.3, 0.2, 0, 0.1, 0.2, 0.1, 0.3, 0.1, 0.1, 0.2, 0.2, 0.1, 0.1, 0.2, 0.1, 0, 0.3)
        params@catchability[] <- fish.mort
        
        #run the model
        tmax <- 100
        dt <- 0.2
        # GWD: use standard project function. We don't need to supply
        # temperature here because we have already rescaled the rates
        # when we set up the params object.
        tasm1 <- project(params, t_max = tmax, effort = 1, dt = dt)
        
        ### Calculate various statistics inside the run to avoid saving massive model objects
        if (showplot == T) {
            plot(tasm1)
        }
        #get relative biomasses 
        #need to take an average of the last 30 years because it is oscilating
        biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
        #biomass <- getBiomass(tasm1)[tmax,]
        #numbers <- tasm1@n[tmax,,] 
        numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
        
        PropLarFish <- rep(NA,17)
        MeanWgtMat <- rep(NA,17)
        MeanWgtAbove5 <- rep(NA,17)
        MeanWgtAbove10 <- rep(NA,17)
        
        for (xx in 1:length(mariaParams$species)) {
            PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[(tmax-29):tmax])
            MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[(tmax-29):tmax])
            MeanWgtAbove5[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm5[xx], max_w = mariaParams$w_inf[xx])[(tmax-29):tmax])
            MeanWgtAbove10[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm10[xx], max_w = mariaParams$w_inf[xx])[(tmax-29):tmax])
            
        }
        
        #get mean values of various statistics over the last 30 years and save them in arrays 
        ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
        plankt_all[scen,,iter] <- apply(ttemp, 2, mean)
        
        ## AA: sep20
        ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc6[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc6[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc6[,iter] <- apply(ttemp, 2, mean)
  
        
        
        
        
        # GWD changes to next 4 lines because extra resources are saved differently
        ttemp <- Reduce("+", tasm1@n_other[(tmax-29):tmax, "bb"])[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
        bent_all[scen,,iter] <- ttemp
        ttemp <- Reduce("+", tasm1@n_other[(tmax-29):tmax, "aa"])[which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
        alg_all[scen,,iter] <- ttemp
        
        numb_all[scen,,,iter] <- numbers
        biom_all[scen,,iter] <- biomass
        PropLarFish_all[scen,,iter] <- PropLarFish
        MeanWgtMat_all[scen,,iter] <- MeanWgtMat
        MeanWgtAbove5_all[scen,,iter] <- MeanWgtAbove5
        MeanWgtAbove10_all[scen,,iter] <- MeanWgtAbove10
        Yield_all[scen,,iter] <- as.numeric(apply((getYield(tasm1)[c((tmax-29):tmax),]),2,mean))
        CommSlope_all[scen,,iter] <- as.numeric(apply((getCommunitySlope(tasm1)[c((tmax-29):tmax),]),2,mean))
        CommSlopeFish_all[scen,,iter] <- as.numeric(apply((getCommunitySlope(tasm1, species = fishonly)[c((tmax-29):tmax),]),2,mean))
        CommSlopeBent_all[scen,,iter] <- as.numeric(apply((getCommunitySlope(tasm1, species = bentiv)[c((tmax-29):tmax),]),2,mean))
        CommSlopePlan_all[scen,,iter] <- as.numeric(apply((getCommunitySlope(tasm1, species = plankt)[c((tmax-29):tmax),]),2,mean))
        CommSlopeHerb_all[scen,,iter] <- as.numeric(apply((getCommunitySlope(tasm1, species = herbiv)[c((tmax-29):tmax),]),2,mean))
        CommSlopePred_all[scen,,iter] <- as.numeric(apply((getCommunitySlope(tasm1, species = predat)[c((tmax-29):tmax),]),2,mean))
        
    }
    
}

### Save results ----

save(numb_all, file = "outputs/numb.RData")
save(biom_all, file = "outputs/biom.RData")
save(plankt_all, file = "outputs/plankt.RData")
save(bent_all, file = "outputs/bent.RData")
save(alg_all, file = "outputs/alg.RData")
save(PropLarFish_all, file = "outputs/PropLargFish.RData")
save(MeanWgtMat_all, file = "outputs/MeanWgtMat.RData")
save(MeanWgtAbove5_all, file = "outputs/MeanWgtAbove5.RData")
save(MeanWgtAbove10_all, file = "outputs/MeanWgtAbove10.RData")
save(Yield_all, file = "outputs/Yield.RData")
save(CommSlope_all, file = "outputs/CommSlope.RData")
save(CommSlopeFish_all, file = "outputs/CommSlopeFish.RData")
save(CommSlopeBent_all, file = "outputs/CommSlopeBent.RData")
save(CommSlopePlan_all, file = "outputs/CommSlopePlan.RData")
save(CommSlopeHerb_all, file = "outputs/CommSlopeHerb.RData")
save(CommSlopePred_all, file = "outputs/CommSlopePred.RData")

#saveRDS(foodWebStats, file = "altRuns28/foodwebstats.rds")


```





### Load saved params, if you have them

Here I load my saved parameter sets and initial abundances

```{r, warning=F, message=FALSE, echo=F, eval = T}

  load(file = "modelParams/mariaParamsMs.RData") #species parameter file 
  load(file = "modelParams/paramsMs.RData") #built params file
  load(file = "modelParams/inter_N19.RData") #interaction matrix (it is also included in the params file)
  # now load stable numbers at size for all species. I start the runs from equilibrium abundances 
  load(file = "modelParams/abund_N19.RData")
  load(file = "modelParams/npp_N19.RData")
  load(file = "modelParams/nbb_N19.RData")
  load(file = "modelParams/naa_N19.RData")
  
  ## data for invertebrate abundances
  load(file = "modelParams/BenticInvAbund_Tasm.RData")

  #load empirical size spectra in underwater visual survey length bins. Species are grouped as in model groups. Their length-weight conversion is included, and weights per size bins are also calculated. Not sure this is the best way to compare observed spectra to model spectra. Either way we need to bin model size spectra into similar bins. How? 
  load(file = "modelParams/empSizes.RData")

  ## earlier parameter rounds, where I was saving subsequent combinations
# runname <- "N19"
# 
# load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
# #write.csv(params@species_params, file = "mariaParams_N20.csv")
# load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
# 
# load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
# #write.csv(inter, file = "inter_N20.csv")
# 
# load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
# #write.csv(stable_abund, file = "stable_abund.N20")
# load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
# #write.csv(stable_pl, file = "stable_pl.csv")
# load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
# #write.csv(stable_ben, file = "stable_ben.csv")
# load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
# #write.csv(stable_alg, file = "stable_alg.csv")
# #and invert abundance data from surveys for the benthic spectrum
# load(file = "../inputs/benthos/BenticInvAbund_Tasm.RData")
# load(file = "../inputs/benthos/InvDataBinned.RData")

```

### Senescence mort functions and params 

Since May2 juvenile mortality is not used. Senescence morality is still used

```{r warning=T, message=FALSE, echo=T}

## Senescence

## function to set senescence mortality and add it on top of mu_b. The function needs mizer params object to be set up first to know the number of size classes. So I run MizerParams here, but can overwrite it later as long as no_w does not change

params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

#parameters for senescence mortality as used in Law et al. 2009
k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)

sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
  
  sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
  
  for (i in 1: length(sppParams$species)) {
    
    mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
    
    sen.mort.m[i,] <- mu_Sen    
  }

  # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
  sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
  return(sen.mort.m)
  
}

## Juvenile mort 

## I also add extra juvenile mortality, because in reality background spectrum species would be imposing mortality on tiny fish, yet we don't model it here. As a result mortality curves look bell-shaped when instead they should be exponential 

juv.sm <- 5 #10 #5 # mortality per year at threshold
juvsw <- 2 # Size of w_min at which mortality is at juv.sm. Note that at the moment w_min is setup at 5x the egg size. 
juv.e <- 0.3 #0.5 #exponent, larger values will give steeper decrease (orignal was 0.3, but it may be too slow decrease)

juv_mort = function(sppParams, params, juv.sm, juvsw, juv.e) {
  
  juv.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
  
  for (i in 1: length(sppParams$species)) {
    mu_Juv = juv.sm * 10^-(juv.e*(log(params@w) - log(juvsw*sppParams$w_min[i])))
    juv.mort.m[i,] <- mu_Juv
  }
  
  # It is most likely that for sharks or other species with large eggs (w_min of at least 1 gram), this early steep mortalit does not apply. So get rid of it
  juv.mort.m[which(params@species_params$w_min > 0.99),] <- 0
  
  return(juv.mort.m)
}

```

### ##########

### CALIBRATION 

### Calibrate benthic kappa

Mizer does not have defined units and can be calibrated for m3, m2 or the total model area. I am using measures per m2, because this is how RLS data is presented. 
AbNoUr <- 0.8 - 0.85*log10(InvDataBinned$wgtGroup)

```{r, eval = F}
#inferred observed abundance (on log10 scale from Kate's and Freddie's data)
#Data using the estimated regression slope
obsab <- 0.8 - 0.85*log10(params@w_full) ## expected abundance using the equation applied to the weight groups used in mizer

# Now we get model abundance per size class
#length(params@dw_full[c(min(which(params@w_full > min_w_bb)):max(which(params@w_full < w_bb_cutoff)))])
modbb <- log10(params@initial_n_bb * params@dw_full) 
modpl <- log10(params@initial_n_pp * params@dw_full)
modaa <- log10(params@initial_n_aa * params@dw_full)

plot(log10(params@w_full), obsab, type = 'l', lwd = 1.5, xlim = c(-6,2), ylim = c(-3, 5), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w_full), modbb, type = 'l', col = 'red')
points(log10(params@w_full),modpl, type = 'l', col = 'green')
points(log10(params@w_full),modaa, type = 'l', col = 'blue')
#abline(v = log10(0.05), lty = 2)
abline(v = log10(min_w_bb), lty =2)

```

Comment on the above: there is a big dip in the observed abundance data at around the size of 1g. This could be because the two methods used are just diverging on their sampling accuracy at this size or because at this size there is indeed a strong benthos depletion and a dip in the slope. I actually do get a dip at this point. The theoretical abundance at 1g would be 10individuals per m2, while we get less than 1 in observations. 

### Data files: DON'T RUN if loaded

For initial start of the calibration load your parameter files here. During the calibration I then save all params and initial abundances, and load them later. So this chunk is not needed. I use a scalar from observed abundances to rescale model default initial abundances, because they seem to be too far from the observations 

```{r warning=T, message=FALSE, echo=F, eval = F}

#mariaParams <- read.csv(file = "../modelParams/Tasm_parametersN18.csv") #16 species
mariaParams <- read.csv(file = "../modelParams/Tasm_paramsN19.csv") #16 species
#inter <- read.csv(file = "../modelParams/Tasm_interaction.csv") #16 species
inter <- read.csv(file = "../modelParams/Tasm_interN19.csv") #16 species
inter <- as.matrix(inter)

```

### Fixed params: DON'T RUN if loaded 

I am not optimising or exploring these much

```{r warning=T, message=FALSE, echo=T, eval = F}

#### egg size, rmax, exponents ####
mariaParams$w_min <- round(((0.0015* mariaParams$w_inf^0.14) *10),4)  # Barneche et al. 2018 equation for egg sizes, but let's start with at least 10 times bigger individuals, as they don't start feeding when they are eggs and we don't track the dynamics of early days very well
mariaParams$w_min[which(mariaParams$species == "C_laticeps")] <- 1  #assume that shark eggs are 5 grams?

mariaParams$w_min <- params@species_params$w_min

#scaling exponents. Who knows what they should be!! 
mariaParams$n <- 0.75 # maximum intake scaling, mizer default is 2/3, but the growth curves don't look so good
mariaParams$p <- 0.8 # metabolism scaling
mariaParams$q <- 0.75 # search rate scaling

#### h & ks  ####
# by default mizer will set  h values, calcualted as h = [3*k_vb/(alfa*f0)]*W_inf^(1/3)
# I use size dependent scaling, derived from earlier explorations based on daily consumption rates or minimum intake needed to get juvenile growth right
mariaParams$h = 50 * (mariaParams$w_inf/1000)^0.15

# then for herbivores, who have low assimilation efficiency, we triple the maximum intake rate (based on Graham Edgar daily intake calculations, ref in Soler et al. 2018)
mariaParams$h[which(mariaParams$funcgr == "herbi")] <- mariaParams$h[which(mariaParams$funcgr == "herbi")]*3
#See thoughts above on whether these values give reasonable estimates

#set size dependent ks based on my earlier explorations based on the DEB dataset. This is just a guess, but the key is that ks scales NEGATIVELY with w_inf (not positively as it is set in mizer)
mariaParams$ks <- 20*mariaParams$w_inf^(-0.25)
#however this relationship gives Trachinops (smallest planktivore) very high ks, so I decrease it. The relationship seems too steep for smallest species. Even though small species have high per unit body mass ks, this apppears much too high
mariaParams$ks[which(mariaParams$species == "T_caudimaculatus")] <- 4.5 #instead of 8 which this equation gives
#invertebrates are expected to have lower maintenance costs than fish, but urchin maintenance is very high. So I reduce it by 1.5
ksUrchinsOld <- mariaParams$ks[which(mariaParams$species == "urchins")]
mariaParams$ks[which(mariaParams$species == "urchins")] <- ksUrchinsOld/1.5
plot(mariaParams$w_inf, mariaParams$ks, pch = 19)

## Is ks for urchins too high? 
#which(mariaParams$species == "urchins")
#mariaParams$h[16]
# Let's assume they are are feeding at maximum possible rate
#energy <- (mariaParams$h[16]*mariaParams$w_mat[16]^mariaParams$n[16])*mariaParams$alpha[16]
#metab <- mariaParams$ks[16]*mariaParams$w_mat[16]^mariaParams$p[16]
#energy- metab # plenty of net energy left! So the value should be ok

### Background mortality 

#I am  using mizer default values for background mortality, as z0 = z0pre * w_inf ^ (n-1)
basic_z0 = mariaParams$z0pre * mariaParams$w_inf ^ (mariaParams$n -1 )
basic_z02 = 0.3 * mariaParams$w_inf ^ (mariaParams$n -1 )
## these mortality values seem too high when I ahve strong species interactions and pred mortality already. so i halve them
mariaParams$z0 <- basic_z0/2
#min(mariaParams$z0)


```

### Dynamic parameters(gamma, erepro, rmax): DON'T RUN if loaded 

These are to be explored

```{r warning=T, message=FALSE, echo=T, eval = F}

## Erepro 

# Initial erepro is set using a general approximation now but will be optimised later. This way the steady state optimiser finds values easier
#mariaParams$erepro <- 0.05 * mariaParams$w_inf^(-0.5)
#These are initial values but then they are tuned with steady()
#The equation above actually gives too low erepro values, so I start with 10x larger values
mariaParams$erepro <- 0.5 * mariaParams$w_inf^(-0.5)
#plot(mariaParams$w_inf, mariaParams$erepro)

## Gamma 

## In the MizerParams we asked mizer to set gamma's based on the defaults: 
## gamma = f0*h*beta^(2-lambda)/((1-f0)*2*3.14*kappa*sigma)
#since we use three background spectra I calculate mean lambda and kappa
mean_lam = mean(lambda, lambda_ben, lambda_alg)
mean_kappa = mean(kappa, kappa_ben, kappa_alg)

#as an initial setup we use default mizer gamma parameters, but note this is a very crude approximation because we have 3 size spectra and species have different access to these spectra
gammaDef = mariaParams$f0 *mariaParams$h*mariaParams$beta^(2-mean_lam)/((1-mariaParams$f0)*2*3.14*mean_kappa*mariaParams$sigma)

#for herbivores gamma values might need to be doubled
#gammaDef[which(mariaParams$funcgr == "herbi")] <- gammaDef[which(mariaParams$funcgr == "herbi")] *2

# for predators gamma values should be much higher or else they don't get enough food, because they generally search for food actively 
gammaDef[which(mariaParams$funcgr == "predat")] <- gammaDef[which(mariaParams$funcgr == "predat")] * 3

#And then total gamma is increased for all species, because they just don't need enough otherwise!!
mariaParams$gamma <- gammaDef * 3

#what is the area searched per day? Am I happy with it? Remember that this area should account for the fact that most of the time species hide and not search. so this is the actual active feeding per day
areaSearchedPerDay <- (mariaParams$gamma*mariaParams$w_mat^params@q)/365
areaSearchedPerDay

# R MAX and Q
basic_rmax = mean_kappa * mariaParams$w_inf^(-1.5) # if you are using r_max instead, here is Julia's formula for deep sea
# this rmax just gives extremely low relative abundances for the kappa values and they only eat background. Presumably these values give recruitment per m3 in pelagic ecosystems, while I have coastal areas and values per m2. So I convert the depth of say 500m to 1m2 and increase it further by 2 to account for higher coastal productivity. This gives a multiplier of 1000
#The values are further tuned 
mariaParams$r_max <- basic_rmax *1000
## for small pelagics the default value seems too high (and default abundance is far too high compared to the observations)
mariaParams$r_max[which(mariaParams$species == "T_caudimaculatus")] <- 0.5

#write.csv(mariaParams, file = "mariaParams_basic.csv")

```

### Initial abundance scalar: DON'T RUN if loaded

I want to calibrate initial model abundances with the relative abundances observed in the surveys (in the first 5 years), so that I at least start in the correct ballpark for relative abundances. For this I only use model abundances that are likely to be in the range observable by RLS divers, e.g. bigger than 4cm (the smallest size group is 2cm, but few individuals are observed in this group), or very roughly 1g

```{r warning=T, message=FALSE, echo=T, eval = F}

temp <- params@initial_n * params@dw * params@w #biomass 
initBiom <- apply(temp, 1, sum) # total biomass
initBiom[1] #wrasse
initBiom[3] #trachinops

temp_ben <- params@initial_n_bb * params@dw_full * params@w_full #biomass of benthos
initBiomBen <- sum(temp_ben)
initBiomBen

load(file = "../inputs/InvDataBinned.RData")
obsBenBio <- sum(InvDataBinned$bioPerm2[c(1:7)])
#obsBenBio <- 19

initBiomBen/obsBenBio  #initial benthos biomass is about 2 times bigger than observed

initBiom[1]/(mariaParams$BioM2[1]) #initial biomass of wrasse 158 times bigger than observed
initBiom[3]/(mariaParams$BioM2[3]) #for trachinops it is 40K times bigger than observed
obsBiom <- mariaParams$BioM2

#Now this is a scalar to modify initial densities while accounting for the match of observed vs modelled initial benthos densities. I will have to divide initial densities by this scalar
scalarForInitial <- (initBiom/obsBiom)/(initBiomBen/obsBenBio)
#tt <- round(as.vector(scalarForInitial),1)
mariaParams$initScalar <- round(as.vector(scalarForInitial),1)
#write.csv(mariaParams, file = "../modelParams/Tasm_paramsN19.csv")

```

### Interaction: DON'T RUN if loaded 

Four parameters to be optimised and explored here. Other values are set to 0.7 or 0. This is a tricky one, but with fewer species it should be easier 

```{r warning=T, message=FALSE, echo=T, eval = F}

availUr = 0.15 #urchins to fish
availUrLob = 0.55 #0.65 #Urchins to lobsters
availSchooling = 0.4# 0.45 #avaiability of schooling fish to predators
availTrach = 0.4 # 0.45 #avaiability of schooling fish to predators

# and overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availTrach
inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling

inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob


```

### Background availability: DON'T RUN if loaded

Eight parameters define this. It is important to explore these values, because if predators have too much access to background resource and the resource is abundant, they wont eat fish

```{r warning=T, message=FALSE, echo=T, eval = F}

availBenToPred <- 0.25
availBenToBen <- 0.7

availPlaToPred <- 0.15
availPlaToBen <- 0.2
availPlaToPla <- 0.8
availPlaToHer <- 0.2

availAlgToHer <- 0.7
availAlgToLea <- 0.02

mariaParams$avail_BB <- 0
mariaParams$avail_BB[which(mariaParams$funcgr == "predat")] <- availBenToPred
mariaParams$avail_BB[which(mariaParams$funcgr == "omni")] <- availBenToBen

mariaParams$avail_PP <- 0
mariaParams$avail_PP[which(mariaParams$funcgr == "predat")] <- availPlaToPred
mariaParams$avail_PP[which(mariaParams$funcgr == "omni")] <- availPlaToBen
mariaParams$avail_PP[which(mariaParams$funcgr == "plankt")] <- availPlaToPla
mariaParams$avail_PP[which(mariaParams$funcgr == "herbi")] <- availPlaToHer

mariaParams$avail_AA <- 0
mariaParams$avail_AA[which(mariaParams$funcgr == "herbi")] <- availAlgToHer
mariaParams$avail_AA[which(mariaParams$species == "leather_cool")] <- availAlgToLea
mariaParams$avail_AA[which(mariaParams$species == "M_freycineti")] <- availAlgToLea

```

#### ###########
### SEQUENTIAL NUDGING

### Steady state to get erepro

Now I get erepro to approximately reasonable values, they will be tuned later. Make sure initial abundances are in the right ballpark

```{r warning=T, message=FALSE, echo=T, eval = F}

### setup  
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

#update initial abundances

params@initial_n <- params@initial_n/mariaParams$initScalar
#params@initial_n <- params@initial_n*init_scalar

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## find a steady state by modifying erepro
stedTas <- steady(params, t_max = 300) #t_max gives the number of interations needed 

#plot erepro values and check if they are realistic 
plot(log(stedTas@species_params$w_inf), stedTas@species_params$erepro, xlab = 'log w_inf', ylab = 'erepro', pch = 19)

#just output the values
round(stedTas@species_params$erepro,5)

mariaParams$erepro <- round(stedTas@species_params$erepro,5)

```

### Tune Rmax   

This is a fancy "sequencial nudging" algorithm! :) However at least for me, if I start with values that are not too far off, it seems to work. At each iteration you see the plot and relative abundances, and if some species are just getting worse at each step, then you will need to stop the run and explore options manually for that species. Why is it crashing? 

First tune Rmax by slightly modifying starting Rmax values for species that are lower than 0.7, 0.3 and 0.1 of the relative observed biomass, or higher than 1.2, 1.5 and 1.8. These are just arbitrary values, set your own. 
Make sure intial abundances are scaled with your scalar or some saved stable abundances

```{r warning=FALSE, message=FALSE, echo=T}

## setup an array 
rmaxarr <- matrix(nrow = 100, ncol = 23) # this will save values at each iteration to explore them further if needed
rmaxarr[1,c(1:17)] <- mariaParams$r_max # initial r_max value

for (i in 2:100) {

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- params@initial_n/mariaParams$initScalar

#now that I have saved abundances from earlier tuned runs I use them to overwrite initial abundances
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)

plot(tasm1)

#getBiomass(tasm1)[tmax,]
#(getBiomass(tasm1)[tmax,]*10)/mariaParams$BioM2

relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
relbio

tinyhigherrmax <- which(relbio < 0.8)
print(tinyhigherrmax)
mariaParams$r_max[c(tinyhigherrmax)] <- mariaParams$r_max[c(tinyhigherrmax)] * 1.1

higherrmax <- which(relbio < 0.3)
print(higherrmax)
mariaParams$r_max[c(higherrmax)] <- mariaParams$r_max[c(higherrmax)] * 1.1

muchhigherrmax <- which(relbio < 0.1)
print(muchhigherrmax)
mariaParams$r_max[c(muchhigherrmax)] <- mariaParams$r_max[c(muchhigherrmax)] * 1.2


tinylowerrmax <- which(relbio > 1.2)
print(tinylowerrmax)
mariaParams$r_max[c(tinylowerrmax)] <- mariaParams$r_max[c(tinylowerrmax)] / 1.1

lowerrmax <- which(relbio > 1.5)
print(lowerrmax)
mariaParams$r_max[c(lowerrmax)] <- mariaParams$r_max[c(lowerrmax)] / 1.1

muchlowerrmax <- which(relbio > 1.8)
print(muchlowerrmax)
mariaParams$r_max[c(muchlowerrmax)] <- mariaParams$r_max[c(muchlowerrmax)] / 1.2

ba <- length(tinyhigherrmax) + length(tinylowerrmax)
print('tiny higher and lower')
print(ba)

ca <- length(higherrmax) + length(lowerrmax)
print('higher and lower')
print(ca)

da <- length(muchhigherrmax) + length(muchlowerrmax)
print('much higher and much lower')
print(da)

relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
print(relbio)

rmaxarr[i,c(1:17)] <- mariaParams$r_max
rmaxarr[i,18] <- length(tinyhigherrmax)
rmaxarr[i,19] <- length(higherrmax)
rmaxarr[i,20] <- length(muchhigherrmax)
rmaxarr[i,21] <- length(tinylowerrmax)
rmaxarr[i,22] <- length(lowerrmax)
rmaxarr[i,23] <- length(muchlowerrmax)

aa = ba+ca+da

if (aa == 0) {
        print("finished adjusting")
        break
      }


}

#save(rmaxarr, file = "RmaxArray_redAlg_incrBen.RData")

```

### Save abundances to update intial abundances

```{r}
stable_abund <- tasm1@n[tmax,,]
stable_pl <- tasm1@n_pp[tmax,]
stable_ben <- tasm1@n_bb[tmax,]
stable_alg <- tasm1@n_aa[tmax,]

```

### Tune erepro 1: all species at a time

Next, tune erepro to the desired level of density dependence. We do need some level of DD and it seems ratio of RDD/rmax = 0.9-0.97 might give reasonable relatively strong species interactions (where RDI/RDD = 10 or 20), although Ken thinks it should be much higher (RDI/RDD at 100)

```{r}
## setup an array 
topvalue = 0.98
bottomvalue = 0.85

erepro_arr <- matrix(nrow = 100, ncol = 23)
erepro_arr[1,c(1:17)] <- mariaParams$erepro # initial r_max value

for (i in 2:100) {

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)

plot(tasm1)

model <- tasm1
a2 <- getRDD(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], sex_ratio = 0.5, model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD to rmax ratio
rmaxratio <- round (a2/mariaParams$r_max,4)

## I want the rmax ratio to be between 0.85 and 0.95 

#if rmax ratio is lower than 0.4, I need to increase erepro
tinyhigher <- which(rmaxratio < bottomvalue)
print(tinyhigher)
mariaParams$erepro[c(tinyhigher)] <- mariaParams$erepro[c(tinyhigher)] * 1.1

higher <- which(rmaxratio < (bottomvalue - 0.1))
print(higher)
mariaParams$erepro[c(higher)] <- mariaParams$erepro[c(higher)] * 1.1

muchhigher <- which(rmaxratio < (bottomvalue - 0.2))
print(muchhigher)
mariaParams$erepro[c(muchhigher)] <- mariaParams$erepro[c(muchhigher)] * 1.2

## if rmax ratio is higher than 0.8, I need to decrease erepro 

tinylower <- which(rmaxratio > topvalue)
print(tinylower)
mariaParams$erepro[c(tinylower)] <- mariaParams$erepro[c(tinylower)] / 1.05

lower <- which(rmaxratio > (topvalue+0.02))
print(lower)
mariaParams$erepro[c(lower)] <- mariaParams$erepro[c(lower)] / 1.05

muchlower <- which(rmaxratio > (topvalue+0.04))
print(muchlower)
mariaParams$erepro[c(muchlower)] <- mariaParams$erepro[c(muchlower)] / 1.05

ba <- length(tinyhigher) + length(tinylower)
print('tiny higher and lower')
print(ba)

ca <- length(higher) + length(lower)
print('higher and lower')
print(ca)

da <- length(muchhigher) + length(muchlower)
print('much higher and much lower')
print(da)

erepro_arr[i,c(1:17)] <- mariaParams$erepro
erepro_arr[i,18] <- length(tinyhigher)
erepro_arr[i,19] <- length(higher)
erepro_arr[i,20] <- length(muchhigher)
erepro_arr[i,21] <- length(tinylower)
erepro_arr[i,22] <- length(lower)
erepro_arr[i,23] <- length(muchlower)

print(rmaxratio)
relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
print(relbio)

aa = ba+ca+da

if (aa == 0) {
        print("finished adjusting")
        break
      }


}

#save(erepro_arr, file = "ereproTune_May7.RData")

```

### Tune erepro 2: one spp at a time, assumptions 

This part is essential to assess species interactions. Now we fish one species at a time and see how that will affect the community. 

```{r}

## Here are my assumption about the sensitivity to fishing

sensitivity <- c("medium", "high", "low", "low", "medium", "medium", "high", "high", "low", "high", "medium", "medium", "medium", "medium", "high", "low", "medium")
mariaParams$sensitivity <- sensitivity

sensitivity <- mariaParams$sensitivity

exp.biom.decrease.min <- rep(NA, 17)
exp.biom.decrease.max <- rep(NA, 17)

fish.mort <- 0.2 ## for this fishing mortality I expect below levels of biomass decrease

exp.biom.decrease.min[which(sensitivity == "low")] <- 0.2
exp.biom.decrease.min[which(sensitivity == "medium")] <- 0.3
exp.biom.decrease.min[which(sensitivity == "high")] <- 0.5

exp.biom.decrease.max[which(sensitivity == "low")] <- 0.4
exp.biom.decrease.max[which(sensitivity == "medium")] <- 0.5
exp.biom.decrease.max[which(sensitivity == "high")] <- 0.75
```

### Tune erepro 2: one spp at a time, run 

```{r}

#Which species do you want to tune? Enter the number here
spptune <- which(mariaParams$species == species[13])
print(mariaParams$species[spptune])
print(mariaParams$sensitivity[spptune])

erepro_vec <- rep(NA, 100)
erepro_vec[1] <- mariaParams$erepro[spptune] # initial r_max value

tmax = 150

eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
dimnames(eff_arr) = list (rowtest, params@species_params$gear)
eff_arr[,spptune] <- fish.mort

for (i in 2:100) {
  print(i)

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
#params@initial_n <- params@initial_n*init_scalar

params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  
tasm1ef1 <- project(params, t_max = tmax, effort=eff_arr, dt = 0.2, diet_steps = 0)  
#plot(tasm1ef1)

bio.decrease <- 1- round(getBiomass(tasm1ef1)[tmax,spptune]/getBiomass(tasm1)[tmax,spptune],5)

#if the decrease in biomass is lower than the expected decrease the erepro is too high, spp recovers too fast
print(bio.decrease)

if (bio.decrease < exp.biom.decrease.min[spptune]) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]/1.05
  print("decreased erepro by 1.05")
}

if (bio.decrease < (exp.biom.decrease.min[spptune]/2)) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]/1.05
  print("decreased erepro by another 1.05")
}

##
if (bio.decrease > exp.biom.decrease.max[spptune]) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]*1.05
  print("increased erepro by 1.05 ")
}

if (bio.decrease > (exp.biom.decrease.max[spptune]*1.5)) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]*1.05
  print("increased erepro by another 1.05")
}

erepro_vec[i] <- mariaParams$erepro[spptune]
print("erepro now is")
print(mariaParams$erepro[spptune])

if (bio.decrease  < exp.biom.decrease.max[spptune] & bio.decrease > exp.biom.decrease.min[spptune]) {
  print("finished adjusting")
  break
}

}

```

### Tune daily intake with gamma 

I want daily intake to be around 4% of body weight for small fish and ca 1% for adults

```{r}
## setup an array 
gamma_arr <- matrix(nrow = 100, ncol = 21)
gamma_arr[1,c(1:17)] <- mariaParams$gamma # initial r_max value

diettime <- tmax # year to get diet
no_pred <- length(model@params@species_params$species)
no_prey <- length(model@params@species_params$species) + 3
tmax = 150
#which size class corresponds to ca 1g
onegsize <- max(which(params@w < 1)) + 1
## herbivores are expected to consume 3x higher daily intake as proportion of their body weight. So create an adjustment vector to tune all gamma at once
adj_vector <- rep(1,17)
adj_vector[which(mariaParams$funcgr == "herbi")] <- 3
## small species also would consume relatively higher proportion of their body weight when they are (small) adults compared to big species, so adjust those as well 
adj_vector[which(mariaParams$w_inf < 100)] <- 2
## relative intake for inverebrates is higher, so adjust urchins even more (allow adult urchins to have higher intake than normal fish herbivores)
adj_vector[which(mariaParams$species == "urchins")] <- 4

for (i in 2:100) {

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
#plot(tasm1)

#simulation name

model <- tasm1 

### Consumption as a proportion of weight

cons_juv <- as.numeric(vector())
cons_ad <- as.numeric(vector())

diet2 <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = F)

  for (ab in 1:no_pred) {
    #mean juvenile feeding level at the last time step. Same for adults below
    matsize <- max(which(params@w < model@params@species_params$w_mat[ab]))
    maxsize <- max(which(params@w < model@params@species_params$w_inf[ab]))
    
    temp <- diet2[ab,,]
    tot.diet <- round(apply(temp, 1, sum),4)
    prop_cons <- ((tot.diet/model@params@w)/365)*100

    #mean juvenile feeding level at the last time step. Same for adults below
    juv_cons <- round(mean(prop_cons[c(onegsize:matsize)]), 3)
    ad_cons <- round(mean(prop_cons[c((matsize+1):maxsize)]), 3)
    cons_juv <- c(cons_juv, juv_cons)
    cons_ad <- c(cons_ad, ad_cons)

  }

cons_juv <- round(cons_juv/adj_vector,3)
cons_ad <- round(cons_ad/adj_vector,3)

## Now tune adult consumption and hopefully juvenile consumption will fix itself 
## I want adult daily intake to be between 0.5 and 1% of body weight 
# If daily intake is < 0.5% of body weight I want to increase gamma a bit
#tinyhigher <- which(cons_ad < 0.5)
#print(tinyhigher)
#mariaParams$gamma[c(tinyhigher)] <- mariaParams$gamma[c(tinyhigher)] * 1.01

higher <- which(cons_ad < 0.4)
print(higher)
mariaParams$gamma[c(higher)] <- mariaParams$gamma[c(higher)] * 1.03

#tinylower <- which(cons_ad > 1)
#print(tinylower)
#mariaParams$gamma[c(tinylower)] <- mariaParams$gamma[c(tinylower)] / 1.01

lower <- which(cons_ad > 1.2)
print(lower)
mariaParams$gamma[c(lower)] <- mariaParams$gamma[c(lower)] / 1.03


#aa <- length(tinyhigher) + length(tinylower)
#print('tiny higher and lower')
#print(aa)

aa <- length(higher) + length(lower)
print('higher and lower')
print(aa)
print(cons_ad)
relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
print("relative biomass")
print(relbio)

gamma_arr[i,c(1:17)] <- mariaParams$gamma
#gamma_arr[i,18] <- length(tinyhigher)
gamma_arr[i,19] <- length(higher)
#gamma_arr[i,20] <- length(tinylower)
gamma_arr[i,21] <- length(lower)

if (aa == 0) {
        print("finished adjusting")
        break
      }
}


```

### Save

```{r}
runname <- "N19" #November 19, with fixed initial abundances

save(mariaParams, file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
save(params, file = paste("../modelParams/params_", runname, ".RData", sep = ""))
save(inter, file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
stable_abund <- tasm1@n[tmax,,]
stable_pl <- tasm1@n_pp[tmax,]
stable_ben <- tasm1@n_bb[tmax,]
stable_alg <- tasm1@n_aa[tmax,]
save(stable_abund, file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
save(stable_pl, file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
save(stable_ben, file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
save(stable_alg, file = paste("../modelParams/naa_", runname, ".RData", sep = ""))

```

### ###########
### MAIN RUNS

### Basic run

```{r warning=FALSE, message=FALSE, echo=T}

### setup 
params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg
## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- mizerRewire::project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)
plot(tasm1)

#getBiomass(tasm1)[tmax,]

relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
relbio

obsInvAb <- sum(InvData$meanAb[which(InvData$wgt > min_w_bb & InvData$wgt < w_bb_cutoff)])
modelInvAb <- sum(tasm1@n_bb[tmax,]*params@dw_full)
#ratio of model vs observed inv abundances (benthic spectrum) in the relevant range
modelInvAb/obsInvAb

```

### Run with fishing   

Here is an important test of the model!! Are species able to sustain small amounts of fishing? If RDI/RDD is too low, then some species will start going extinct even with low fishing

```{r warning=FALSE, message=FALSE, echo=T}

#now run with some fishing mortality (equal to all)
tmax = tmax
#tasm1 <- project(params, t_max = tmax, effort=0, dt = 0.2, diet_steps = 0)  

tasm1ef <- project(params, t_max = tmax, effort=0.2, dt = 0.2, diet_steps = 0)  
plot(tasm1ef)

getBiomass(tasm1ef)[mean((tmax-10):tmax),]/getBiomass(tasm1)[tmax,]

getBiomass(tasm1ef)[mean((tmax-10):tmax),]

#plotDietComp(tasm1ef)
```

### Fish one species in a loop

This part is essential to assess species interactions. Now we fish one species at a time and see how that will affect the community. How do we visualise the output matrix?

```{r, eval = F}
tmax = tmax
fish.mort <- 0.2

relbiomFishOne <- data.frame()

for (i in 1:length(params@species_params$species)) {

#set up the effort array
eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
dimnames(eff_arr) = list (rowtest, params@species_params$gear)
eff_arr[,i] <- fish.mort

#run the model with fishing using previously set params set
tasm1ef1 <- project(params, t_max = tmax, effort=eff_arr, dt = 0.2, diet_steps = 0)  
plot(tasm1ef1)

print(round(getBiomass(tasm1ef1)[tmax,]/getBiomass(tasm1)[tmax,],5))

temp <- round(getBiomass(tasm1ef1)[tmax,]/getBiomass(tasm1)[tmax,],5)
relbiomFishOne <- rbind(relbiomFishOne, temp)

}

colnames(relbiomFishOne) <- params@species_params$species #biomasses of species as you fish species in rows
rownames(relbiomFishOne) <- paste("fish_",params@species_params$species, sep="")

#save(relbiomFishOne, file = "../outputs/FishOneSppBiom_Nov20.RData")

knitr::kable(relbiomFishOne, digits = 2)

#look at how each species responds to its own fishing
responseToF <- diag(as.matrix(relbiomFishOne))
which(responseToF < 0.4)

## explore correlations among species, etc
## Look if biomass of one species (T_caudimaculatus in my case) is strongly correlated to other species
#cor_Tra <- rep(NA, 17)
#p_Tra <- rep(NA, 17)

#for (i in 1:length(params@species_params$species)) {
#onesp <- relbiomFishOne[,i]
#temp <- cor.test(relbiomFishOne$T_caudimaculatus, onesp)
#cor_Tra[i] <- temp$statistic
#p_Tra[i] <- round(temp$p.value,5)
#}
#trach_inter <- cbind(as.character(mariaParams$species), round(cor_Tra,3), round(p_Tra,4))  


```

Now if interactions are too strong or some species are too much or too little sensitive to fishing we might want to tune this by modifying erepro of one species 

### Diet 
Why doesn't the plot work from mizer??? 

#Function
```{r}

 plotDiet <- function(object, diettime = tmax) {
  model <- object
  diet <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = T)
  prey <- dimnames(diet)$prey
  predator <- dimnames(diet)$predator
  prey <- factor(prey, levels = rev(prey))
  predator <- factor(predator, levels = (predator))
  w.temp = rep(params@w, each = length(predator))
  w = rep(w.temp, times = length(prey))
  plot_dat <- data.frame(
    Proportion = c(diet),
    w = w,
    Prey = rep(prey, each = (length(params@w)*length(predator))),
#    Predator = rep(predator, each = (length(params@w)*length(prey))))
    Predator = rep(predator))
  plot_dat <- plot_dat[plot_dat$Proportion > 0, ]
#  colorvalues <- c(params@linecolour[c(1:length(params@species_params$species))])
#  colorvalues <- c(colorvalues,"green","brown","yellow")
  ggplot(plot_dat) +
    geom_area(aes(x = w, y = Proportion, fill = Prey)) +
    facet_wrap(~ Predator, ncol=5) +
    scale_x_log10() +
    labs(x = "Size [g]") 
}

```

```{r}

diettime <- tmax # year to get diet
model <- tasm1 #simulation name

## diet function can give output as proportion or as total consumed weight, depending on the "proportion" parameter
diet <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = T)

#Plot diet  
plotDiet(tasm1, diettime = tmax)

plotPPMR(tasm1) #plot realised PPMR - this is also a function Jon wrote and they are now all incorporated into rewire-temp


#I want my large predators to eath fish!
# which size class to check the diets for (500g for example)
dietsize = max(which(params@w < 1000))
#sppdiet <- round(diet[,dietsize,],3)

# or just look at one species
round(diet[which(mariaParams$species == "Notolabrus"),dietsize,],3)
round(diet[which(mariaParams$species == "D_lewini"),dietsize,],3)
round(diet[which(mariaParams$species == "predator"),dietsize,],3)
round(diet[which(mariaParams$species == "lobsters"),dietsize,],3)
round(diet[which(mariaParams$species == "L_forsteri"),dietsize,],3)
round(diet[which(mariaParams$species == "leather_cool"),dietsize,],3)
round(diet[which(mariaParams$species == "M_freycineti"),dietsize,],3)
#round(diet[which(mariaParams$species == "urchins"),dietsize,],3)

dietsize = max(which(params@w < 100))
#Alternatively look who eats certain species
diet[,dietsize,which(mariaParams$species == "T_caudimaculatus")]
diet[,dietsize,which(mariaParams$species == "C_rasor")]
diet[,dietsize,which(mariaParams$species == "P_laticlavius")]
diet[,dietsize,which(mariaParams$species == "Notolabrus")]
diet[,dietsize,which(mariaParams$species == "urchins")]


```

### Get FMSY
F and max sustain yield should be at around 0.2 if no other info is available (higher for small species). If it is too low it means reproduction is not fast enough, and we need to increase RDI/RDD ratio or decrease linear dependence on stock biomass. 
This takes a while to run!

NOTE: THE run is saved, so make sure to load the file rather than run everything again 

```{r}
#might beed to run it for longer for biomasses to stabilise
tmax = 200
yield_final <- data.frame()
eff_vector1 = seq(from = 0.01, to = 0.09, by = 0.01)
eff_vector2 = seq(from = 0.1, to = 0.2, by = 0.02)
eff_vector3 = seq(from = 0.25, to = 0.95, by = 0.05)
eff_vector = c(eff_vector1, eff_vector2, eff_vector3)

for (i in 1:length(eff_vector)) {
  print("eff_number")
  print(i)
  yield_array <- as.data.frame(matrix(ncol = 17, nrow = tmax))
  colnames(yield_array) <- mariaParams$species
  
  eff.now <- eff_vector[i]
  yield_array$fishing <- eff.now
  yield_array$year <- c(1:tmax)
  
  for (b in 1:length(mariaParams$species)) {
    print("sp_no")
    print(b)
    #Setup effort array
    eff_arr = array(0, dim = c(tmax,17))
    rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
    dimnames(eff_arr) = list (rowtest, params@species_params$gear)
    eff_arr[,b] <- eff.now
    
    tasm1ef <- project(params, t_max = tmax, effort=eff_arr, dt = 0.2, diet_steps = 0)
    yield <- getYield(tasm1ef)
    yield_array[,b] <- yield[,b]
    
  }
  
  yield_final <- rbind(yield_final, yield_array)   
  
}   

#save(yield_final, file = "../outputs/yield001to095.RData")
```

something does not work here, need to check:
```{r}
## check if yields have stabilised for a given fishing level
load(file = "../outputs/yield001to07_lessDD.RData")

#which(yield_final$fishing == 0.2)
#test <- yield_final[-c(4001:4250),] #0.2 mort was used two times so remove some rows
#test2 <- test[-c(2251:2500),]

oneeffort <- yield_final %>% filter (fishing == 0.9) ## decide which fishign level to use
par(mfrow = c(4,5), mar = c(1,1,1,1))

for (i in 1:length(mariaParams$species)) {
  onespp <- oneeffort[,i]
  plot(x = c(1:length(onespp)), y = onespp, type= 'l', ylim = c(0, max(onespp)))
}

yieldF <- yield_final %>% filter (year == tmax)  

## get the actual F at max yield
fmsy = rep(NA, length(mariaParams$species))

for (i in 1:length(mariaParams$species)) {
  
fmsy[i] <- yieldF$fishing[which(yieldF[,i] == max(yieldF[,i]))]
}

MaxYield <- list()
MaxYield$fmsy <- as.vector(fmsy)
MaxYield$species <- as.character(mariaParams$species)
MaxYield$erepro <- round(mariaParams$erepro,3)
MaxYield$sensitivity <- as.character(mariaParams$sensitivity)
MaxYield <- as.data.frame(MaxYield)

write.csv(MaxYield, file = "../outputs/Fmsy.csv")

```

### Growth curves    

Plot and check individual growth curves. Note that the reference curves are based on vb_k and Linf, and vb_k is a highly uncertain parameter for many species. So black refrence curves are not good in many species. 

```{r warning=FALSE, message=FALSE, echo=T}
tasm1 <- tasm1

#All species
plotGrowthCurves(tasm1, percentage = T)



#Individual species 
plotGrowthCurves(tasm1, species = params@species_params$species[3], max_age = 10, percentage = F)

max_age = c(15, 20, 10, 10, 10, 6, 80, 40, 5, 20, 10, 15, 10, 10, 20, 10, 20)

par(mfrow = c(4,5))

## growth curves
for (i in 1:17) {
  
  plotGrowthCurves(tasm1, species = params@species_params$species[i], max_age = max_age[i], percentage = F)

}

```

#Plot all sizespectra at a chosen time

```{r warning=FALSE, message=FALSE, echo=T}
par(mfrow = c(1,1), mar = c(4,4,4,4))

tplot = 150 #which time to plot

model <- tasm1

#plot size spectra
plot(log10(model@params@w_full), log10(model@n_pp[tplot,]*params@dw_full), type = 'l', ylim = c(-10,10), xlim = c(-5,5),lwd = 2, xlab = 'size, g', ylab = 'abundance')
points(log10(model@params@w_full), log10(model@n_bb[tplot,]*params@dw_full), type = 'l', lwd = 2, col = 'red')
points(log10(model@params@w_full), log10(model@n_aa[tplot,]*params@dw_full), type = 'l', lwd = 1, col = 'green')

for (i in 1: length(params@species_params$species)) {
  points(log10(model@params@w), log10(model@n[tplot,i,]*params@dw), type = 'l')
  
}

ppatmat = log10(mariaParams$w_mat/mariaParams$beta) # prefered prey size at predators maturation size
abline(v = c(ppatmat), lty = 2, col = 'grey')

abline(v = log10(mariaParams$w_mat), lty = 2, col = 'yellow')

```

### Backgr mort: functions 

```{r}
## need to pass functions separately

getBenthosMort <- function(object, n, n_pp, n_bb, n_aa, intakeScalar,
             pred_rate = getPredRate(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar)) {
    temp <- matrix(object@species_params$avail_BB, nrow = 1, ncol = length(object@species_params$avail_BB), byrow = T)
    m2_benthos <- temp %*% pred_rate
    return(m2_benthos)
}


getPlanktonMort <- function(object, n, n_pp, n_bb, n_aa, intakeScalar,
             pred_rate = getPredRate(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar)) {

    temp <- matrix(object@species_params$avail_PP, nrow = 1, ncol = length(object@species_params$avail_PP), byrow = T)
    m2_plankton <- temp %*% pred_rate

    return(m2_plankton)
}

getAlgalMort <- 
  function(object, n, n_pp, n_bb, n_aa, intakeScalar,
           pred_rate = getPredRate(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar)) {
        temp <- matrix(object@species_params$avail_AA, nrow = 1, ncol = length(object@species_params$avail_AA), byrow = T)
    m2_algae <- temp %*% pred_rate
    
    return(m2_algae)
  }
```

### Benthos mort

```{r}
tasm1 <- tasm1 #put your model name here
params <- params
tmax <- tmax #time to plot

## Benthos 
#get ranges for plotting 
w_full_bb <- params@w_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
#dw_full_bb <- params@dw_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]

## to run the line below you need to run the functions in the chunk above!
ben_mort <- getBenthosMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

ben_mort <- getBenthosMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

#only get relevant size ranges
ben_mort <- ben_mort[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]

#plot
plot(log(w_full), ben_mort, type = 'l', lwd = 2, main = "Inst benthos mortality rate per year", xlab = "log size, g", ylab = "mortality 1/years")
```

### Plankton mort 

```{r}
tasm1 <- tasm1 #put your model name here
params <- params
tmax <- tmax #time to plot

#get ranges for plotting 
w_full_pp <- params@w_full[which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
#dw_full_pp <- params@dw_full[which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]

pla_mort <- getPlanktonMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

#only get relevant size ranges
pla_mort <- pla_mort[which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]

#plot
plot(log(w_full_pp), pla_mort, type = 'l', lwd = 2, main = "Inst plankton mortality rate per year", xlab = "log size, g", ylab = "mortality 1/years")
```


### Algal mort

```{r}
tasm1 <- tasm1 #put your model name here
params <- params
tmax <- tmax #time to plot

#get ranges for plotting 
w_full_aa <- params@w_full[which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]

alg_mort <- getAlgalMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

#only get relevant size ranges
alg_mort <- alg_mort[which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]

#plot
plot(log(w_full_aa), alg_mort, type = 'l', lwd = 2, main = "Inst algal mortality rate per year", xlab = "log size, g", ylab = "mortality 1/years")


```

### starv mort function

```{r}

getSMort <- function(object, n, n_pp, n_bb, n_aa, intakeScalar, metScalar,
                     e = getEReproAndGrowth(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar, metScalar = metScalar)){

            if (!all(dim(e) == c(nrow(object@species_params), length(object@w)))) {
              stop("e argument must have dimensions: no. species (",
                   nrow(object@species_params), ") x no. size bins (",
                   length(object@w), ")")
            }

        mu_S <- e # assign net energy to the initial starvation mortality matrix

        #x_old <- t(t(mu_S)/(0.1*object@w)) # apply the mortality formula to the whole matrix
        #print (dim(x_old))
        #print(x_old[c(3:6, 50:60)])
        #remember, 0.1 is a parameter here, which is a scaling constant on how negative e translates to starvation mortality. For a 100g fish with a negative e of -1, it will give starvation value of 0.1. For a 10 g fish with e of -1, it will give mortality of 1. This seems reasonable for a start, but a more conmplex relationship could be explored in the future 
        ### TODO ### a small value added here to avoid division by zero, but not sure this is ideal
        x <- t(t(mu_S)/((1/(object@c+1e-12))*object@w))
        #print (dim(x))
        #print(x[c(3:6, 50:60)])
        mu_S[mu_S<0] <- x[x<0] # replace the negative values of e by the starvation mortality
        mu_S[mu_S>0] <- 0 # replace the positive values of e by 0

        mu_S = - mu_S # this returns negative mortality values, because negative e is divided by weight. So to get the actual mortality we turn them into positive values 
        #comment to test
    return(mu_S)
}

```

### Predation mort proportion: TODO

```{r}
sim <- tasm1

final_time_idx <- dim(sim@n)[[1]]
n <- sim@n[final_time_idx, , ]
n_pp <- sim@n_pp[final_time_idx, ]
n_bb <- sim@n_bb[final_time_idx, ]
n_aa <- sim@n_aa[final_time_idx, ]

#test <- getPredMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)])

total_pred_mort <- rowSums(getPredMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)]) * n)
total_starv_mort <- rowSums(getSMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)], metScalar = sim@metTempScalar[,,(final_time_idx/dt)]) * n)

total_mort <- rowSums(getMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)], morScalar = sim@morTempScalar[,,(final_time_idx/dt)], metScalar = sim@metTempScalar[,,(final_time_idx/dt)], effort = 0) * n)

total_mort <- rowSums(getMort(sim@params, n, n_pp) * n)
proportion <- total_pred_mort / total_mort
st_proportion <- total_starv_mort / total_mort


```



### Background depletion 

In the stabilised set of parameters, where initial abundances are set from final abundances the depletion is of course 1, because everything is stable 

```{r warning=FALSE, message=FALSE, echo=T}

model <- tasm1

smallcut <- max(which(model@params@w_full < min_w_bb)) +1
largecut <- min(which(model@params@w_full > w_bb_cutoff)) -1

largecutP <- min(which(model@params@w_full > w_pp_cutoff)) -1

smallcutA <- max(which(model@params@w_full < min_w_aa)) +1
largecutA <- min(which(model@params@w_full > w_aa_cutoff)) -1

plot(log10(model@params@w_full[c(smallcut:largecut)]), (model@n_bb[tmax,c(smallcut:largecut)]/model@n_bb[1,c(smallcut:largecut)]),ylim = c(0,1.5), xlim = c( log10(model@params@w_full[1]), log(model@params@w_full[largecutA])), type = 'l', col = 'red', xlab = "log weight,g", ylab = "depletion compared to initial abundance", main = "Depletion of plankton, benthos(red) and algae(green)")
points(log10(model@params@w_full[c(1:largecutP)]), (model@n_pp[tmax,c(1:largecutP)]/model@n_pp[1,c(1:largecutP)]),type = 'l', col = 'black')
points(log10(model@params@w_full[c(smallcutA:largecutA)]), (model@n_aa[tmax,c(smallcutA:largecutA)]/model@n_aa[1,c(smallcutA:largecutA)]),type = 'l', col = 'green')


```

### Get RDD/rmax

This tells you where the species are on their rmax level, but I found that this is not necessarily an indication of their sensitivity to fishing...

```{r warning=FALSE, message=FALSE, echo=T}

#Check where they are at rmax level
tmax =tmax
model <- tasm1

a1 <- getRDI(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD 
a2 <- getRDD(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], sex_ratio = 0.5, model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD to rmax ratio
rmaxratio <- a2/mariaParams$r_max
#plot(rmaxratio)
round(rmaxratio,4)
round(a1/a2, 4)


```

### Sp params

Write species params for the publication 

```{r}
para <- params@species_params

sppPprint <- para %>% select(species, w_inf, w_min, w_mat, beta, sigma, avail_PP, avail_BB, avail_AA, r_max, erepro, gamma, ks, h, z0)

sppPprint[,10] <- round(sppPprint[,10],5)
sppPprint[,11] <- round(sppPprint[,11],4)
sppPprint[,c(12:14)] <- round(sppPprint[,c(12:14)],2)
sppPprint[,15] <- round(sppPprint[,15],3)

write.csv(sppPprint, file = "../suplTables/TableSppParams2.csv")


```

##### ###########
#### ABC

### ABC first round on clusters

Run lots of combinations and only save relative biomass

```{r, eval = F}
#rm(list=ls())
#library(devtools)
#install.packages(vegan)
#library(vegan)
#install_github("astaaudzi/mizer", ref = "rewire-temp")
library(mizer, lib.loc = "/home/astaa/R/x86_64-pc-linux-gnu-library/3.5")
library(future.apply)
#library(furrr)
plan(multiprocess)

abcres <- function(...)  {
  
  # Load parameter files to initialise the runs. Presumably they will be available to all cores and I don't need to do it inside the function 
  runname <- "N19"
  load(file = paste("mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("params_", runname, ".RData", sep = ""))
  load(file = paste("inter_", runname, ".RData", sep = ""))
  load(file = paste("abund_", runname, ".RData", sep = ""))
  load(file = paste("npp_", runname, ".RData", sep = ""))
  load(file = paste("nbb_", runname, ".RData", sep = ""))
  load(file = paste("naa_", runname, ".RData", sep = ""))
  
  ## These are global variables, can they be loaded here, rather than inside the function? 
  #global initial parameter values which will be multiplied by random vectors at each iteration
  availUr = 0.15 #urchins to fish
  availUrLob = 0.55 #0.65 #Urchins to lobsters
  availSchooling = 0.4# 0.45 #avaiability of schooling fish to predators
  
  rmax_basic <- mariaParams$r_max
  gamma_basic <- mariaParams$gamma
  inter_basic <- c(availUr, availUrLob, availSchooling)
  
  init_params <- c(rmax_basic, gamma_basic, inter_basic)
  
  ## setup run time 
  tmax = 150
  #number of size groups 
  no_size_groups = 200
  #timestep used in the integration 
  dt = 0.5
  
  ## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
  
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
  ## Now the main analysis
  
  #random multiplier of initial rmax values
  multipl.1 <- runif(n = 17, min = 0.8, max = 1.2)
  
  rmax <- rmax_basic * multipl.1  
  mariaParams$r_max <- rmax
  
  ##random multiplier of initial gamma values
  multipl.2 <- runif(n = 17, min = 0.8, max = 1.2)
  gamma <- gamma_basic * multipl.2
  mariaParams$gamma <- gamma
  
  #random multiplier of initial interaction values
  multipl.3 <- runif(n = 3, min = 0.8, max = 1.2)
  availUr <- round((inter_basic[1] * multipl.3[1]),3)
  availUrLob <- round((inter_basic[2] * multipl.3[2]),3)
  availSchooling <- round((inter_basic[3] * multipl.3[3]),3)
  
  # and overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  
  #get relative biomasses
  relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
  
  inter_new <- c(availUr, availUrLob, availSchooling)
  
  ## write down current param values
  param_values <- as.numeric(c(mariaParams$r_max, mariaParams$gamma, inter_new))
  
  #report results
  result_values <- as.numeric(round(relbio, 4))
  
  ## now fish everything at 0.2
  #tasm1ef <- project(params, t_max = tmax, effort= 0.2, dt = dt)
  #get relative fished versus unfished biomass 
  #fishbiom <- getBiomass(tasm1ef)[tmax,]/getBiomass(tasm1)[tmax,]
  #report results 
  #result_values <- c(result_values, as.numeric(round(fishbiom, 4)))
  
  abcresult <- c(param_values, result_values)
  return(abcresult)
  
}

iter <- 200000

set.seed(123)

abc1 <- future_lapply(seq_len(iter), abcres, future.seed = TRUE)

#future_map(iter, abcres, .progress = TRUE)

saveRDS(abc1, file = "abc1.rds")

```

### Analyse ABC first round 

from the 2.2mln combinations select those that have 4x times bigger or smaller relative biomass

```{r}
#load the file
#First run with narrower "priors"
#load(file = "../ABCruns/ABCNov16.RData")
## These are multiplied by 20% (0.8-1.2)
load(file = "../ABCruns/ABC1_new_N20.RData") ## new run, 200K, no fishing
load(file = "../ABCruns/ABC2_new_N20.RData") ## new run, 200K, no fishing
ABC20p <- rbind(ab1, ab2) #400K
rm(ab1, ab2)

#These are multiplied by 40% (0.6-1.4)
load(file = "../ABCruns/ABC1_wider.RData") ## 200K
ABC40p <- abw1

## Now I have 1.6mln runs with 0.5-2x multiplier on rmax, gamma and inter
load(file = "../ABCruns/ABCTwice.RData")
load(file = "../ABCruns/ABCTwice2.RData") 
ABC100p <- rbind(abcTwice, abcTwice2) 
rm(abcTwice, abcTwice2)

#ABCresult <- abw1
#param_values <- as.numeric(c(mariaParams$r_max, mariaParams$gamma, inter_new))
#result_values <- as.numeric(round(relbio, 4))
#result_values <- c(result_values, as.numeric(round(fishbiom, 4)))
#abcresult <- c(param_values, result_values)


#name columns 
cc1 <- paste("rmax", mariaParams$species, sep="_")
cc2 <- paste("gamma", mariaParams$species, sep="_")
cc3 <- c("availUr", "availUrLob", "availSch")
#cc4 <- c("lambda", "lambda_ben", "lambda_alg")
cc5 <- paste("relbiom", mariaParams$species, sep="_")
#cc6 <- paste("fishedbiom", mariaParams$species, sep="_")

#column <- c(cc1, cc2, cc3, cc4, cc5, cc6)
#column <- c(cc1, cc2, cc3, cc4, cc5)
column <- c(cc1, cc2, cc3, cc5)


#colnames(abw1) <- column


## Fix relative biomasses relative to the new relative biomasses

## The runs reported relative biomases based on all scaled biomasses
#relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
#mariaParamsGood <- mariaParams
#load(file = "../ABCruns/mariaParams_BEST_N.RData")
#scaledAbOld <-mariaParams$scaledBio
#scaledAbNew <- mariaParamsGood$scaledBio
#temp1 <- as.matrix(ABCresult[,c(38:54)])
#correction <- function(x){
#  (x*scaledAbOld)/scaledAbNew
#}
#test <- t(apply(temp1,1,correction))
#ABCresult[,c(38:54)] <- test

###
#for 20% variation out of 400K I have 42K of 0.5-2x relative biomasses, for 0.4-2.5 there are 135K; for 0.33-3x biomass - 209K cases
#for 40% variation out of 200K I have 49 cases; for 0.4-2.5 there are 718 cases, for 0.33-3x there are 3623 cases
#for 100% variation out of 1.6mln I have 0 cases, for 0.4-2.5 there are 32 cases; for 0.33-3x biomass there are 307 cases


#ABCresult <- ABC20p
ABCresult <- rbind(ABC20p, ABC40p, ABC100p)
colnames(ABCresult) <- column
#save(ABCresult, file = "../ABCruns/abc_firstRound.RData")
#initialise result columns for the first criterion: relative biomass
ABCresult$reject <- 0
ABCresult$temp <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.25
upper.rel.abun <- 4

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp <- which(ABCresult[,(i+ 37)] < lower.rel.abun  | ABCresult[,(i + 37)] > upper.rel.abun) #38 is the first column of results
  ABCresult$temp[temp] <- 1
  ABCresult$reject <- ABCresult$reject + ABCresult$temp
}

accepted.result <- ABCresult[which(ABCresult$reject == 0),]
save(accepted.result, file = "accepted.RData")
test <- accepted.result[c(200001:287490),c(1:37)]

#save(test, file = "accepted5.RData")

load(file = "../ABCruns/accepted.RData")


write.csv(accepted.result[c(100001:200000),c(1:37)], file = "accept2.csv")
accept.save <- accepted.result[c(100001:200000),c(1:37)]
save(accept.save, file = "accep2.RData", version = 2)

#Get original values
runname <- "N19"
load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
#load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))

rmax_orig <- mariaParams$r_max
gamma_orig <- mariaParams$gamma
inter_orig <- c(0.15,0.55,0.4)
#  availUr = 0.15 #urchins to fish
#  availUrLob = 0.55 #0.65 #Urchins to lobsters
#  availSchooling = 0.4# 0.45 #avaiability of schooling fish to predators

## now plot rmax values  
rmaxplot <- accepted.result[,c(1:17)] #just select first 17 rmax variables
gammaplot <- accepted.result[,c(18:34)] #just select second 17 gamma variables
interplot <- accepted.result[,c(35:37)] #select inter variables
#lambdaplot <- accepted.result[,c(38:40)] #select inter variables

## plot rmax

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(rmaxplot[,i], breaks = 50, col = "grey", xlim = c((min(rmaxplot[,i])- mean(rmaxplot[,i])/2), (max(rmaxplot[,i])+ (mean(rmaxplot[,i])/2))), main = colnames(rmaxplot)[i])
  abline(v = rmax_orig[i], lwd = 2, col = 'red')
  abline (v  = (rmax_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (rmax_orig[i]*2), lty =2, col = 'red')
  abline (v  = (rmax_orig[i]*0.6), lty =2, col = 'blue')
  abline (v  = (rmax_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (rmax_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (rmax_orig[i]*1.2), lty =2, col = 'green')
}

#plot gamma

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(gammaplot[,i], breaks = 50, col = "grey", xlim = c((min(gammaplot[,i])- mean(gammaplot[,i])/2), (max(gammaplot[,i])+ (mean(gammaplot[,i])/2))), main = colnames(gammaplot)[i])
  abline(v = gamma_orig[i], lwd = 2, col = 'red')
  abline (v  = (gamma_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (gamma_orig[i]*2), lty =2, col = 'red')
  abline (v  = (gamma_orig[i]*0.6), lty =2, col = 'blue')
  abline (v  = (gamma_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (gamma_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (gamma_orig[i]*1.2), lty =2, col = 'green')
}

#inter plot 
par(mfrow = c(1,3), mar = c(3,3,3,3))

for (i in 1:3) {
  
  hist(interplot[,i], breaks = 50, col = "grey", xlim = c((min(interplot[,i])- mean(interplot[,i])/2), (max(interplot[,i])+ (mean(interplot[,i])/2))), main = colnames(interplot)[i])
  abline(v = inter_orig[i], lwd = 2, col = 'red')
  abline (v  = (inter_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (inter_orig[i]*2), lty =2, col = 'red')
  abline (v  = (inter_orig[i]*0.6), lty =2, col = 'blue')
  abline (v  = (inter_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (inter_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (inter_orig[i]*1.2), lty =2, col = 'green')
}


#lambda plot 
par(mfrow = c(1,3), mar = c(3,3,3,3))

for (i in 1:3) {
  
  hist(lambdaplot[,i], breaks = 15, col = "grey", xlim = c((min(lambdaplot[,i])- mean(lambdaplot[,i])/4), (max(lambdaplot[,i])+ (mean(lambdaplot[,i])/4))), main = colnames(lambdaplot)[i])
  abline(v = lambda_orig[i], lwd = 2, col = 'red')
  abline (v  = (lambda_orig[i]*0.9), lty =2, col = 'red')
  abline (v  = (lambda_orig[i]*1.1), lty =2, col = 'red')
}

save(accepted.result, file = "acceptedABC1150values.RData")
save(values, file = "originalABCvalues.RData")
```

### ABC second round on clusters

Run 287K selected param combinations but this time run more scenarios with each and get more data (diets, fishing response)
 
```{r, eval = F}
#rm(list=ls())
#library(devtools)
#install.packages(vegan)
#library(vegan)
#install_github("astaaudzi/mizer", ref = "rewire-temp")
library(mizer, lib.loc = "/home/astaa/R/x86_64-pc-linux-gnu-library/3.5")
library(future.apply)
#library(furrr)
plan(multiprocess)

abcres <- function(iter)  {
  
  # Load parameter files to initialise the runs. Presumably they will be available to all cores and I don't need to do it inside the function 
  runname <- "N19"
  load(file = paste("mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("params_", runname, ".RData", sep = ""))
  load(file = paste("inter_", runname, ".RData", sep = ""))
  load(file = paste("abund_", runname, ".RData", sep = ""))
  load(file = paste("npp_", runname, ".RData", sep = ""))
  load(file = paste("nbb_", runname, ".RData", sep = ""))
  load(file = paste("naa_", runname, ".RData", sep = ""))
  load(file = "accepted1.RData")
  
  
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  ## setup run time 
  tmax = 150
  #number of size groups 
  no_size_groups = 200
  #timestep used in the integration 
  dt = 0.5
  #
  fish.mort = 0.2
  
  
  ## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
  
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
  ## Now the main analysis
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  #get relative biomasses
  unfishedBio <- getBiomass(tasm1)[tmax,]
  
  #get diet 
  ## diet function can give output as proportion or as total consumed weight, depending on the "proportion" parameter
  diet <- getDiet(params,tasm1@n[tmax,,],tasm1@n_pp[tmax,], tasm1@n_bb[tmax,], tasm1@n_aa[tmax,], proportion = T)
  
  #I want my large predators to eath fish! So I get diet at 2/3 of the maximum size
  size <- mariaParams$w_inf[which(mariaParams$species == "predator")]*0.66
  PredDiet <- as.numeric(round(diet[which(mariaParams$species == "predator"),max(which(params@w < size)),],3))
  PredF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "predator"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "lobsters")]*0.66
  LobsDiet <- as.numeric(round(diet[which(mariaParams$species == "lobsters"),max(which(params@w < size)),],3))
  LobsF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "lobsters"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "D_lewini")]*0.66
  LewiDiet <- as.numeric(round(diet[which(mariaParams$species == "D_lewini"),max(which(params@w < size)),],3))
  LewiF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "D_lewini"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "Notolabrus")]*0.66
  NotoDiet <- as.numeric(round(diet[which(mariaParams$species == "Notolabrus"),max(which(params@w < size)),],3))
  NotoF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "Notolabrus"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "urchins")]*0.66
  UrcDiet <- as.numeric(round(diet[which(mariaParams$species == "urchins"),max(which(params@w < size)),],3))
  UrcF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "urchins"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "T_caudimaculatus")]*0.66
  TrachDiet <- as.numeric(round(diet[which(mariaParams$species == "T_caudimaculatus"),max(which(params@w < size)),],3))
  TrachF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "T_caudimaculatus"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "C_rasor")]*0.66
  RasoDiet <- as.numeric(round(diet[which(mariaParams$species == "C_rasor"),max(which(params@w < size)),],3))
  RasoF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "C_rasor"),max(which(params@w < size))],3))
  
  Diets <- c(PredDiet, LobsDiet, LewiDiet, NotoDiet, UrcDiet, TrachDiet, RasoDiet) #140 values
  FeedLevel <- c(PredF, LobsF, LewiF, NotoF, UrcF, TrachF, RasoF)
  
  #run with fishing 
  tasm1 <- project(params, t_max = tmax, effort=0.2, dt = dt)  
  fishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only predator
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "predator")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  PredfishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only lobsters
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "lobsters")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  LobsfishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only urchins
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "urchins")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  UrchfishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only Trachinops
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "T_caudimaculatus")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  TrafishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  results <- c(unfishedBio, Diets, FeedLevel, fishedBio, PredfishedBio, LobsfishedBio, UrchfishedBio, TrafishedBio)
  #report results
  result_values <- as.numeric(round(results, 4))
  
  return(result_values)
  
}

iter <- 100000

set.seed(123)

abc1 <- future_lapply(seq_len(iter), abcres, future.seed = TRUE)

#future_map(iter, abcres, .progress = TRUE)

saveRDS(abc1, file = "abc1.rds")

```

### ABC2: load and prepare

```{r}

#load the file
#First run with narrower "priors"
#load(file = "../ABCruns/ABCNov16.RData")
## These are multiplied by 20% (0.8-1.2)
load(file = "../ABCruns/abc_secondRound.RData") ## new run, 200K, no fishing = results
load(file = "../ABCruns/accepted.RData") ## parameters

#This is how results were saved
#Diets <- c(PredDiet, LobsDiet, LewiDiet, NotoDiet, UrcDiet, TrachDiet, RasoDiet) #140 values
#FeedLevel <- c(PredF, LobsF, LewiF, NotoF, UrcF, TrachF, RasoF)
#results <- c(unfishedBio, Diets, FeedLevel, fishedBio, PredfishedBio, LobsfishedBio, UrchfishedBio, TrafishedBio)

#And here are params values
cc1p <- paste("rmax", mariaParams$species, sep="_")
cc2p <- paste("gamma", mariaParams$species, sep="_")
cc3p <- c("availUr", "availUrLob", "availSch")
ccP <- c(cc1p, cc2p, cc3p)
params <- accepted.result[,c(1:37)]

abc_second <- cbind(abc_second, params)

#name columns of results - there are lots of them!
 
cc1 <- paste("unfBio", mariaParams$species, sep="_")
cc2 <- c(paste("PredDiet", mariaParams$species, sep="_"),paste("PredDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc3 <- c(paste("LobsDiet", mariaParams$species, sep="_"),paste("LobsDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc4 <- c(paste("LewiDiet", mariaParams$species, sep="_"),paste("LewiDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc5 <- c(paste("NotoDiet", mariaParams$species, sep="_"),paste("NotoDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc6 <- c(paste("UrcDiet", mariaParams$species, sep="_"),paste("UrcDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc7 <- c(paste("TrachDiet", mariaParams$species, sep="_"),paste("TrachDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc8 <- c(paste("RasoDiet", mariaParams$species, sep="_"),paste("RasoDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc9 <- c("PredF", "LobsF", "LewiF", "NotoF", "UrcF", "TrachF", "RasoF")
cc10 <- paste("fishAllBio", mariaParams$species, sep="_")
cc11 <- paste("PredFishBio", mariaParams$species, sep="_")
cc12 <- paste("LobsFishBio", mariaParams$species, sep="_")
cc13 <- paste("UrchFishBio", mariaParams$species, sep="_")
cc14 <- paste("TraFishBio", mariaParams$species, sep="_")

#combine all columns names (including param names at the end)
column <- c(cc1, cc2, cc3, cc4, cc5, cc6, cc7, cc8, cc9, cc10, cc11, cc12, cc13, cc14, ccP)
#clear environment
rm(cc1, cc2, cc3, cc4, cc5, cc6, cc7, cc8, cc9, cc10, cc11, cc12, cc13, cc14, cc1p, cc2p, cc3p, ccP, params)

colnames(abc_second) <- column
#save(abc_second, file = "../ABCruns/abc_secondNamed.RData")
#save(column, file = "../ABCruns/colnames.RData")

```

### ABC2: lobster fishing response

Second, response to fishing lobsters 
 
```{r}
load(file = "../ABCruns/abc_secondNamed.RData")
load(file = "../ABCruns/colnames.RData")
#first generate a matrix of relative biomasses 

#overwirte the file so I can use the same code
#abc_second <- abc_second_afterPredF
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = dim(abc_second)[1], ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "LobsFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
breaks <- seq(from = 0, to = 5, by = 0.1)
breaks <- c(breaks, 10, 50, 100, 500)

for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,5))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.33
upper.rel.abun <- 3

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodLobsFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeLobsF <- abc_second
abc_second <- abc_second[goodLobsFish,]

```


### ABC2: urchin fishing response

Third, response to fishing urchins 
 
```{r}
#overwirte the file so I can use the same code
#abc_second <- abc_second_afterLobsF
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = dim(abc_second)[1], ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "UrchFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
breaks <- seq(from = 0, to = 2, by = 0.1)
breaks <- c(breaks, 3, 5, 10, 50, 100, 500)

for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,2))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits. Since response to urchin fishing is not so huge, we narrow down these limits
lower.rel.abun <- 0.67
upper.rel.abun <- 1.5

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodUrchFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeUrchF <- abc_second
abc_second <- abc_second[goodUrchFish,]

```

### ABC2: predator fishing response

Screen results in successive importance. First, response to fishing a predator 
 
```{r}
#abc_second <- abc_second_relbioUnf
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = length(abc_second[,1]), ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "PredFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
#these are just breaks for histogram plots
breaks <- seq(from = 0, to = 3, by = 0.1)
breaks <- c(breaks, 10, 50, 100, 500)

## get relative biomases when fishing predator (column ff+i) compared to unfished biomases (in column i)
for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,3))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.25
upper.rel.abun <- 2

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodPredFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeFishPred <- abc_second
abc_second <- abc_second[goodPredFish,]

```

### ABC2: trachinops fishing response

```{r}
#overwirte the file so I can use the same code
#abc_second <- abc_second_afterUrchF
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = dim(abc_second)[1], ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "TraFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
breaks <- seq(from = 0, to = 3, by = 0.1)
breaks <- c(breaks, 5, 10, 50, 100, 500)

for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,2))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits. Since response to urchin fishing is not so huge, we narrow down these limits
lower.rel.abun <- 0.67
upper.rel.abun <- 1.5

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodTrachFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeTrachF <- abc_second
abc_second <- abc_second[goodTrachFish,]

```

### ABC2: feeding level
we are now working with a much reduced set of parameters 

```{r}
#abc_second <- abc_second_afterTrachF
dim(abc_second)
par(mfrow = c(2,4))
#First explore various outputs 
#ranges of predator feeding level at 66% of Winf
hist(abc_second$PredF, breaks = 50)
#same for lobster
hist(abc_second$LobsF, breaks = 50)
#same for D lewini
hist(abc_second$LewiF, breaks = 50)
#same for Notolabrus
hist(abc_second$NotoF, breaks = 50)
#same for urchins
hist(abc_second$UrcF, breaks = 50)
#same for Trachinops
hist(abc_second$TrachF, breaks = 50)
#same for Caesioperca
hist(abc_second$RasoF, breaks = 50)

## first only use feeding level criterion (don't use lobsters as they always feed well)
#THis was used for the first 194 params
#length(which(abc_second$PredF > 0.6 & abc_second$LobsF > 0.6 & abc_second$LewiF > 0.6 & abc_second$NotoF > 0.50 #& abc_second$TrachF > 0.45 & abc_second$RasoF > 0.4))

length(which(abc_second$PredF > 0.55 & abc_second$LobsF > 0.55 & abc_second$LewiF > 0.55 & abc_second$NotoF > 0.55 & abc_second$TrachF > 0.5 & abc_second$PredF < 0.8 & abc_second$LobsF < 0.8 & abc_second$LewiF < 0.8 & abc_second$NotoF < 0.8 & abc_second$TrachF < 0.8))

#we save a vector of accepted values
goodfeed <- which(abc_second$PredF > 0.55 & abc_second$LobsF > 0.55 & abc_second$LewiF > 0.55 & abc_second$NotoF > 0.55 & abc_second$TrachF > 0.5 & abc_second$PredF < 0.8 & abc_second$LobsF < 0.8 & abc_second$LewiF < 0.8 & abc_second$NotoF < 0.8 & abc_second$TrachF < 0.8)

abc_second_beforeFeed <- abc_second
abc_second <- abc_second_beforeFeed[goodfeed,]

```

### ABC2: diets

Continue screening 

```{r}
## Now let's look at the proportion of benthos in various species diets (at 66% of max size)
par(mfrow = c(2,3))
#Pred, Lobs, Urch, Noto, Lewi, Trach, Raso
hist(abc_second$LewiDiet_benthos, breaks = 50)
hist(abc_second$PredDiet_benthos, breaks = 50)
hist(abc_second$LobsDiet_benthos, breaks = 50)
hist(abc_second$NotoDiet_benthos, breaks = 50)

par(mfrow = c(2,3))
## Or proportion of plankton
hist(abc_second$UrcDiet_plankton, breaks = 50)
hist(abc_second$LewiDiet_plankton, breaks = 50)
hist(abc_second$PredDiet_plankton, breaks = 50)
hist(abc_second$LobsDiet_plankton, breaks = 50)
hist(abc_second$TrachDiet_plankton, breaks = 50)
hist(abc_second$RasoDiet_plankton, breaks = 50)
## It all looks reasonable

par(mfrow = c(2,3))
## Lobsters shoudl eat urchins and fish
hist(abc_second$LobsDiet_urchins, breaks = 50)
hist(abc_second$LobsDiet_Notolabrus, breaks = 50)
hist(abc_second$LobsDiet_T_caudimaculatus, breaks = 50)
hist(abc_second$LobsDiet_D_lewini, breaks = 50)
hist(abc_second$LobsDiet_C_rasor, breaks = 50)
hist(abc_second$LobsDiet_leatherjack, breaks = 50)
## it all looks reasonable, don't want to restrict it without data

par(mfrow = c(2,2))
## who eats urchins?
hist(abc_second$LobsDiet_urchins, breaks = 50)
hist(abc_second$NotoDiet_urchins, breaks = 50)
hist(abc_second$PredDiet_urchins, breaks = 50)
hist(abc_second$LewiDiet_urchins, breaks = 50)
#we don't want predators to each that many urchins, max proportion at 0.3 or 0.25

par(mfrow = c(2,3))
## most diet of Lewini should consist of small pelagics I suppose
hist(abc_second$LewiDiet_T_caudimaculatus, breaks = 50)
hist(abc_second$LewiDiet_Notolabrus, breaks = 50)
hist(abc_second$LewiDiet_C_rasor, breaks = 50)
hist(abc_second$LewiDiet_P_laticlavius, breaks = 50)
hist(abc_second$LewiDiet_D_lewini, breaks = 50)
hist(abc_second$LewiDiet_leatherjack, breaks = 50)
#this looks reasonable

#criteria limiting consumption of benthos and urchins, and predator consumption of pelagics
#This was the original 194
#length(which(abc_second$PredDiet_benthos < 0.15 & abc_second$NotoDiet_benthos > 0.75 & abc_second$LewiDiet_urchins < 0.15 & abc_second$PredDiet_urchins < 0.3 & abc_second$LobsDiet_urchins > 0.3 & abc_second$LewiDiet_T_caudimaculatus > 0.10))

#Just restrict predators from eating too many urchins
length(which(abc_second$LewiDiet_urchins < 0.10 & abc_second$PredDiet_urchins < 0.20))

gooddiet <- which(abc_second$LewiDiet_urchins < 0.1 & abc_second$PredDiet_urchins < 0.2)

abc_second_beforeDiet <- abc_second
abc_second <- abc_second_beforeDiet[gooddiet,]

```

### ABC2: relative biomases 

```{r}


BiomsNoFish <- abc_second[,c(1:17)]

relative <- function(x){
  x/mariaParams$BioM2
}

RelativeBiomsNoFish <- as.data.frame(t(apply(BiomsNoFish,1,relative)))

RelativeBiomsNoFish$reject <- 0
RelativeBiomsNoFish$temp <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.5
upper.rel.abun <- 2

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp <- which(RelativeBiomsNoFish[,i] < lower.rel.abun  | RelativeBiomsNoFish[,i] > upper.rel.abun) 
  RelativeBiomsNoFish$temp[temp] <- 1
  RelativeBiomsNoFish$reject <- RelativeBiomsNoFish$reject + RelativeBiomsNoFish$temp
}

length(which(RelativeBiomsNoFish$reject == 0))
goodBiomass <- which(relativeBiomsPredF$reject == 0)


#abc_second_relbioUnf <- abc_second[which(RelativeBiomsNoFish$reject == 0),]

abc_second_beforeRelBiom <- abc_second
abc_second <- abc_second[which(RelativeBiomsNoFish$reject == 0),]
dim(abc_second)

```

### Final ABC2 set

```{r}
ff <- which(column == "rmax_Notolabrus")
rmaxplot <- abc_second[,c(ff:(ff+16))] #just select rmax variables

ff <- which(column == "gamma_Notolabrus")
gammaplot <- abc_second[,c(ff:(ff+16))] # gamma variables

ff <- which(column == "availUr")
interplot <- abc_second[,c(ff:(ff+2))] #select inter variables

## plot rmax
rmax_orig <- mariaParams$r_max

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(rmaxplot[,i], breaks = 50, col = "grey", xlim = c((min(rmaxplot[,i])- mean(rmaxplot[,i])/2), (max(rmaxplot[,i])+ (mean(rmaxplot[,i])/2))), main = colnames(rmaxplot)[i])
  abline(v = rmax_orig[i], lwd = 2, col = 'red')
  abline (v  = (rmax_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (rmax_orig[i]*2), lty =2, col = 'red')
#  abline (v  = (rmax_orig[i]*0.6), lty =2, col = 'blue')
#  abline (v  = (rmax_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (rmax_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (rmax_orig[i]*1.2), lty =2, col = 'green')
}

#plot gamma
gamma_orig <- mariaParams$gamma

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(gammaplot[,i], breaks = 50, col = "grey", xlim = c((min(gammaplot[,i])- mean(gammaplot[,i])/2), (max(gammaplot[,i])+ (mean(gammaplot[,i])/2))), main = colnames(gammaplot)[i])
  abline(v = gamma_orig[i], lwd = 2, col = 'red')
  abline (v  = (gamma_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (gamma_orig[i]*2), lty =2, col = 'red')
#  abline (v  = (gamma_orig[i]*0.6), lty =2, col = 'blue')
#  abline (v  = (gamma_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (gamma_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (gamma_orig[i]*1.2), lty =2, col = 'green')
}

#inter plot 
inter_orig <- c(0.15, 0.55, 0.4)

par(mfrow = c(1,3), mar = c(3,3,3,3))

for (i in 1:3) {
  
  hist(interplot[,i], breaks = 50, col = "grey", xlim = c((min(interplot[,i])- mean(interplot[,i])/2), (max(interplot[,i])+ (mean(interplot[,i])/2))), main = colnames(interplot)[i])
  abline(v = inter_orig[i], lwd = 2, col = 'red')
  abline (v  = (inter_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (inter_orig[i]*2), lty =2, col = 'red')
#  abline (v  = (inter_orig[i]*0.6), lty =2, col = 'blue')
#  abline (v  = (inter_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (inter_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (inter_orig[i]*1.2), lty =2, col = 'green')
}

## save the selected file with outputs and params
save(abc_second, file = "../ABCruns/acceptedSecond28ms.RData")

## save only the params
ff <- which(column == "rmax_Notolabrus")
#params194 <- abc_second[,c(ff:dim(abc_second)[2])]
#save(params194, file = "../modelParams/params194.RData")

params28 <- abc_second[,c(ff:dim(abc_second)[2])]

#add original params 
origParams <- c(params@species_params$r_max, params@species_params$gamma, inter_orig)
params28 <- rbind(origParams, params28)

save(params28, file = "../modelParams/params28ms.RData")

```

### ########
### FOOD SCENARIOS

### backgr params

```{r}
## resource params
kappa = 2  # intercept assuming g/m2
lambda = 2.15 
r_pp = 1 #rate of regeneration

kappa_ben = 6 #intercept assuming g/m2  
lambda_ben = 1.9 # 1.9 is baseline!
r_bb = 1 # something to be calibrated. Default mizer option is 10

kappa_alg = 16  #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
r_aa = 2 #something to be calibrated

### setup initial theoretical slopes
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

```


### Calibrate benthic spectrum abundance

Mizer does not have defined units and can be calibrated for m3, m2 or the total model area. I am using measures per m2, because this is how RLS data is presented. 
AbNoUr <- 0.8 - 0.9*log10(InvDataBinned$wgtGroup)

    res@rr_bb[] <- r_bb * res@w_full^(n - 1) # weight specific benthos growth rate
    res@cc_bb[] <- kappa_ben *res@w_full^(-lambda_ben) # benthos carrying capacity
    res@cc_bb[res@w_full > w_bb_cutoff] <- 0  # set density of sizes < benthic cutoff size
    res@cc_bb[res@w_full < min_w_bb] <- 0 #set density of sizes < min size of benthos ##AAdec
    res@initial_n_bb <- res@cc_bb  # put this as initial density
    
     # Dynamics of benthic spectrum uses a semi-chemostat model 
    # currently it follows exactly the same rules as plankton but has it's own parameters
        tmp <- (sim@params@rr_bb * sim@params@cc_bb / (sim@params@rr_bb + m2_benthos))
        n_bb <- tmp - (tmp - n_bb) * exp(-(sim@params@rr_bb + m2_benthos) * dt)
        n_bb[sim@params@initial_n_bb == 0] <- 0 # destroy what's below (and above) threshold sizes
 
1. The model is initialised using background spectra from equilibrium conditions; using theoretically expected initial abundance of background spectra leads the same results as the simulations converge on the same solution within about 50 years. So the model outptus are not sensitive to the initial background spectra abudnaces. This is because at each time step background regenerates towards the theoretical expectation set by the kappa and lambda parameters. The regeneration rate is set by r_bb and can vary from 1 used in this model to 10 used in xx models. When regeneration rate is close to 10, after mortality of 1/year the background regenerates to theoerical slope almost within one time step, for slower regeneration rate this can take a few time steps. However, if backgrund mortality at each time step is high and regeneration rate is lower, the spectrum of the background resource might deviate substantially from a theoretically expected linear slope set by kappa and lambda.  

2. By changing the lambda parameter of the background spectrum we are changing its carrying capacity, which together with the regeneration rate will affect the spectrum dynamics 

3. Background mortality rates in the model are quite high because a lot of species feed on the background. In the equilibrium model benthos mortality ranges from 1 to 6 in the largest sizes, and plankton mortality goes all the way to 2 for the largest sizes (it is 0.75 at size of 0.007g, which is still quite high)

4. We know that the benthos abundance is decreasing and Kate's work shows that slopes are getting steeper with temperature. So let's compare just two scenarios - baseline and decreased kappa (from 6 to 4) combined with steeper lambda (from 1.9 to 2.1)

### Explore spectra dynamics

How would small changes in kappa and lambda affect the spectrum. 

```{r, eval = F}
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

w_full <- params@w_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
dw_full <- params@dw_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
n_bb <- stable_ben[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
n_bb_C <- n_bb*dw_full
init_nbb <- params@initial_n_bb[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
init_nbb_C <- init_nbb*dw_full

n <- 0.75
m2_benthos <- ben_mort
dt.t = 0.2

r_bb <- 1 #baseline is 1
r_bb21 <- 1
lambda_ben <- 1.9
lambda_ben21 <- 2.1
kappa_ben <- 6
kappa_ben21 <- 4

rr_bb <- r_bb * w_full^(n - 1) # weight specific benthos growth rate
rr_bb21 <- r_bb21 * w_full^(n - 1) 

cc_bb <- kappa_ben *w_full^(-lambda_ben) # benthos carrying capacity: this sets initial abundance 
cc_bb21 <- kappa_ben21 *w_full^(-lambda_ben21) # benthos carrying capacity

# Dynamics of benthic spectrum uses a semi-chemostat model 
tmp <- (rr_bb * cc_bb / (rr_bb + m2_benthos))
tmp21 <- (rr_bb21 * cc_bb21 / (rr_bb21 + m2_benthos))

n_bb_next <- tmp - (tmp - n_bb) * exp(-(rr_bb + m2_benthos) * dt.t)
n_bb_next21 <- tmp21 - (tmp21 - n_bb) * exp(-(rr_bb21 + m2_benthos) * dt.t)

n_bb_next_C <- n_bb_next*dw_full
n_bb_next21_C <- n_bb_next21*dw_full

plot(log(w_full), log(n_bb_C), type = "l", col = "orange", lwd = 1.5, main = "Benthos spectrum", xlab = "log weigth(g)", ylab = "log abundance per m2")
points(log(w_full), log(init_nbb_C), type = 'l', col = 'black', lwd = 1.5)
points(log(w_full), log(n_bb_next_C), type = 'l', col = 'blue', lwd = 1.5)
points(log(w_full), log(n_bb_next21_C), type = 'l', col = 'red', lwd = 1.5)
abline(v=0, lty=2)


```


```{r, eval = F}
#inferred observed abundance (on log10 scale from Kate's and Freddie's data)
#Data using the estimated regression slope
obsab <- -0.3 - 0.9*log10(params@w_full) ## expected abundance using the equation applied to the weight groups used in mizer

#length(params@dw_full[c(min(which(params@w_full > min_w_bb)):max(which(params@w_full < w_bb_cutoff)))])
modbb_base <- log10(params@initial_n_bb * params@dw_full) 
modbb_21 <- log10(params@initial_n_bb * params@dw_full) 
modbb_23 <- log10(params@initial_n_bb * params@dw_full) 

plot(log10(params@w_full), obsab, type = 'l', lwd = 1.5, xlim = c(-6,2), ylim = c(-3, 5), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w_full), modbb_base, type = 'l', col = 'red', lwd = 1.5)
points(log10(params@w_full), modbb_21, type = 'l', col = 'blue', lwd = 1.5)
points(log10(params@w_full), modbb_23, type = 'l', col = 'purple', lwd = 1.5)
points(log10(params@w_full), modbbend, type = 'l', col = 'red', lwd = 2)

abline(v=0)



modpl <- log10(params@initial_n_pp * params@dw_full)
modaa <- log10(params@initial_n_aa * params@dw_full)

modbbend <- log10(tasm1@n_bb[tmax,] * params@dw_full) 
modppend <- log10(tasm1@n_pp[tmax,] * params@dw_full)
modaaend <- log10(tasm1@n_aa[tmax,] * params@dw_full)


plot(log10(params@w_full), obsab, type = 'l', lwd = 1.5, xlim = c(-6,2), ylim = c(-3, 5), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w_full), modbb, type = 'l', col = 'red')
points(log10(params@w_full), modbbend, type = 'l', col = 'red', lwd = 2)
points(log10(params@w_full),modpl, type = 'l', col = 'darkgreen')
points(log10(params@w_full),modppend, type = 'l', col = 'green', lwd = 2)
points(log10(params@w_full),modaa, type = 'l', col = 'blue')
points(log10(params@w_full),modaaend, type = 'l', col = 'blue', lwd = 2)

#abline(v = log10(0.05), lty = 2)
abline(v = log10(min_w_bb), lty =2)


##


noto_ini <- log10(params@initial_n[1,]*params@dw)
noto_upd <- log10(stable_abund[1,]*params@dw)

plot(log10(params@w), noto_ini, type = 'l', lwd = 1.5, ylim = c(-8, -2), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w), noto_upd, type = 'l', col = 'red')




for (i in 1: length(params@species_params$species)) {
  points(log10(model@params@w), log10(model@n[tplot,i,]*params@dw), type = 'l')
  
}


```

### Kappa, lambda, r_ scenarios

Before each change in explored parameters reload baseline background data

```{r}
## resource params
kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
lambda = 2.15 #2.1 # 
r_pp = 1 #2 # rate of regeneration

kappa_ben = 6 #2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10

kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
r_aa = 2 #1 #something to be calibrated

## in 6 productivity scnearios benthos and plankton kappa and lambda change

prod_scen<-list( 
  "baseline"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "more_plankt"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_plankt"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_plankt"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9), 
  "more_benth"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_benth"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_benth"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0)) 



#weight at 5 cm - we will calculate mean weight of all fish above 5 cm length to compare with observed trends  
mariaParams$cm2 <- mariaParams$a * 5 ^mariaParams$b 

```

### Run in a list - in progress

```{r}

## load params
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)
  

## define senescence moratlity
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
  
  

modelRunFun <- function(prod_scen, 
                        sppParams,
                        params, 
                        stable_abund, 
                        stable_alg, 
                        stable_ben, 
                        stable_pl,
                        accepted1, 
                        dietstep = 2) 
  
  {
  
## fixed resource params
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001

    
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
    inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)
  
  
  
}




  
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all <- array(data=NA, c(17, dim(params28)[1]))
plankt_all <- array(data=NA, c(326, dim(params28)[1]))
bent_all <- array(data=NA, c(120, dim(params28)[1]))
alg_all <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:dim(params28)[1]) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
    inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)

  ####
  #baseline <- tasm1
  #saveRDS(baseline, file = "../examRuns/baseline.rds")
  ####
  
  #plot(tasm1)
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

for (xx in 1:length(mariaParams$species)) {
  PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
  MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
}
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[,iter] <- apply(ttemp, 2, mean)
  numb_all[,,iter] <- numbers
  biom_all[,iter] <- biomass
  PropLarFish_all[,iter] <- PropLarFish
  MeanWgtMat_all[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all[,iter] <- MeanWgtHalfMat
  
  }

save(numb_all, file = "../altRuns28/numbBase.RData")
save(biom_all, file = "../altRuns28/biomBase.RData")
save(plankt_all, file = "../altRuns28/planktBase.RData")
save(bent_all, file = "../altRuns28/bentBase.RData")
save(alg_all, file = "../altRuns28/algBase.RData")
save(PropLarFish_all, file = "../altRuns28/PropLargFishBase.RData")
save(MeanWgtMat_all, file = "../altRuns28/MeanWgtMatBase.RData")
save(MeanWgtHalfMat_all, file = "../altRuns28/MeanWgtHalfMatBase.RData")

```

### food web stats function

```{r}

getFoodWebStats<-function(model, diet_steps=10, link_strength=0.01, backgroundTL=0){
  
  #average n over the same time period diet was averaged 
  n_ave<- apply(model@n[tail(1:dim(model@n)[1],diet_steps),,], c(2,3), FUN="mean")
  
  # Get predator biomass 
  b_ave<-sweep(n_ave, 2, model@params@w *model@params@dw, "*")
  predbio<-reshape2::melt(b_ave)
  
  # Sum up prey consumed by prey species and prey size for each predator species and size class 
  diet_comp<-model@diet_comp
  
  dimnames(diet_comp)$pred_size<- floor(log10(as.numeric(dimnames(diet_comp)$pred_size)))+.5
  dimnames(diet_comp)$prey_size<- floor(log10(as.numeric(dimnames(diet_comp)$prey_size)))+.5
  
  diet_df<-reshape2::melt(diet_comp)
  
  # Sum up prey consumed in each predator size class / prey size class 
  dietmat<-reshape2::dcast(diet_df, predator + pred_size ~ prey + prey_size, value.var="value", sum) 
  dietmat_PreyPred<-reshape2::dcast(diet_df, prey + prey_size ~predator + pred_size , value.var="value", sum) 
  
  #Take out rows and columns with zero entries.
  dietmat<- dietmat[rowSums(dietmat[,3:dim(dietmat)[2]])!=0, ]
  idx<-colSums(dietmat[,3:dim(dietmat)[2]])!=0
  dietmat<- dietmat[,c(TRUE, TRUE, idx)]
  
  dietmat_PreyPred<- dietmat_PreyPred[rowSums(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]])!=0, ]
  idx<-colSums(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]])!=0
  dietmat_PreyPred<- dietmat_PreyPred[,c(TRUE, TRUE, idx)]
  
  #Restandardize diets
  dietmat_prop<-dietmat
  dietmat_prop[,3:dim(dietmat)[2]]<-sweep( dietmat_prop[,3:dim(dietmat_prop)[2]], 1, rowSums(dietmat_prop[,3:dim(dietmat_prop)[2]]), "/")
  
  #Food web metrics  
  totLinks <- sum(dietmat_prop[,3:dim(dietmat_prop)[2]]>link_strength) 
  Connectance <- totLinks / ( dim(dietmat_prop[,3:dim(dietmat_prop)[2]])[1] * dim(dietmat_prop[,3:dim(dietmat_prop)[2]])[2])
  AveLinks <- totLinks /  dim(dietmat_prop[,3:dim(dietmat_prop)[2]])[1] 
  
  #Predator metrics: 
  datPredSize<-data.frame(predator=dietmat$predator, pred_size=dietmat$pred_size) 
  
  #Predator metrics:
  datPredSize$generality <- rowSums(sweep(dietmat_prop[,3:dim(dietmat_prop)[2]], 1, apply(dietmat_prop[,3:dim(dietmat_prop)[2]],1,FUN="max"),"/"))
  datPredSize$shannon <- diversity(dietmat_prop[,3:dim(dietmat_prop)[2]])
  datPredSize$evenness <-  diversity(dietmat_prop[,3:dim(dietmat_prop)[2]])/log(specnumber(dietmat_prop[,3:dim(dietmat_prop)[2]])) #https://cran.r-project.org/web/packages/vegan/vignettes/diversity-vegan.pdf
  
  # Cannibalism? Aggregate prey sizes according to prey species 
  
  t_dietmat<-t(dietmat_prop)
  t_dietmat<- as.matrix(t_dietmat[-c(1:2),])
  t_dietmat<- matrix(as.numeric(as.character(t_dietmat)), nrow=dim(t_dietmat)[1], ncol=dim(t_dietmat)[2])
  dimnames(t_dietmat)<- list(prey=dietmat_PreyPred$prey, predator=dietmat$predator)
  t_dietmat<- aggregate(t_dietmat, by=list(dietmat_PreyPred$prey), FUN="sum")
  rownames(t_dietmat)<-t_dietmat[,1]
  t_dietmat<-t_dietmat[,-1]
  diet_matsp<-t(t_dietmat)
  
  datPredSize$cannibalism<- 0
  ma<-match( dietmat$predator, colnames(diet_matsp))
  for(i in 1:length(ma)){
    datPredSize$cannibalism[i]<- diet_matsp[i,ma[i]]
  }
  
  #Prey vulnerability 
  
  datPreySize<-data.frame(prey=dietmat_PreyPred$prey, prey_size=dietmat_PreyPred$prey_size) 
  
  #sweep(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]], 1, apply(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]],1,FUN="max"),"/")
  datPreySize$vulnerability<- rowSums(sweep(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]], 1, apply(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]],1,FUN="max"),"/"))
  
  ###PPMR #
  
  # Sum prey eaten within prey size classes
  diet_compSum<- apply(model@diet_comp, c(1,2,4), sum)
  
  # Calculate PPMR 
  ppmr_df<-reshape2::melt(diet_compSum)
  ppmr_df$ppmr<- ppmr_df$pred_size/ppmr_df$prey_size
  ppmr_df$pred_size<- floor(log10(as.numeric(ppmr_df$pred_size)))+.5
  
  # Sum up diet proporation across prey species within prey size class 
  ppmr_DT <- data.table(ppmr_df)
  ppmr_DT <- ppmr_DT[,list(ppmr_ave = weighted.mean(ppmr, value)), by=.(predator , pred_size)]
  
  #Add PPMR into Predator food web metics   
  ppmr_df<-as.data.frame(ppmr_DT)
  ma<-match(paste(datPredSize$predator, datPredSize$pred_size), paste(ppmr_df$predator, ppmr_df$pred_size))
  datPredSize$ppmr<- ppmr_df$ppmr_ave[ma]
  
  #### Calculate trophic level #
  
  #Pull out diet composition, put into proportional contribution witin a predator species and predator size class
  tlsum<-model@diet_comp[1,1,,]
  tlsum<-drop(tlsum)
  names(dimnames(tlsum))<-c("predator","pred_size")
  
  ##DoesNotWork####
  predator<- dimnames(model@diet_comp)$predator
  prey<-dimnames(model@diet_comp)$prey
  pred_size<- dimnames(model@diet_comp)$pred_size
  prey_size<- dimnames(model@diet_comp)$prey_size
  
  tlsum[]<-0
  
  #Load in specific backgroundTL if supplied 
  tlsum[dimnames(tlsum)$predator=="background", ] <- backgroundTL
  
  for(i in 1:length(pred_size)){      # Predator size 
    for (j in 1:length(predator)){  # Predator species
      
      tl<- 1 + weighted.mean(tlsum,  model@diet_comp[dimnames(model@diet_comp)$predator==predator[j], dimnames(model@diet_comp)$pred_size==pred_size[i], ,] ) 
      tlsum[dimnames(tlsum)$predator==predator[j], dimnames(tlsum)$pred_size==pred_size[i]]<-tl
    }
  }
  
  # Melt the arrays to make data frame with species, wt, biomass, num, tl 
  tldat<-reshape2::melt(tlsum)
  tldat<-na.omit(tldat)
  
  b_ave<-sweep(n_ave, 2, model@params@w *model@params@dw, "*")
  predbio<-reshape2::melt(b_ave)
  
  
  ma<-match(paste(tldat$predator, signif(tldat$pred_size,3)), paste(predbio$sp, signif(predbio$w,3)))
  
  tldat$predbio<- predbio$value[ma]
  tldat$pred_size<- floor(log10(as.numeric(tldat$pred_size)))+.5
  
  DFtl<- data.table(tldat)
  tldatave<-DFtl[,list(tl_ave = weighted.mean(value, predbio, na.rm = TRUE)),by=.(predator , pred_size)]
  
  # Add to predator food web metrics 
  ma<-match( paste(datPredSize$predator, datPredSize$pred_size), paste(tldatave$predator, tldatave$pred_size))
  datPredSize$relTL <- tldatave$tl_ave[ma]
  
  #Organize and return objects  
  FWmetrics<-list(datPredSize=datPredSize,
                  datPreySize=datPreySize,
                  dietmat=dietmat,
                  dietmat_PreyPred=dietmat_PreyPred,
                  predbio=predbio)
  
  return(FWmetrics)
  
}

```


### Baseline runs - v2

Get uncertainty around baseline runs

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)

#weight at 5 cm - we will calculate mean weight of all fish above 5 cm length to compare with observed trends  
mariaParams$cm2 <- mariaParams$a * 5 ^mariaParams$b 


  prod_scen<-list( 
  "baseline"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "more_plankt"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_plankt"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_plankt"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9), 
  "more_benth"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_benth"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_benth"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0)) 
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
     
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2
#calcualte diet?
diet_steps = 2

## fixed background params
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001

  
#setup arrays to store results 
numb_all <-array(data=NA,c(7,17,200,dim(params28)[1]))
biom_all <- array(data=NA, c(7,17, dim(params28)[1]))
plankt_all <- array(data=NA, c(7,326, dim(params28)[1]))
bent_all <- array(data=NA, c(7,120, dim(params28)[1]))
alg_all <- array(data=NA, c(7,153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(7,17, dim(params28)[1]))
MeanWgtMat_all <- array(data= NA, c(7,17, dim(params28)[1]))
MeanWgtHalfMat_all <- array(data= NA, c(7,17, dim(params28)[1]))
CommunitySlope_all <- array(data= NA, c(7,3, dim(params28)[1]))
   
foodWebStats <- list()
#dietCompList <- list()

## loop through 7 scenarios
  
for (scen in 1:7) {
  
  print("scenario = ")
  print (scen)

## resource params
  kappa = as.numeric(prod_scen[[scen]][1])
  kappa_ben = as.numeric(prod_scen[[scen]][2])  
  lambda = as.numeric(prod_scen[[scen]][3])
  lambda_ben = as.numeric(prod_scen[[scen]][4])

    for (iter in 1:dim(params28)[1]) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- mizerRewire::project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = diet_steps)

  ### Calculate various statistics inside the run to avoid saving massive 
  
  #plot(tasm1)
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((mizerRewire::getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

      for (xx in 1:length(mariaParams$species)) {
        PropLarFish[xx] <- mean(mizerRewire::getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
        MeanWgtMat[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        MeanWgtHalfMat[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
      }
  
  
  #get mean values of various statistics over the last 30 years and save them in arrays 
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[scen,,iter] <- apply(ttemp, 2, mean)
  numb_all[scen,,,iter] <- numbers
  biom_all[scen,,iter] <- biomass
  PropLarFish_all[scen,,iter] <- PropLarFish
  MeanWgtMat_all[scen,,iter] <- MeanWgtMat
  MeanWgtHalfMat_all[scen,,iter] <- MeanWgtHalfMat
  CommunitySlope_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1)[c((tmax-29):tmax),]),2,mean))
  
  food.t <- getFoodWebStats(tasm1, diet_steps = diet_steps)
  
  foodWebStats <- c(foodWebStats, food.t)
  #dietCompList <- c(dietCompList, tasm1@diet_comp)
  
  }

}
  
save(numb_all, file = "../altRuns28/numb.RData")
save(biom_all, file = "../altRuns28/biom.RData")
save(plankt_all, file = "../altRuns28/plankt.RData")
save(bent_all, file = "../altRuns28/bent.RData")
save(alg_all, file = "../altRuns28/alg.RData")
save(PropLarFish_all, file = "../altRuns28/PropLargFish.RData")
save(MeanWgtMat_all, file = "../altRuns28/MeanWgtMat.RData")
save(MeanWgtHalfMat_all, file = "../altRuns28/MeanWgtHalfMat.RData")
save(CommunitySlope_all, file = "../altRuns28/CommunitySlope.RData")
saveRDS(foodWebStats, file = "../altRuns28/foodwebstats.rds")

```


### Baseline runs 

Get uncertainty around baseline runs

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all <- array(data=NA, c(17, dim(params28)[1]))
plankt_all <- array(data=NA, c(326, dim(params28)[1]))
bent_all <- array(data=NA, c(120, dim(params28)[1]))
alg_all <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:dim(params28)[1]) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
    inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)

  ####
  #baseline <- tasm1
  #saveRDS(baseline, file = "../examRuns/baseline.rds")
  ####
  
  #plot(tasm1)
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

for (xx in 1:length(mariaParams$species)) {
  PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
  MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
}
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[,iter] <- apply(ttemp, 2, mean)
  numb_all[,,iter] <- numbers
  biom_all[,iter] <- biomass
  PropLarFish_all[,iter] <- PropLarFish
  MeanWgtMat_all[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all[,iter] <- MeanWgtHalfMat
  
  }

save(numb_all, file = "../altRuns28/numbBase.RData")
save(biom_all, file = "../altRuns28/biomBase.RData")
save(plankt_all, file = "../altRuns28/planktBase.RData")
save(bent_all, file = "../altRuns28/bentBase.RData")
save(alg_all, file = "../altRuns28/algBase.RData")
save(PropLarFish_all, file = "../altRuns28/PropLargFishBase.RData")
save(MeanWgtMat_all, file = "../altRuns28/MeanWgtMatBase.RData")
save(MeanWgtHalfMat_all, file = "../altRuns28/MeanWgtHalfMatBase.RData")

```



### Sc1: incr benthos kappa  50%

kappa_ben = 3, lambda_ben = 2.2
kappa_ben = 9 (not 6), lambda = 1.9 (1.9)

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
    accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 9 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc1 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc1 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc1 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc1 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc1 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc1 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc1 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc1 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #more_bent <- tasm1
  #saveRDS(more_bent, file = "../examRuns/more_bent.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
          MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
  }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc1[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc1[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc1[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc1[,,iter] <- numbers
  biom_all_sc1[,iter] <- biomass
  PropLarFish_all_sc1[,iter] <- PropLarFish
  MeanWgtMat_all_sc1[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc1[,iter] <- MeanWgtHalfMat
  
}

#save(numb_all_sc1, file = "../altRuns28/numbS1.RData")
#save(biom_all_sc1, file = "../altRuns28/biomS1.RData")
#save(plankt_all_sc1, file = "../altRuns28/planktS1.RData")
#save(bent_all_sc1, file = "../altRuns28/bentS1.RData")
#save(alg_all_sc1, file = "../altRuns28/algS1.RData")
#save(PropLarFish_all_sc1, file = "../altRuns28/PropLargFishS1.RData")
#save(MeanWgtMat_all_sc1, file = "../altRuns28/MeanWgtMatS1.RData")
#save(MeanWgtHalfMat_all_sc1, file = "../altRuns28/MeanWgtHalfMatS1.RData")

```

### Sc2: decr benthos kappa 50%

kappa_ben = 4 (not 6), lambda_ben = 1.9

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 4 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc2 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc2 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc2 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc2 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc2 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc2 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc2 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc2 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #less_bent <- tasm1
  #saveRDS(less_bent, file = "../examRuns/less_bent.rds")
  ###
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
    PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
          MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc2[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc2[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc2[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc2[,,iter] <- numbers
  biom_all_sc2[,iter] <- biomass
    PropLarFish_all_sc2[,iter] <- PropLarFish
  MeanWgtMat_all_sc2[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc2[,iter] <- MeanWgtHalfMat

  
}

save(numb_all_sc2, file = "../altRuns28/numbS2.RData")
save(biom_all_sc2, file = "../altRuns28/biomS2.RData")
save(plankt_all_sc2, file = "../altRuns28/planktS2.RData")
save(bent_all_sc2, file = "../altRuns28/bentS2.RData")
save(alg_all_sc2, file = "../altRuns28/algS2.RData")
save(PropLarFish_all_sc2, file = "../altRuns28/PropLargFishS2.RData")
save(MeanWgtMat_all_sc2, file = "../altRuns28/MeanWgtMatS2.RData")
save(MeanWgtHalfMat_all_sc2, file = "../altRuns28/MeanWgtHalfMatS2.RData")

```

### Sc3: incr plankton kappa 50%

kappa = 2.6, lambda = 2.15

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2.6#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc3 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc3 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc3 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc3 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc3 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc3 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc3 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc3 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #more_plank <- tasm1
  #saveRDS(more_plank, file = "../examRuns/more_plank.rds")
  ###
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
      PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
                  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc3[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc3[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc3[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc3[,,iter] <- numbers
  biom_all_sc3[,iter] <- biomass
      PropLarFish_all_sc3[,iter] <- PropLarFish
  MeanWgtMat_all_sc3[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc3[,iter] <- MeanWgtHalfMat
  
}

save(numb_all_sc3, file = "../altRuns28/numbS3.RData")
save(biom_all_sc3, file = "../altRuns28/biomS3.RData")
save(plankt_all_sc3, file = "../altRuns28/planktS3.RData")
save(bent_all_sc3, file = "../altRuns28/bentS3.RData")
save(alg_all_sc3, file = "../altRuns28/algS3.RData")
save(PropLarFish_all_sc3, file = "../altRuns28/PropLargFishS3.RData")
save(MeanWgtMat_all_sc3, file = "../altRuns28/MeanWgtMatS3.RData")
save(MeanWgtHalfMat_all_sc3, file = "../altRuns28/MeanWgtHalfMatS3.RData")

```

### Sc4: decr plankton kappa 25%

kappa = 1.5, lambda = 2.15

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 1.5#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc4 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc4 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc4 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc4 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc4 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc4 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc4 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc4 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #less_plank <- tasm1
  #saveRDS(less_plank, file = "../examRuns/less_plank.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
      PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc4[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc4[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc4[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc4[,,iter] <- numbers
  biom_all_sc4[,iter] <- biomass
      PropLarFish_all_sc4[,iter] <- PropLarFish
  MeanWgtMat_all_sc4[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc4[,iter] <- MeanWgtHalfMat
  
}

save(numb_all_sc4, file = "../altRuns28/numbS4.RData")
save(biom_all_sc4, file = "../altRuns28/biomS4.RData")
save(plankt_all_sc4, file = "../altRuns28/planktS4.RData")
save(bent_all_sc4, file = "../altRuns28/bentS4.RData")
save(alg_all_sc4, file = "../altRuns28/algS4.RData")
save(PropLarFish_all_sc4, file = "../altRuns28/PropLargFishS4.RData")
save(MeanWgtMat_all_sc4, file = "../altRuns28/MeanWgtMatS4.RData")
save(MeanWgtHalfMat_all_sc4, file = "../altRuns28/MeanWgtHalfMatS4.RData")

```

### Sc5: steeper plankton lambda

kappa = 2, lambda = 2.18

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2.5#2 intercept assuming g/m2
  lambda = 2.18 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc5 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc5 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc5 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc5 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc5 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc5 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc5 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc5 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #small_plank <- tasm1
  #saveRDS(small_plank, file = "../examRuns/small_plank.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
      PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
                  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc5[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc5[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc5[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc5[,,iter] <- numbers
  biom_all_sc5[,iter] <- biomass
      PropLarFish_all_sc5[,iter] <- PropLarFish
  MeanWgtMat_all_sc5[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc5[,iter] <- MeanWgtHalfMat
}

save(numb_all_sc5, file = "../altRuns28/numbS5.RData")
save(biom_all_sc5, file = "../altRuns28/biomS5.RData")
save(plankt_all_sc5, file = "../altRuns28/planktS5.RData")
save(bent_all_sc5, file = "../altRuns28/bentS5.RData")
save(alg_all_sc5, file = "../altRuns28/algS5.RData")
save(PropLarFish_all_sc5, file = "../altRuns28/PropLargFishS5.RData")
save(MeanWgtMat_all_sc5, file = "../altRuns28/MeanWgtMatS5.RData")
save(MeanWgtHalfMat_all_sc5, file = "../altRuns28/MeanWgtHalfMatS5.RData")

```

### Sc6: steeper benthos lambda 

kappa = 6, lambda = 2.0

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 2.0 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc6 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc6 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc6 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc6 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc6 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc6 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc6 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc6 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #small_bent <- tasm1
  #saveRDS(small_bent, file = "../examRuns/small_bent.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
         MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc6[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc6[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc6[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc6[,,iter] <- numbers
  biom_all_sc6[,iter] <- biomass
      PropLarFish_all_sc6[,iter] <- PropLarFish
  MeanWgtMat_all_sc6[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc6[,iter] <- MeanWgtHalfMat
  
}

save(numb_all_sc6, file = "../altRuns28/numbS6.RData")
save(biom_all_sc6, file = "../altRuns28/biomS6.RData")
save(plankt_all_sc6, file = "../altRuns28/planktS6.RData")
save(bent_all_sc6, file = "../altRuns28/bentS6.RData")
save(alg_all_sc6, file = "../altRuns28/algS6.RData")
save(PropLarFish_all_sc6, file = "../altRuns28/PropLargFishS6.RData")
save(MeanWgtMat_all_sc6, file = "../altRuns28/MeanWgtMatS6.RData")
save(MeanWgtHalfMat_all_sc6, file = "../altRuns28/MeanWgtHalfMatS6.RData")

```


### ####################
### OUTPUT PLOTS 

what kind of outputs to show 
1. Relative changes in biomasses 
2. Total fish community biomass? 
3. Relative changes in size-at-age 
4. Relative changes in mean size (above 2 cm in length)
5. Entire community size spectrum 
6. Emergent ppmr at species and community level?
7. Production to biomass ratio
8. Stability with alpha max? 

### Food web stats

```{r}
#Make sure you give the right path and load extra required packages
library(data.table)
source("FoodWebStats.R")

plotDietComp(tasm1) #plot proportion of prey in diets - this is a function Jon wrote 
plotPPMR(tasm1) #plot realised PPMR - this is also a function Jon wrote and they are now all incorporated into rewire-temp

## Now we can get all sorts of other food web statistics, using a code that Jon wrote. 
#the code is not a part of mizer rewiring, so we source it separately 

foodwebstats <- getFoodWebStats(tasm1, diet_steps = 2)
```

### Total biomass plot

```{r}

par(mfrow = c(1,1))
#how much variation among plausible parameters?
biom_mean_base <- apply(biom_all, 1, mean)
biom_min_base <- apply(biom_all, 1, min)
biom_max_base <- apply(biom_all, 1, max)

x = c(1:17)
plot(x, biom_mean_base, pch=19, ylim = c(0,4), xlab = "Species", ylab = "Biomass, g/m2")
arrows(x, biom_min_base, x, biom_max_base, length = 0.05, angle = 90, code = 3)

#points(biom_min_base, pch=19, col = 'red')
#points(biom_max_base, pch=19, col = 'red')
```

#Relative biomass plot

```{r}

#plot(x, avg,
#    ylim=range(c(avg-sdev, avg+sdev)),
#    pch=19, xlab="Measurements", ylab="Mean +/- SD",
#    main="Scatter plot with std.dev error bars"
#)
# hack: we draw arrows but with very special "arrowheads"
#arrows(x, avg-sdev, x, avg+sdev, length=0.05, angle=90, code=3)
#n the arrows(...) function length=0.05 is the size of the "arrowhead" in inches, angle=90 specifies that the "arrowhead" is perpendicular to the shaft of the arrow, and the particularly intuitive code=3 parameter specifies that we want to draw an arrowhead on both ends of the arrow.

#For horizontal error bars the following changes are necessary, assuming that the sdev vector now contains the errors in the x values and the y values are the ordinates:
#
#plot(x, y,
#    xlim=range(c(x-sdev, x+sdev)),
#    pch=19,...)
# horizontal error bars
#arrows(x-sdev, y, x+sdev, y, length=0.05, angle=90, code=3

 par(mfrow = c(2,3))
#We want to compare DIFFERENCE in biomass from baseline scenario
  BiomDiffs1 <- (biom_all_sc1 - biom_all)/biom_all
  MedianBiomDiffs1 <- apply(BiomDiffs1, 1, median)
  MinBiomDiffs1 <- apply(BiomDiffs1, 1, min)
  MaxBiomDiffs1 <- apply(BiomDiffs1, 1, max)
  SDBiomDiffs1 <- apply(BiomDiffs1, 1, sd)
  
plot(x, MedianBiomDiffs1, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs1, x, MaxBiomDiffs1, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs1, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs1, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#We want to compare DIFFERENCE in biomass from baseline scenario
  BiomDiffs2 <- (biom_all_sc2 - biom_all)/biom_all
  MedianBiomDiffs2 <- apply(BiomDiffs2, 1, median)
  MinBiomDiffs2 <- apply(BiomDiffs2, 1, min)
  MaxBiomDiffs2 <- apply(BiomDiffs2, 1, max)
  SDBiomDiffs2 <- apply(BiomDiffs2, 1, sd)
  
plot(x, MedianBiomDiffs2, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs2, x, MaxBiomDiffs2, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs2, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs2, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

 BiomDiffs6 <- (biom_all_sc6 - biom_all)/biom_all
  MedianBiomDiffs6 <- apply(BiomDiffs6, 1, median)
  MinBiomDiffs6 <- apply(BiomDiffs6, 1, min)
  MaxBiomDiffs6 <- apply(BiomDiffs6, 1, max)
  SDBiomDiffs6 <- apply(BiomDiffs6, 1, sd)
  
plot(x,MedianBiomDiffs6, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs6, x, MaxBiomDiffs6, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs6, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs6, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#
  BiomDiffs3 <- (biom_all_sc3 - biom_all)/biom_all
  MedianBiomDiffs3 <- apply(BiomDiffs3, 1, median)
  MinBiomDiffs3 <- apply(BiomDiffs3, 1, min)
  MaxBiomDiffs3 <- apply(BiomDiffs3, 1, max)
  SDBiomDiffs3 <- apply(BiomDiffs3, 1, sd)
  
plot(x, MedianBiomDiffs3, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs3, x, MaxBiomDiffs3, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs3, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs3, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

  BiomDiffs4 <- (biom_all_sc4 - biom_all)/biom_all
  MedianBiomDiffs4 <- apply(BiomDiffs4, 1, median)
  MinBiomDiffs4 <- apply(BiomDiffs4, 1, min)
  MaxBiomDiffs4 <- apply(BiomDiffs4, 1, max)
  SDBiomDiffs4 <- apply(BiomDiffs4, 1, sd)
  
plot(x, MedianBiomDiffs4, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs4, x, MaxBiomDiffs4, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs4, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs4, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)
abline(h=-1, lty=2)

 BiomDiffs5 <- (biom_all_sc5 - biom_all)/biom_all
  MedianBiomDiffs5 <- apply(BiomDiffs5, 1, median)
  MinBiomDiffs5 <- apply(BiomDiffs5, 1, min)
  MaxBiomDiffs5 <- apply(BiomDiffs5, 1, max)
  SDBiomDiffs5 <- apply(BiomDiffs5, 1, sd)
  
plot(MedianBiomDiffs5, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs5, x, MaxBiomDiffs5, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs5, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs5, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)


```

### Compare proportion of large fish

```{r}

 par(mfrow = c(1,1))
#how much variation among plausible parameters?
PropLarFish_mean_base <- apply(PropLarFish_all, 1, mean)
PropLarFish_min_base <- apply(PropLarFish_all, 1, min)
PropLarFish_max_base <- apply(PropLarFish_all, 1, max)

plot(PropLarFish_mean_base, pch=19, ylim = c(0,1))
points(PropLarFish_min_base, pch=19, col = 'red')
points(PropLarFish_max_base, pch=19, col = 'red')

 par(mfrow = c(3,2))
#We want to compare DIFFERENCE in PropLarFishass from baseline scenario
  PropLarFishDiffs1 <- (PropLarFish_all_sc1 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, median)
  MinPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, min)
  MaxPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, max)
  SDPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, sd)
  
plot(MedianPropLarFishDiffs1, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs1, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs1, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#We want to compare DIFFERENCE in PropLarFishass from baseline scenario
  PropLarFishDiffs2 <- (PropLarFish_all_sc2 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, median)
  MinPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, min)
  MaxPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, max)
  SDPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, sd)
  
plot(MedianPropLarFishDiffs2, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs2, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs2, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#
  PropLarFishDiffs3 <- (PropLarFish_all_sc3 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, median)
  MinPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, min)
  MaxPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, max)
  SDPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, sd)
  
plot(MedianPropLarFishDiffs3, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs3, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs3, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

  PropLarFishDiffs4 <- (PropLarFish_all_sc4 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, median)
  MinPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, min)
  MaxPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, max)
  SDPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, sd)
  
plot(MedianPropLarFishDiffs4, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs4, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs4, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)
abline(h=-1, lty=2)

 PropLarFishDiffs5 <- (PropLarFish_all_sc5 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, median)
  MinPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, min)
  MaxPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, max)
  SDPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, sd)
  
plot(MedianPropLarFishDiffs5, pch=19, ylim = c(-1,1.5))
points(MaxPropLarFishDiffs5, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs5, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

 PropLarFishDiffs6 <- (PropLarFish_all_sc6 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, median)
  MinPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, min)
  MaxPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, max)
  SDPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, sd)
  
plot(MedianPropLarFishDiffs6, pch=19, ylim = c(-1,1.5))
points(MaxPropLarFishDiffs6, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs6, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)
```




### Compare size spectra

```{r}
### 
# we only want to look at "observable" size spectra, i.e. individuals above 2cm in length. Assuming standard wl relationship this would correspond to w = 0.01*2^3 or 0.08 grams

par(mfrow = c(1,2))
#par(mfrow = c(1,1))

for (sp in 1:17) {
#sp = 1

#benthos scenarios
i = 1 #first set of params
temp <- which(params@w > params@species_params$w_inf[sp])
num.d1 <- (numb_all_sc1[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d2 <- (numb_all_sc2[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d6 <- (numb_all_sc6[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d1[temp] <- NA
num.d2[temp] <- NA
num.d6[temp] <- NA

plot(log(params@w), num.d1, type = 'l', col = 'grey', main = mariaParams$species[sp], xlab = "log size group, g", ylab = "relative number difference", ylim = c(-1, 1))
abline(v = log(params@species_params$w_mat[sp]), lty = 2)
abline(v = log(0.08))
abline(h = 0)
points(log(params@w), num.d2, type = 'l', col = 'pink')
points(log(params@w), num.d6, type = 'l', col = 'lightblue3')


for (i in 2:(dim(params28)[1])) {
num.d1 <- (numb_all_sc1[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d2 <- (numb_all_sc2[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d6 <- (numb_all_sc6[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d1[temp] <- NA
num.d2[temp] <- NA
num.d6[temp] <- NA
points(log(params@w), num.d1, type = 'l', col = 'grey')
points(log(params@w), num.d2, type = 'l', col = 'pink')
points(log(params@w), num.d6, type = 'l', col = 'lightblue3')
}


## plankton scenarios

i = 1 #first set of params
temp <- which(params@w > params@species_params$w_inf[sp])
num.d3 <- (numb_all_sc3[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d4 <- (numb_all_sc4[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d5 <- (numb_all_sc5[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d3[temp] <- NA
num.d4[temp] <- NA
num.d5[temp] <- NA

plot(log(params@w), num.d3, type = 'l', col = 'grey', main = mariaParams$species[sp], xlab = "log size group, g", ylab = "relative number difference", ylim = c(-1, 1))
abline(v = log(params@species_params$w_mat[sp]), lty = 2)
abline(v = log(0.08))
abline(h = 0)
points(log(params@w), num.d4, type = 'l', col = 'pink')
points(log(params@w), num.d5, type = 'l', col = 'lightblue3')


for (i in 2:(dim(params28)[1])) {
num.d3 <- (numb_all_sc3[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d4 <- (numb_all_sc4[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d5 <- (numb_all_sc5[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d3[temp] <- NA
num.d4[temp] <- NA
num.d5[temp] <- NA
points(log(params@w), num.d3, type = 'l', col = 'grey')
points(log(params@w), num.d4, type = 'l', col = 'pink')
points(log(params@w), num.d5, type = 'l', col = 'lightblue3')
}
}



```

1, 3, 7, 13, 16, 17

```{r}
ggplot(df_CI) +
  geom_abline(intercept = 0, slope = 0, linetype = "dashed") +
#  geom_point(data = df_fit, aes(x = x, y = y, color = color)) +
  geom_point(data = data_subset2, aes(x = x, y = y, col = "grey")) + 
  geom_errorbar(data = data_subset2, aes(x = x, ymin = p10, ymax = p90, color = "grey"), width=0) +
  geom_point(data = data_subset1, aes(x = x, y = y, color = "blue")) + 
  geom_errorbar(data = data_subset1, aes(x = x, ymin = p10, ymax = p90, color = "blue"), width=0) +
    geom_point(data = data_subset0, aes(x = x, y = y, color = "red")) + 
#  geom_errorbar(data = df_fit, aes(x = x, ymin = p10, ymax = p90, color = color), width=0) +
  geom_errorbar(data = data_subset0, aes(x = x, ymin = p10, ymax = p90, color = "red"), width=0) +
  geom_polygon(data = df_polygon, aes(x = x, y = y), fill = "#feb24c") +
  geom_line(aes(x = x, y = mu_500)) +
  labs(
    x = expression("Species thermal affinity ("~degree~"C)"),
    y = expression("Relative change in body length (per "~degree~"C)")
  ) +
  ylim(-0.25, 0.25) +   # add ylim to remove the outlier 
  #  xlim (-0.03, 0.03) +
  scale_colour_manual(values=c("#de2d26", "grey70", "#3182bd")) +
  guides(color=FALSE) +
#  geom_vline(xintercept = 23, linetype = "dashed") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(size=14),
    axis.title.y = element_text(size=14),
    axis.text=element_text(size=12)
  )
```




Actual runs 

```{r}
tmax = 150

#for benthos kappa
#kappa.v <- seq(from = (kappa_ben-2), to = (kappa_ben + 2), by = 0.5) #current kappa_ben is 6

#for benthos lambda
#kappa.v <- seq(from = (lambda_ben-0.3), to = (lambda_ben + 0.3), by = 0.05) #current lambda_ben is 1.9

#for benthos r_bb
#kappa.v <- seq(from = (r_bb-0.5), to = (r_bb + 2.5), by = 0.25) #current r_bb is 1

#for plankton kappa
#kappa.v <- seq(from = (kappa-1.5), to = (kappa + 1.5), by = 0.25) ## current kappa is 2

#for plankton lambda
#kappa.v <- seq(from = (lambda-0.3), to = (lambda + 0.3), by = 0.05) #current lambda is 2.15

#for plankton r_pp
kappa.v <- seq(from = (r_pp-0.5), to = (r_pp + 2.5), by = 0.25) #current r_pp is 1

#for algal kappa
#kappa.v <- seq(from = (kappa_alg-4), to = (kappa_alg + 4), by = 0.5) ## current kappa is 16

#for algal lambda
#kappa.v <- seq(from = (lambda_alg-0.3), to = (lambda_alg + 0.3), by = 0.05) #current lambda_alg is 1.6

relbiomKappaSens <- data.frame()

for (i in 1:length(kappa.v)) {

#update kappa for benthos
#kappa_ben = kappa.v[i]
#update lambda for benthos
#lambda_ben = kappa.v[i]  
#r_bb = kappa.v[i] 
  
#or if running for plankton update kappa 
#kappa = kappa.v[i]
#update plankton lambda
#lambda = kappa.v[i] 
r_pp = kappa.v[i] 
  
#kappa_alg <- kappa.v[i]
#lambda_alg <- kappa.v[i] 
      
### setup 
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tasm1kappa <- project(params, t_max = tmax, effort= 0, dt = dt)

plot(tasm1kappa)

## compare biomasses 
print(round(getBiomass(tasm1kappa)[tmax,]/getBiomass(tasm1)[tmax,],5))

temp <- round(getBiomass(tasm1kappa)[tmax,]/getBiomass(tasm1)[tmax,],5)
relbiomKappaSens <- rbind(relbiomKappaSens, temp)

}

colnames(relbiomKappaSens) <- params@species_params$species #biomasses of species as you fish species in rows
rownames(relbiomKappaSens) <- paste("r_pp",as.character(kappa.v), sep = "")

temp <- backgr_change

#backgr_change <- data.frame()
backgr_change <- rbind(backgr_change, relbiomKappaSens)

save(backgr_change, file = "../outputs/changeOneParamBackground.RData")
write.csv(backgr_change, file = "../outputs/changeOneParamBackground.csv")
```

### Alternative scenarios results

```{r}
load(file = "../outputs/changeOneParamBackground.RData")

pca_test <- prcomp(backgr_change)
plot(pca_test)
summary(pca_test)
biplot(pca_test)

## Look if biomass of one species (T_caudimaculatus in my case) is strongly correlated to other species
#cor_Tra <- rep(NA, 17)
#p_Tra <- rep(NA, 17)

#for (i in 1:length(params@species_params$species)) {
#onesp <- relbiomFishOne[,i]
#temp <- cor.test(relbiomFishOne$T_caudimaculatus, onesp)
#cor_Tra[i] <- temp$statistic
#p_Tra[i] <- round(temp$p.value,5)
#}
#trach_inter <- cbind(as.character(mariaParams$species), round(cor_Tra,3), round(p_Tra,4))  


```


### Time variable background

```{r}
### setup 
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
plot(tasm1)


```




### #####################
#### OTHER STUFF


### Sc1_P: gradually incr benthos kappa 50%

kappa_ben = 3, lambda_ben = 2.2
kappa_ben = 9 (not 6), lambda = 1.9 (1.9)

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
    accepted1 <- as.data.frame(params28)
  
    ## setup run time 
tmax = 60
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2
    
    
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben_S = seq(from = 6, to = 9, length.out = (tmax/2)) #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    


#setup arrays to store results 
numb_all_sc1P <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc1P <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc1P <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc1P <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc1P <- array(data=NA, c(153, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters
  
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  #run iteratively every 2 years 
  for (yy in 1:(tmax/2)) {
    #print(yy)
   kappa_ben <- kappa_ben_S[yy]
   #print(kappa_ben)
    
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
    ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = 2, effort= 0, dt = dt)
  #plot(tasm1)
  stable_abund <- tasm1@n[dim(tasm1@n)[1],,]
  stable_pl <- tasm1@n_pp[dim(tasm1@n)[1],]
  stable_ben <- tasm1@n_bb[dim(tasm1@n)[1],]
  stable_alg <- tasm1@n_aa[dim(tasm1@n)[1],]
  }
  
  #plot(tasm1)
  #need to take an average of the last 30 years because it is oscilating
  biomass <- getBiomass(tasm1)[dim(tasm1@n)[1],]
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- tasm1@n[dim(tasm1@n)[1],,]
  
  plankt_all_sc1P[,iter] <- tasm1@n_pp[(dim(tasm1@n)[1]),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  bent_all_sc1P[,iter] <- tasm1@n_bb[(dim(tasm1@n)[1]),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  alg_all_sc1P[,iter] <- tasm1@n_aa[(dim(tasm1@n)[1]),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  numb_all_sc1P[,,iter] <- numbers
  biom_all_sc1P[,iter] <- biomass
  
  
  
  
}

save(numb_all_sc1P, file = "../altRuns28/numbS1P.RData")
save(biom_all_sc1P, file = "../altRuns28/biomS1P.RData")
save(plankt_all_sc1P, file = "../altRuns28/planktS1P.RData")
save(bent_all_sc1P, file = "../altRuns28/bentS1P.RData")
save(alg_all_sc1P, file = "../altRuns28/algS1P.RData")

```


### Sc2_P: gradually decr benthos kappa 50%

kappa_ben = 3, lambda_ben = 2.2
kappa_ben = 4 (not 6), lambda = 1.9 (1.9)

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
    accepted1 <- as.data.frame(params28)
  
    ## setup run time 
tmax = 60
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2
    
    
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben_S = seq(from = 6, to = 4, length.out = (tmax/2)) #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    


#setup arrays to store results 
numb_all_sc2P <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc2P <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc2P <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc2P <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc2P <- array(data=NA, c(153, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters
  
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  #run iteratively every 2 years 
  for (yy in 1:(tmax/2)) {
    #print(yy)
   kappa_ben <- kappa_ben_S[yy]
   #print(kappa_ben)
    
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
    ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = 2, effort= 0, dt = dt)
  #plot(tasm1)
  stable_abund <- tasm1@n[dim(tasm1@n)[1],,]
  stable_pl <- tasm1@n_pp[dim(tasm1@n)[1],]
  stable_ben <- tasm1@n_bb[dim(tasm1@n)[1],]
  stable_alg <- tasm1@n_aa[dim(tasm1@n)[1],]
  }
  
  #plot(tasm1)
  #need to take an average of the last 30 years because it is oscilating
  biomass <- getBiomass(tasm1)[dim(tasm1@n)[1],]
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- tasm1@n[dim(tasm1@n)[1],,]
  
  plankt_all_sc2P[,iter] <- tasm1@n_pp[(dim(tasm1@n)[1]),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  bent_all_sc2P[,iter] <- tasm1@n_bb[(dim(tasm1@n)[1]),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  alg_all_sc2P[,iter] <- tasm1@n_aa[(dim(tasm1@n)[1]),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  numb_all_sc2P[,,iter] <- numbers
  biom_all_sc2P[,iter] <- biomass
  
}

save(numb_all_sc2P, file = "../altRuns28/numbS2P.RData")
save(biom_all_sc2P, file = "../altRuns28/biomS2P.RData")
save(plankt_all_sc2P, file = "../altRuns28/planktS2P.RData")
save(bent_all_sc2P, file = "../altRuns28/bentS2P.RData")
save(alg_all_sc2P, file = "../altRuns28/algS2P.RData")

```

