---
title: "SEA_bentPelModel"
author: "Asta Audzijonyte et al."
date: "7 November 2019"
output: html_document
---
### clear memory

```{r}

rm(list=ls())

```

### Load libraries

```{r warning=FALSE, message=FALSE, warning=FALSE, echo=F}
#list.files()

#devtools::install_github("james-thorson/FishLife")
list.of.packages <- c("tidyverse", "dplyr", "ggplot2", "ggmap", "vegan", "reshape2", "cowplot", "factoextra", "data.table")

new.packages<- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, require, character.only = TRUE)

```

#### ###########

### SETTING UP SPECIES ###

### Load datafiles: BIG

Get all RLS data and filter out Bassian ecoregion

```{r warning=FALSE, message=FALSE, eval=FALSE, echo = F} 

load(file="../inputs/rlsst_mar.RData") ## RLS/MPA database from 2019 March (only Australia)
glimpse(rls_st)
rls_bas <- rls_st %>% filter (Ecoregion == "Bassian")
#save(rls_bas, file = "../inputs/rlsbas_mar2019.RData")

```

### Lmax for diet species: don't run

Get maximum sizes from German's data set predicting diet for all RLS species and observations

```{r, eval = F}
diet = read.csv (file = "../inputs/dietpred.csv")
AllSpp <- unique(diet$Species)

  MaxSize <- rls_st %>%
    filter (TAXONOMIC_NAME %in% AllSpp) %>%
      group_by (TAXONOMIC_NAME, year) %>% # maximum size observed in a year in a given Location
        summarise (sizeMax = max(SizeClass)) %>% 
          group_by(TAXONOMIC_NAME) %>%
            top_n(3, sizeMax) %>% summarise (MaxSizeMed = median(sizeMax))

diet$Lmax <- MaxSize$MaxSizeMed[match(diet$Species, MaxSize$TAXONOMIC_NAME)]  
write.csv(diet, file = "../inputs/dietpred.csv" )

```

### Load datafiles: filtered

```{r warning=FALSE, message=FALSE, eval=T, echo = F} 
load(file="../inputs/rlsbas_mar2019.RData") 

#remove errors
#rls_bas  <- rls_bas[-c(which(rls_bas$TAXONOMIC_NAME == "Trachinops caudimaculatus" & rls_bas$SizeClass > 15)),]

rls_bas$dayID <- paste(rls_bas$day,rls_bas$month, rls_bas$year, rls_bas$SiteCode, rls_bas$Depth, sep = "") #unique date - site code identfier

traits <- read.csv(file = "../inputs/SpeciesTraits.csv") #collection of Tasmanian species traits by Rick
thermal <- read.csv(file = "../inputs/ThermalOptima.csv") #Ricks thermal database
FBdata <- read.csv(file = "../inputs/FBlifehistory.csv")
diet = read.csv (file = "../inputs/dietpred.csv")
ComNames = read.csv(file = "../inputs/SpeciesCommonNames.csv")
Lmax = read.csv(file = "../inputs/CorrectLmax.csv")
lw <- read.csv(file = "../inputs/SpeciesLW.csv")

```

### Tasmanian samples: select species 

```{r warning=FALSE, message=FALSE, eval=T, echo = F} 
ComNames <- ComNames[,c(1:2)]

## This is a list of locations in 5 long term monitored areas 

MariaLocs = c("Maria Island Reserve", "Maria Island Vincinity", "Maria External")
TinderLocs = c("Tinderbox External", "Tinderbox Reserve")
NineLocs = c("Ninepin Internal", "Ninepin External")
PortPhilLocs = c("Port Phillip Bay", "Port Phillip Heads")
BichLocs = c("Bicheno Internal", "Bicheno External")

#Set this to the wanted area
LocationsWanted = c(MariaLocs, TinderLocs, NineLocs, BichLocs)

## cutoff for the year periods
#yearEarly = 2000 ## 1990s
#yearMid = 2010 ## 2000s

## Get only the data for longterm locations, method 1 and for the 1990s
#fish.early.LT.M1 <- rls_bas %>% filter (Location %in% LocationsWanted) %>% filter (year < 2000) %>% filter (Method == 1)
## Or try all surveys from E, W and S coast of Tamania (N coast has different spp) and 1990s
fish.early.LT.M1 <- rls_bas %>% filter (SiteLat < -40.8) %>% filter (year < 2000) %>% filter (Method == 1)
## Or use all years
#fish.early.LT.M1 <- rls_bas %>% filter (SiteLat < -40.8) %>% filter (Method == 1)

#how many surveys are there? 
survno <- length(unique(fish.early.LT.M1$SurveyID)) #1965

# Select only species that occur in more than x% of surveys with a given biomass and abudance 
BasianCommonFish <- fish.early.LT.M1 %>%
  filter (GENUS != "NA") %>% #Ignore species for which only family name is known
    group_by (TAXONOMIC_NAME, SurveyID) %>% ## group by species and survey to summarise species/survey data
       summarise (abundSur = sum(Abundance), biomSur = sum(BioMass, na.rm=TRUE)) %>% #add all observations per survey to get abundance and biomass per survey
      group_by (TAXONOMIC_NAME) %>%
        summarise(freq_surv = n_distinct(SurveyID)/survno, abun_surv = sum(abundSur)/survno, bio_surv = sum(biomSur)/survno) %>%
  filter (freq_surv > 0.025) %>% #the cutoff of 2.5% reduces the list of spp from 103 to 32
            filter (bio_surv > 25) %>% arrange (desc(bio_surv))

BasianCommonFish$commonName <- ComNames$COMMON_NAME[match(BasianCommonFish$TAXONOMIC_NAME,ComNames$TAXONOMIC_NAME)]
BasianCommonFish$Lmax <- Lmax$LmaxCorrect[match(BasianCommonFish$TAXONOMIC_NAME,Lmax$TAXONOMIC_NAME)]

knitr::kable(BasianCommonFish, digits = 2)

#excluded rarer species 

excspp <- c("Girella zebra","Cheilodactylus nigripes", "Urolophus cruciatus","Pseudolabrus mortonii","Diodon nicthemerus" ,"Neoodax balteatus", "Caesioperca lepidoptera")

#Model species
ModelSpecies <- BasianCommonFish %>% filter((!TAXONOMIC_NAME %in% excspp))

#save(ModelSpecies, file = "../inputs/ModelSpeciesSummary.RData")

```

### How much biomass & abund model fish make up?

```{r warning=FALSE, message=FALSE, eval=T, echo = F}
#load(file="../inputs/rlsbas_mar2019.RData") 
#load(file = "../inputs/ModelSpeciesSummary.RData")

#Mean survey abundance and biomass of fish and sharks 
SurvBioAb <- rls_bas %>% 
  filter (SiteLat < -40.8) %>%
  filter (CLASS == "Actinopterygii" | CLASS == "Elasmobranchii") %>% 
  filter (Method == "1") %>% 
  group_by (SurveyID) %>% 
  summarise (bio = sum(BioMass, na.rm = T), abun = sum(Abundance), year = first(year))

SurvBioAb16 <- rls_bas %>% 
  filter (SiteLat < -40.8) %>%
  filter (TAXONOMIC_NAME %in% ModelSpecies$TAXONOMIC_NAME) %>% 
  filter (Method == "1") %>% 
  group_by (SurveyID) %>% 
  summarise (bio16 = sum(BioMass, na.rm = T), abun16 = sum(Abundance))

#combine mean abundacne a
SurvTotal <- full_join(SurvBioAb, SurvBioAb16, by = "SurveyID")

#If none of the species were present the biomas and abund will be shown as NA. I need to replace them as 0
 SurvTotal$bio16[which(is.na(SurvTotal$bio16) == TRUE)] <- 0
 SurvTotal$abun16[which(is.na(SurvTotal$abun16) == TRUE)] <- 0
 
# Now get the proportion of biomass and abundane that the 16 species make up
SurvTotal$bioRatio = SurvTotal$bio16 / SurvTotal$bio
SurvTotal$abunRatio = SurvTotal$abun16 / SurvTotal$abun

#get median proportion of per survey fish and shark biomass and abundance made up by these 16 species in years < 2000
median(SurvTotal$bioRatio[which(SurvTotal$year < 2000)], na.rm = T) #0.96
median(SurvTotal$abunRatio[which(SurvTotal$year < 2000)], na.rm = T) #0.92

#and across years 
median(SurvTotal$bioRatio, na.rm = T) #0.96
median(SurvTotal$abunRatio, na.rm = T) #0.91

```

### Get mean, max, min and sd of biomasses and abundances for the model species

```{r warning=FALSE, message=FALSE, eval=T, echo = F}

#load(file="../inputs/rlsbas_mar2019.RData")
#load(file = "../inputs/ModelSpeciesSummary.RData")

fish.early.LT.M1 <- rls_bas %>% filter (SiteLat < -40.8) %>% filter (year < 2000) %>% filter (Method == 1)
length(unique(fish.early.LT.M1$SurveyID)) #1965
surveys <- unique(fish.early.LT.M1$SurveyID)

SurveyYear <- fish.early.LT.M1 %>% group_by(SurveyID) %>% summarise (year = first(year), spp = n_distinct(TAXONOMIC_NAME))

##
ModelSppAbund <- rls_bas %>% 
  filter (SiteLat < -40.8) %>%
  filter (TAXONOMIC_NAME %in% ModelSpecies$TAXONOMIC_NAME) %>% 
  filter (Method == "1") %>% 
  group_by (TAXONOMIC_NAME, SurveyID) %>% 
  summarise (bio16 = sum(BioMass, na.rm = T), abun16 = sum(Abundance))

#Now we have  biomases and abundances of all model species per each survey. But if a species was not present in the survey it will not be recorded, and we do not know for how many surveys a given species was absent from. So from this data we can't estimate mean per survey abundance or sd of abundance. We want to create a file with all surveys for each species and 0 if a species was not present

temp1 <- rep(surveys, each = length(ModelSpecies$TAXONOMIC_NAME)) ## vector of surveys by species
temp2 <- rep(ModelSpecies$TAXONOMIC_NAME, times = length(surveys) ) ## vector of species 
temp3 <- as.data.frame(cbind(temp1, temp2)) ## combine them
colnames(temp3) <- c("SurveyID","TAXONOMIC_NAME") #column names 

#add observed abundance to the relevant rows. Since we use left_join it will keep all entries from temp3, so all survey / species combinations, and leave NA if a species was absent
SppSurveyAll <- left_join(temp3, ModelSppAbund, by = c("SurveyID","TAXONOMIC_NAME"))

## check that we have the same number of NAs for biomasses and abundances 
length(which(is.na(SppSurveyAll$bio16) == TRUE))
length(which(is.na(SppSurveyAll$abun16) == TRUE))
# yes, we do, which means that if there is no abundance there is also no biomass and vice versa

#and replace NAs with 0 
SppSurveyAll$bio16[which(is.na(SppSurveyAll$bio16) == TRUE)] <- 0
SppSurveyAll$abun16[which(is.na(SppSurveyAll$abun16) == TRUE)] <- 0

#Now we can calcualte per survey biomass and abundance statistics 
ModelSppStatistics <- SppSurveyAll %>% group_by(TAXONOMIC_NAME) %>%
  summarise(meanBio = mean(bio16), sdBio = sd(bio16), maxBio = max(bio16), medianBio = median(bio16), meanAbun = mean(abun16), sdAbun = sd(abun16), maxAbun = max(abun16), q90abun = quantile(abun16, probs = 0.9), q80bio = quantile(abun16, probs = 0.8), q70abun = quantile(abun16, probs = 0.70), q60abun = quantile(abun16, probs = 0.60), q50abun = quantile(abun16, probs = 0.50))

#write.csv(ModelSppStatistics, file = "fish.csv")

#NOTE, there is a huge amount of variation in abundance and biomass per survey. For most species median per survey abundance is 0!

#Now do the same for invertebrates 
fish.early.LT.M2 <- rls_bas %>% filter (SiteLat < -40.8) %>% filter (year < 2000) %>% filter (Method == 2)
length(unique(fish.early.LT.M2$SurveyID)) #1945
surveysM2 <- unique(fish.early.LT.M2$SurveyID)

## Urchin abundance
urchinSum <- rls_bas %>% 
  filter (SiteLat < -40.8) %>%
  filter (year < 2000) %>% 
    filter(Method==2) %>% #method 2 has 5 times smaller area than method 1, so abund is multiplied by 5
      filter( GENUS == "Heliocidaris" | GENUS == "Centrostephanus" | GENUS == "Goniocidaris" ) %>%
        group_by (SurveyID) %>%
          summarise (abunUr = sum(Abundance))

#Lobsters
lobsterSum <- rls_bas %>% 
  filter (SiteLat < -40.8) %>%
#  filter(Location %in% LocationsWanted) %>%
   filter (year < 2000) %>%
    filter(Method==2) %>% 
      filter( GENUS == "Jasus") %>%
        group_by (SurveyID) %>%
          summarise (abunLob = sum(Abundance))

#create a dataframe of all surveys
temp1 <- as.data.frame(cbind(surveysM2, NA))
colnames(temp1) <- c("SurveyID", "abundance")
urchAb <- left_join(temp1, urchinSum, by = "SurveyID")
InvertAb <- left_join(urchAb, lobsterSum, by = "SurveyID")

#replace NAs by 0
InvertAb$abunUr[which(is.na(InvertAb$abunUr) == TRUE)] <- 0
InvertAb$abunLob[which(is.na(InvertAb$abunLob) == TRUE)] <- 0

#And calcualte by survey statistics
InvertStatistics <- InvertAb %>% summarise(UrAbMean = mean(abunUr), UrAbSD = sd(abunUr), UrAbMax = max(abunUr), Urq90abun = quantile(abunUr, probs = 0.9), Urq80abun = quantile(abunUr, probs = 0.8), Urq70abun = quantile(abunUr, probs = 0.70), Urq60abun = quantile(abunUr, probs = 0.60), Urq50abun = quantile(abunUr, probs = 0.50), LobAbMean = mean(abunLob), LobAbSD = sd(abunLob), LobAbMax = max(abunLob), Lob90abun = quantile(abunLob, probs = 0.9), Lob80abun = quantile(abunLob, probs = 0.8), Lob70abun = quantile(abunLob, probs = 0.70), Lob60abun = quantile(abunLob, probs = 0.60), Lob50abun = quantile(abunLob, probs = 0.50))

#to convert to biomass, I assume that an average urchin weighs 5 grams; 
urcRow <- as.numeric(c(InvertStatistics$UrAbMean*5, InvertStatistics$UrAbSD*5, InvertStatistics$UrAbMax*5, InvertStatistics$Urq50abun*5, InvertStatistics$UrAbMean, InvertStatistics$UrAbSD, InvertStatistics$UrAbMax, InvertStatistics$Urq90abun, InvertStatistics$Urq80abun, InvertStatistics$Urq70abun, InvertStatistics$Urq60abun, InvertStatistics$Urq50abun))

MeanLobWeight = 150

# For biomass I assume that average observed lobster weighs 300g (below the maturation size, they can get to a few kg in weight)
lobRow <- as.numeric(c(InvertStatistics$LobAbMean*MeanLobWeight, InvertStatistics$LobAbSD*MeanLobWeight, InvertStatistics$LobAbMax*MeanLobWeight, InvertStatistics$Lob50abun*MeanLobWeight, InvertStatistics$LobAbMean, InvertStatistics$LobAbSD, InvertStatistics$LobAbMax, InvertStatistics$Lob90abun, InvertStatistics$Lob80abun, InvertStatistics$Lob70abun, InvertStatistics$Lob60abun, InvertStatistics$Lob50abun))

#Add urchin observations
#For method 2 remember to multiply everything by 5 to get comparable abundances!!
ModelSppStatistics <- add_row( ModelSppStatistics)
dim(ModelSppStatistics)
ModelSppStatistics[dim(ModelSppStatistics)[[1]],c(2:13)] <- urcRow*5
ModelSppStatistics[dim(ModelSppStatistics)[[1]],1] <- "urchins"

#Add lobsters
ModelSppStatistics <- add_row( ModelSppStatistics)
dim(ModelSppStatistics)
ModelSppStatistics[dim(ModelSppStatistics)[[1]],c(2:13)] <- lobRow*5
ModelSppStatistics[dim(ModelSppStatistics)[[1]],1] <- "lobsters"

#And add a general predator
ModelSppStatistics <- add_row(ModelSppStatistics)
dim(ModelSppStatistics)
ModelSppStatistics[dim(ModelSppStatistics)[[1]],1] <- "predator"
ModelSppStatistics[dim(ModelSppStatistics)[[1]],2] <- 500 #mean biomass of a predator
ModelSppStatistics[dim(ModelSppStatistics)[[1]],6] <- 0.5 #mean abundance of a predator

## now pool some species into model groups
ModelSpp = c("Caesioperca rasor", "Cheilodactylus spectabilis" ,"Dinolestes lewini" ,"Latridopsis forsteri" ,"Aplodactylus arctidens" ,"Notolabrus tetricus", "Notolabrus fucicola" ,"Cephaloscyllium laticeps", "Meuschenia australis" ,"Acanthaluteres vittiger" ,"Pseudophycis bachus" ,"Trachinops caudimaculatus", "Olisthops cyanomelas" ,"Pentaceropsis recurvirostris", "Meuschenia freycineti" ,"Pictilabrus laticlavius", "urchins", "lobsters", "predator")
MatchNames <- list()
MatchNames$modelName <- c("C_rasor", "C_spectabilis" ,"D_lewini" ,"L_forsteri" ,"A_arctidens" ,"Notolabrus", "Notolabrus" ,"C_laticeps", "leatherjack" ,"leatherjack" ,"P_bachus" ,"T_caudimaculatus", "O_cyanomelas" ,"Boarfish", "M_freycineti" ,"P_laticlavius", "urchins", "lobsters", "predator")
MatchNames$sppName <- ModelSpp

ModelSppStatistics$modelName <- MatchNames$modelName[match(ModelSppStatistics$TAXONOMIC_NAME, MatchNames$sppName)]

#Model species summary
ModelSummaryFinal <- ModelSppStatistics %>% group_by(modelName) %>% summarise(meanAb = mean(meanAbun), sdAb = mean(sdAbun), maxAb = mean(maxAbun), meanBio = mean(meanBio), sdBio = mean(sdBio), maxBio = mean(maxBio))

load(file = "../inputs/meanAbundBefore2000.RData")

ModelSummaryFinal$meanAbOLD <- fishAbund$meanAb[match(ModelSummaryFinal$modelName, fishAbund$modelName)]
ModelSummaryFinal$meanBioOLD <- fishAbund$meanBio[match(ModelSummaryFinal$modelName, fishAbund$modelName)]
ModelSummaryFinal$sdAbOLD <- fishAbund$sdAb[match(ModelSummaryFinal$modelName, fishAbund$modelName)]
ModelSummaryFinal$sdBioOLD <- fishAbund$sdBio[match(ModelSummaryFinal$modelName, fishAbund$modelName)]

ModelSummaryFinal$scaledAbun <- ModelSummaryFinal$meanAb/max(ModelSummaryFinal$meanAb)
ModelSummaryFinal$scaledBiom <- ModelSummaryFinal$meanBio/max(ModelSummaryFinal$meanBio)

ModelSppStatistics <- ModelSummaryFinal
#write.csv(ModelSppStatistics, file = "../inputs/ModelSppStats.csv")
save(ModelSppStatistics, file = "../inputs/ModelSppStats.RData")

## save relative abundance and biomass data to the model param file 
mariaParams <- read.csv(file = "../modelParams/Tasm_parameters.csv")
mariaParams$scaledAb <- round(ModelSummaryFinal$scaledAbun[match(mariaParams$species, ModelSummaryFinal$modelName)],6)
mariaParams$scaledBio <- round(ModelSummaryFinal$scaledBiom[match(mariaParams$species, ModelSummaryFinal$modelName)],6)
mariaParams$BioM2 <- (round(ModelSummaryFinal$meanBio[match(mariaParams$species, ModelSummaryFinal$modelName)],6)/500)
write.csv(mariaParams, file = "../modelParams/Tasm_paramsN19.csv")

#for Trachinops mean abundance is 110 but it gives diffcult calibration so I set to lower number for now (note that here we only record abundance above 2cm, whereas model counts all abundance and assumes same size slopes for all species)
#fishAbund$meanAb[which(fishAbund$modelName == "T_caudimaculatus")] <- 60
#fishAbund$meanAb[which(fishAbund$modelName == "urchins")] <- 100 #instead of 230, which drives the system nuts I think
#save(fishAbund, file = "meanAbundBefore2000.RData")
#For lobsters LW conversion is as 
#W = 0.000285*L^3.114 males
#W = 0.000271*L^3.135 females
#to convert from carapace length in mm to grams

```

### Species params: Fishbase, diet prediction

```{r}
load(file = "../inputs/ModelSpeciesSummary.RData")

ModelSpp <- ModelSpecies$TAXONOMIC_NAME

#get maximum size from the survey data: surveys are selected for the model area

  MaxSize <- rls_bas %>%
    filter (TAXONOMIC_NAME %in% ModelSpp) %>%
      group_by (TAXONOMIC_NAME, year) %>% # maximum size observed in a year in a given Location
        summarise (sizeMax = max(SizeClass)) %>% 
          group_by(TAXONOMIC_NAME) %>%
            top_n(3, sizeMax) %>% summarise (MaxSizeMed = median(sizeMax))
  
ModelSpecies <- full_join(ModelSpecies, MaxSize, by = "TAXONOMIC_NAME")
  
ModelSpecies$therm_count <- thermal$count[match(ModelSpecies$TAXONOMIC_NAME, thermal$SPECIES_NAME)] 
ModelSpecies$CTMq05 <- thermal$CTMq05[match(ModelSpecies$TAXONOMIC_NAME, thermal$SPECIES_NAME)]
ModelSpecies$CTMq95 <- thermal$CTMq95[match(ModelSpecies$TAXONOMIC_NAME, thermal$SPECIES_NAME)]
ModelSpecies$midpoint <- thermal$MP..5.95.[match(ModelSpecies$TAXONOMIC_NAME, thermal$SPECIES_NAME)]
ModelSpecies$comname <- ComNames$COMMON_NAME[match(ModelSpecies$TAXONOMIC_NAME, ComNames$TAXONOMIC_NAME)]

## next add parameters for length-weight conversion 
ModelSpecies$LWa <- lw$A[match(ModelSpecies$TAXONOMIC_NAME, lw$SPECIES)] 
ModelSpecies$LWb <- lw$B[match(ModelSpecies$TAXONOMIC_NAME, lw$SPECIES)]

#the median Lmax estimation is not always good, so I have a datafile corrected by experts
ModelSpecies$LmaxCor <- Lmax$LmaxCorrect[match(ModelSpecies$TAXONOMIC_NAME, Lmax$TAXONOMIC_NAME)]
ModelSpecies$vbKcor <- Lmax$Kvb_correct[match(ModelSpecies$TAXONOMIC_NAME, Lmax$TAXONOMIC_NAME)]  

##Now add parameters from the fishbase lifeHistory tool 
#first select only species that are in the model 

ModelSppFB <- FBdata %>% filter (TAXONOMIC_NAME %in% ModelSpp)
ModelSpp_Fishbase <- full_join(ModelSpecies, ModelSppFB, by = "TAXONOMIC_NAME")

ModelSpecies$vbKfb <- ModelSppFB$K[match(ModelSpecies$TAXONOMIC_NAME, ModelSppFB$TAXONOMIC_NAME)] 
ModelSpecies$Lmaxfb <- ModelSppFB$Lmax[match(ModelSpecies$TAXONOMIC_NAME, ModelSppFB$TAXONOMIC_NAME)] 

### and now add the diet prediction data 
#First create vectors for all the species and genera for which we have diet predictiton data 
dietSpecies = as.character(unique(diet$Species))
dietGenera = as.character(unique(diet$Genus))
#dietFamily = unique(dietData$Family)

## and the same for model species
ModelSpecies$genus <- rls_bas$GENUS[match(ModelSpecies$TAXONOMIC_NAME, rls_bas$TAXONOMIC_NAME)]

ModelGenera <- as.character(unlist(unique(ModelSpecies$genus)))
#ModelSpecies <- as.character(unlist(unique(ModelSpecies$TAXONOMIC_NAME)))
#ModelFamily <- unique(MarVerts$Family)

#ModelGenera[which(ModelGenera %in% dietGenera)] #all model genera are in 
#ModelSpecies[which(ModelSpecies %in% dietSpecies)]
#ModelFamily[which(ModelFamily %in% dietFamily)]

## from the large diet PREDICTION matrix extract only information relevant to the model species and genera and size groups of fish consumers
ModelDiets <- diet %>% filter(Species %in% ModelSpp) %>% group_by(WWtr, MainPrey, Species) %>% summarise (fish = n_distinct(Fish), dietProp = sum(pDietpc)/fish, preyWmean = mean(preyWW), preyWsd = sd(preyWW), preySmean = mean(predictdietsize.mm.), preySsd = sd(predictdietsize.mm.), MR = mean(ppmr), LR =mean(pplr), fromSp = first(fromSp), fromGe = first(fromGe), fromFa = first(fromFa)) #%>% filter(fish>5) %>% filter (dietProp > 5)

#get total number of size groups available in the diet prediction data  for all model species. it would be better to simply use the diet prediction code to run for the range of model size groups. But at the moment we are using outputs generated from the diet prediction code to the RLS observations in Tasmania. Given that predictions are very general this is sufficient for now 
NofSG <- diet %>% filter(Species %in% ModelSpp) %>% group_by(Species) %>% summarise(sizeGr = n_distinct(WWtr))

ModelDiets2 <- full_join(ModelDiets, NofSG, by ="Species")
 
#Get a summary of diet predictions for species and prey types. What is the predicted proportion and PPMR of different prey types for model species 
MeanModelDiets <- ModelDiets2 %>% group_by(Species, MainPrey) %>% summarise(NoFish = sum(fish), NoFishSizeGroups = n_distinct(WWtr), meanWgtFish = mean(WWtr), sdWgtFish = sd(WWtr), dietProp = round(sum(dietProp)/first(sizeGr),0), PPMRmean = round(mean(MR),0), PPMRsd = round(sd(MR, na.rm = T),0), fromSp = first(fromSp), fromGe = first(fromGe), fromFa = first(fromFa), ) #get correct diet proporton in %

rm(ModelDiets, ModelDiets2, NofSG)

#Mean model diets shows the proportion of various diets 

SpeciesPPMR <- MeanModelDiets %>% group_by(Species) %>% summarise(dietTypes = n_distinct(MainPrey), MRmean = round(mean(PPMRmean),0), MRsd = round(mean(PPMRsd, na.rm = T),0), fromSp = first(fromSp), fromGe = first(fromGe), fromFa = first(fromFa))
SpeciesPPMR$dietConf <- SpeciesPPMR$fromSp + SpeciesPPMR$fromGe + SpeciesPPMR$fromFa

ModelSpecies$PPMRmean <- SpeciesPPMR$MRmean[match(ModelSpecies$TAXONOMIC_NAME, SpeciesPPMR$Species)] 
ModelSpecies$PPMRsd <- SpeciesPPMR$MRsd[match(ModelSpecies$TAXONOMIC_NAME, SpeciesPPMR$Species)]
ModelSpecies$dietConf <- SpeciesPPMR$dietConf[match(ModelSpecies$TAXONOMIC_NAME, SpeciesPPMR$Species)]

#FishBenDiets <- MeanModelDiets %>% filter(MainPrey == "epif" | MainPrey == 'epcr' | MainPrey == "fish" | MainPrey == 'plcr') %>% group_by (Species, MainPrey) %>% summarise (MRmean = mean(MRmean), MRsd = mean(MRsd))

#save(ModelSpecies, file = "../inputs/ModelSpeciesSummaryMore.RData")

```

### Estimating h: maximum intake coefficient

Daily food intake for all RLS species has been calculated by Soler et al. (2014) based on diets, sizes and average site temperature. The equation is from Palomares and Pauly (1989) and is empirically derived: 
lnQ/B = −0.1775 − 0.2018 lnW + 0.6121 lnT + 0.5156 lnA + 1.26F
where Q/B is the % intake per day, A is the aspect ratio of the tail and F is set to 1 for carnivorous fish and 0 for all other fish. The values of daily intake in these calculations varies around 1-8% for differnet species and sizes, but is bigger for herbivores. These values are generally consistent with experimental feeding rates

We can use the estimates for a simple body size intake linear regression, that will give us allometric relationship between consumption and body size (constant and exponent). Note, these intake values are realised intakes ant not the maximum intake. So we need to correct them for the feeding level to get to the maximum intake. If we make various assumptions about the feeding level we could infer the maximum intake rate at different body sizes. For this we assume that feeding level changes smoothly and monotonically with body size. This is not entirely true as some sizes might experience drops in feeding level, but for a general approximation it will do

#### h for model species only

```{r warning=FALSE, message=FALSE, warning=FALSE, echo=F}
load(file = "../inputs/ModelSpeciesSummaryMore.RData")
#diet = read.csv (file = "../inputs/dietpred.csv")

#assumptions about food limitation 
f_min = 0.6 # assumed value for feeding level at minimum body size
f_max = 0.9 # assumed value for feeding level at maximum body size
m1_1 = 0.15 #steepness value to give a smooth curve 

#check how the curve looks: 
ww_inf = 1000 #let's say maximum body size is 1000g
ww = seq(from = 0, to = ww_inf)
foodlim1 <- f_min + (f_max-f_min)*exp(-m1_1*(ww_inf/ww)) # food satiation versus body size 
#this is how feeding level could increase with body size at the intraspecific level 
plot(ww, foodlim1, type = 'l')

#get Wmax for all model species
ModelSpecies$Wmax <- ModelSpecies$LWa * ModelSpecies$Lmax^ ModelSpecies$LWb

## list of model species
ModelSpp <- ModelSpecies$TAXONOMIC_NAME

# loop through the list of model species, fit linear regression between food consumed (in grams) and consumers body weight 
ConsEst <- list()

for (i in 1:length(ModelSpp)) {
  
Intake <- diet %>% filter (Species %in% ModelSpp[i])

Intake$Wmax <- ModelSpecies$Wmax[match(Intake$Species, ModelSpecies$TAXONOMIC_NAME)]

#linear regression to estimate daily consumption - weight relationship
# daily consumption is predicted based on the equation above
temp = lm(log(Intake$FoodCons) ~ log(Intake$WWtr))
ConsEst$coef[i] <- exp(temp$coefficients[[1]])
ConsEst$exp[i] <- temp$coefficients[[2]]

# the consumption estimates above are realised intake, not maximum intake. To get maximum intake we have to assume some level of food limitation. Let's assume that food limiation or satiation changes with body size as outlined above. Now add a column of feeding level to the data set. It will depend on the ratio between body size to maximum size 
Intake$foodlim <- f_min + (f_max-f_min)*exp(-m1_1*(Intake$Wmax/Intake$WWtr))

#Now the maximum consumption would simply be the ratio from the estimated consumption by food limitation
maxcon = Intake$FoodCons/Intake$foodlim
# and we can fit a regression on how max consumption  scales with body size 
temp2 = lm(log(maxcon) ~ log(Intake$WWtr))

#Save the coefficient and exponents values (transformed from the log log scale to that used in the model)
ConsEst$coefMax[i] <- exp(temp2$coefficients[[1]])
ConsEst$expMax[i] <- temp2$coefficients[[2]]
ConsEst$TAXONOMIC_NAME[i] <- ModelSpp[i]
}

# Add these values into the final data file. Note the coefficient is divided by 100 because thi
ModelSpecies$ConsConst <- (ConsEst$coef[match(ModelSpecies$TAXONOMIC_NAME, ConsEst$TAXONOMIC_NAME)])/100
ModelSpecies$ConsExp <- ConsEst$exp[match(ModelSpecies$TAXONOMIC_NAME, ConsEst$TAXONOMIC_NAME)] 
ModelSpecies$ConsConstMax <- (ConsEst$coefMax[match(ModelSpecies$TAXONOMIC_NAME, ConsEst$TAXONOMIC_NAME)])/100
ModelSpecies$ConsExpMax <- ConsEst$expMax[match(ModelSpecies$TAXONOMIC_NAME, ConsEst$TAXONOMIC_NAME)] 

## Note the exponent of daily food consumption with body weight is 0.79-0.81
round(ModelSpecies$ConsExpMax, 2)

## consumption constant (higher for two herbivore species)
round(ModelSpecies$ConsConstMax, 2) 

#or get annual values, as used in mizer
round(ModelSpecies$ConsConstMax, 2)*365

##
##Alternatively, we could use default mizer estimations of h from Blanchard et al. 2004 (?). They use Winf and von Bertalanffy K.
K_vb = ModelSpecies$vbKfb # VB k value from fishbase
K_vbC = ModelSpecies$vbKcor #Vb k value from literature on specific species or talking to experts. You can see how different it can be!
Winf = ModelSpecies$Wmax

#assumed feeding level
f0 = 0.8
alpha = 0.6*0.6 #here we account for 0.6 assimilation efficiency and 0.6 growth cost (inefficiency)

ModelSpecies$h_mizer = (3*K_vb)/(alpha*f0) * Winf^(1/3)
ModelSpecies$h_mizerC = (3*K_vbC)/(alpha*f0) * Winf^(1/3)

#plot(ModelSpecies$Wmax, ModelSpecies$h_mizer)

ConsParams <- ModelSpecies %>% select (TAXONOMIC_NAME, ConsExp, ConsExpMax, ConsConst, ConsConstMax, LmaxCor, vbKcor, Lmaxfb, vbKfb, PPMRmean, PPMRsd, dietConf, h_mizer, h_mizerC, Wmax) %>% mutate(ConsConstMaxY = ConsConstMax*365) 

knitr::kable(ConsParams, digits = 3)

```

The summary from analyses above shows that assuming feeding level of about 0.6 across all body size and using empirical equation based daily intake values, we get the h value of about 50 g/g/year for most species and ca 150 g/g/year for herbivores. The esimated maximum consumption exponent n is around 0.8, which is much higher than DEB or mizer assumptions of 2/3. To get the maximum intake exponent to be close to 2/3 and still match the daily intake estimates from the Pauly and Palomares equation (or other empirical studies), we need to assume that for many fish species feeding level increases with body size from 0.5 to somewhere around 0.9. In this case the fitted exponent is ca 0.7-0.75 and h is 40-60g/g/year (ConsConstMaxY column) and 200g/g/year in herbivores. You can see that if you play with the feeding level assumptions above

If we use mizer default h estimation (based on alpha, VB_k and feeding level) we find that it is extremely sensitive to the VB k parameter, which is highly uncertain in our species. So the h estimate can vary between 30 and 170 for the same species, because k estimates for this species vary between 1.4 to 0.26! However for species where k values seem reasonabble (e.g. Notolabrus) the mizer default values are about half of what we get based on daily intake estimation (ca 20-30 g/g/year for mizer default compared to 40-60 g/g/year for my estimations). If we reduce alpha from 0.6 to 0.6*0.6 (which now accounts both for assimilation efficiency and growth conversion cost used in this study)and increase the feeding level to 0.8 we still get h values about 50% lower than the estimates based on empirical intake assumptions. 

Next, we can compare these estimates of h to the Dynamic Energy Budget (DEB) theory. DEB assumes that intake is always at maximum (feeding level =1). The range of surface area specific maximum assimilation rate in DEB ranges at 0.06-0.19 g cm-2 day-1 (DEB online database, Kooijman and Lika, 2014), which is approximately 0.06-0.2 g/g/day or 20-73 g/g/year given that DEB and mizer assumptions that maximum intake scales with body sizes to the power of 2/3. In fish growth model (Audzijonyte & Richards, 2018) intake is determined by structural weight only, so the mass specific constant is higher than in models where intake is based on total weight. The constant is 0.1 g/g/day (or 36.5 g/g/years) and leads to emergent daily intake of 0.5-4%  (assuming assimilation efficiency of 0.7-0.8). In mizer default assimilation rates are slighly lower (0.6) so the maximum intake rate should be a bit higher, or closer to 40-50g/g/year. Indeed, in the standard community model of mizer the maximum food intake constant h = 40 g/g/year (Hartvig et al. 2011), which is very similar to the estimate from the daily food intake or from DEB. This suggests that at least for the model species mizer default calculations would give h values that are too low, and we should aim for the h values that are in the range of 40-50g/g/year. 

#### h to Wmax across many species

Now we can repeat similar analyses for the entire list of species in the Soler et al. dataset

```{r}
#assumptions 
f_min = 0.5 # assumed value for feeding level at minimum body size
f_max = 0.9 # assumed value for feeding level at maximum body size
m1_1 = 0.15 #steepness value to give a smooth curve 


AllSpp <- unique(diet$Species)
#are there any na?
length(which(is.na(diet$Lmax) == T))
#get only data without NA for Lmax
dietForRegr <- diet[which(is.na(diet$Lmax) == F),]
length(which(is.na(dietForRegr$Lmax) == T))
plot(unique(dietForRegr$Lmax))
#now add LW data to get Wmax
dietForRegr$LWa <- lw$A[match(dietForRegr$Species, lw$SPECIES)]
dietForRegr$LWb <- lw$B[match(dietForRegr$Species, lw$SPECIES)]
length(which(is.na(dietForRegr$LWa) == T))
#now get Wmax 
dietForRegr$Wmax <- dietForRegr$LWa*dietForRegr$Lmax^dietForRegr$LWb
plot(unique(log(dietForRegr$Wmax)))
#some species has too small wmax values, let's only use those that are biiger than 10
dietForRegr <- dietForRegr[which(dietForRegr$Wmax > 10),]

#list of species
AllSpp <- unique(dietForRegr$Species)

# loop through the list of model species, fit linear regression between food consumed (in grams) and consumers body weight 
ConsEst <- list()

for (i in 1:length(AllSpp)) {
  
Intake <- dietForRegr %>% filter (Species %in% AllSpp[i])

#linear regression to estimate daily consumption - weight relationship
# daily consumption is predicted based on the equation above
temp = lm(log(Intake$FoodCons) ~ log(Intake$WWtr))
ConsEst$coef[i] <- exp(temp$coefficients[[1]])
ConsEst$exp[i] <- temp$coefficients[[2]]

# the consumption estimates above are realised intake, not maximum intake. To get maximum intake we have to assume some level of food limitation. Let's assume that food limiation or satiation changes with body size as outlined above. Now add a column of feeding level to the data set. It will depend on the ratio between body size to maximum size 
Intake$foodlim <- f_min + (f_max-f_min)*exp(-m1_1*(Intake$Wmax/Intake$WWtr))

#Now the maximum consumption would simply be the ratio from the estimated consumption by food limitation
maxcon = Intake$FoodCons/Intake$foodlim
# and we can fit a regression on how max consumption changes scales with body size 
temp2 = lm(log(maxcon) ~ log(Intake$WWtr))

#Save the coefficient and exponents values (tranformed from the log log scale to that used in the model)
ConsEst$coefMax[i] <- exp(temp2$coefficients[[1]])
ConsEst$expMax[i] <- temp2$coefficients[[2]]
ConsEst$TAXONOMIC_NAME[i] <- AllSpp[i]
}

ConsResAllSpp <- as.data.frame(cbind((ConsEst$coef/100), ConsEst$exp, (ConsEst$coefMax/100), ConsEst$expMax))
ConsResAllSpp$Species <- AllSpp
ConsResAllSpp$Wmax <- dietForRegr$Wmax[match(ConsResAllSpp$Species, dietForRegr$Species)]

colnames (ConsResAllSpp) <- c("coef", "exp", "coefMax", "expMax", "Species", "Wmax")

ConsResAllSpp <- ConsResAllSpp[which(is.na(ConsResAllSpp$expMax) == F),]

round(ConsResAllSpp$exp,2)
round(ConsResAllSpp$coef,3)
round(ConsResAllSpp$expMax,2)
mean(ConsResAllSpp$expMax)
round(ConsResAllSpp$coefMax,2)
#or yearly
round(ConsResAllSpp$coefMax,2)*365
mean((ConsResAllSpp$coefMax))

#or for all species 
plot(log(ConsResAllSpp$Wmax), (ConsResAllSpp$coefMax))

#second regression to get h scaling with Wmax
h_model <- lm(log(ConsResAllSpp$coefMax) ~ log((ConsResAllSpp$Wmax/1000)))

#intercept exp(a) of the model
exp(h_model$coefficients[[1]])
#slope of the model
h_model$coefficients[[2]]

#to account for large number of herbivores we use slighly lower intercept and the final equation is 
#mariaParams$h = 50 * (mariaParams$w_inf/1000)^0.15

```

### Estimating ks across species

By default in mizer and in many MSS model ks = h*0.12. This is based on the assumption that critical feeding level is 0.2 and that assimilation efficiency is 0.6. So intake will just cover the maintenance costs at the critical feeding level (0.6x0.2). For the h of 40g/g/year (see above) this would give ks values of 4.8 g/g/year  and, since h increases with maximum body size, ks would also be larger in large bodied fish. However, critical feeding level in small and large bodied species is likely to be similar and there is good evidence that "cost of life" of mass-specific metabolic rates are higher is small bodied species. 

The average mass specific maintenance cost of structure at 20°C temperature in DEB is 20 J cm-3 day-1, but in slow growing vertebrates can be as low as 10 J cm-3 day-1 (Kooijman 2000). For the cod model we assumed maintenance of 10 J cm-3 day-1 (cold water), which translates to 0.003 g g-1 day-1, assuming 1g of structure mass equals 3000J and 1cm3 of wet weight is 1g (van der Veer et al. 2009). This translates to 1.1 g/g/year, but remember the exponent is 1 with structural mass. While reserves don’t need maintenance in DEB, the R pool here includes reserves and gonads and a small maintenance cost (cR) is used, set at 10% of cS. These values give an emergent total maintenance cost of an adult individual at 40-70% of its daily energy intake


```{r}

#Get DEB parameters 

#get the data file and make a matrix
load(file = '../inputs/debdata.Rda')
Nspecies <- length(debdata$allStat)

# get all values of p_M, v, and the species names
SpNames <- vector(length = Nspecies)
fam <- vector(length = Nspecies) 
order <- vector(length = Nspecies)
class <- vector(length = Nspecies)
zoom <- vector(length = Nspecies) #zoom factor 21
Fm <- vector(length = Nspecies) #Fm = max spec searching rate 22
alfa <- vector(length = Nspecies) #alfa = digestion efficiency 23
ffae <- vector(length = Nspecies) #ffae = food to feased efficiency 24 
v <- vector(length = Nspecies) #v = energy conductance 25
#kapppa <- vector(length = Nspecies) #kappa = allocaiton to soma 26
p.M <- vector(length = Nspecies) #p.M = vol. spec som maintenance 28
p.T <- vector(length = Nspecies) #p.T = surf specific somatic maint 29
k.J <- vector(length = Nspecies)#k.J - maturity maint rate 30
E.G <- vector(length = Nspecies) # E.G - spec cost of structure 31
Arrh <- vector(length = Nspecies)#Arrh = arrhenius temp 36
funcres <- vector(length = Nspecies)#funcres = functional response scaled 38

#DEBparams = data.frame(NA, nrow = length(Nspecies), ncol = 8)

for(i in 1:Nspecies){
  
SpNames[i] <- debdata$allStat[[i]][[1]]
fam[i] <- debdata$allStat[[i]][[5]]
order[i] <- debdata$allStat[[i]][[6]]
class[i] <- debdata$allStat[[i]][[7]]
zoom[i] <- debdata$allStat[[i]][[21]]
Fm[i] <- debdata$allStat[[i]][[22]] # all the same. 6.5
alfa[i] <- debdata$allStat[[i]][[23]] # mostly all at 0.8
ffae[i] <- debdata$allStat[[i]][[24]] #all at 0.10
v[i] <- debdata$allStat[[i]][[25]] # does not look that good
#kappa[i] <- debdata$allStat[[i]][[26]]
p.M[i] <- debdata$allStat[[i]][[28]]
#p.T[i] <- debdata$allStat[[i]][[29]]
k.J[i] <- debdata$allStat[[i]][[30]] # not good, too similar
E.G[i] <- debdata$allStat[[i]][[31]]
Arrh[i] <- debdata$allStat[[i]][[36]]
funcres[i] <- debdata$allStat[[i]][[38]]

}

debparams <- cbind(SpNames, fam, order, class, zoom, Fm, alfa, ffae, v, p.M, k.J, E.G, Arrh, funcres)
debparams[which(debparams == 0)] <- NA #replace zero's with NA because they are actually NAs not zeros

## 
vectFish <- which(class == "Actinopterygii")
vectShark <- which(class == "Chondrichthyes")
debFish <- debparams[vectFish,]

#Plot zoom factor against metabolic rate, we can see that are few species have very high metabolic rates
plot(debFish[,5], debFish[,10], ylim = c(0, 200), xlab = "zoom factor", ylab = "p.M")

#highFishpM = which(debFish[,10] > 150)
#debFish[highFishpM,c(1:3)]
#quantile(as.numeric(debFish[c(highFishpM), 5]))

#unique(class)
# select only fish or sharks with main non extreme metabolic rates
vectFish <- which(class == "Actinopterygii" & p.M > 0 & p.M < 100)
vectShark <- which(class == "Chondrichthyes" & p.M > 0 & p.M < 1000)

plot(log(zoom[vectFish]), log(p.M[vectFish]), xlab = "log structural length, cm", ylab = "log p.M", main = "Scaling of mass specific metabolic rate (DEB p.M.) to body size in fish")
abline(lm(log(p.M[vectFish]) ~ log(zoom[vectFish])), col = 'red')


plot(zoom[vectShark], p.M[vectShark], xlab = "zoom factor - sharks", ylab = "p.M")

#zoom factor is a structural length in cm, or a cubic root of structural volume in cm3. Let's assume it is a simple length in cm. Units of p.M is J cm-3 day-1.

metsizeFish = lm(log(p.M[vectFish]) ~ log(zoom[vectFish])) #do a linear regression of metabolic rate versus zoom factor 
summary(metsizeFish)
#coefficient of exp(3.43) or 30.1 and exponent of -0.31

#this means that Metrate = 30.1*Lmax^(-0.31)

metrate <- ((30.1*ModelSpecies$Lmax^(-0.31))/3000) #3000 is to convert Joules per day to g per day
metrateY <- metrate*365
#The average estimated value for the model species is ca 10 J cm3-1 day-1, or 0.003 g g-1 day-1, assuming 1g of structure mass equals 3000J and 1cm3 of wet weight is 1g. This would give ks = 1.1 g g-1 year-1. 
```

We cannot really use this value because this is a structural maintenance that scales as 1, whereas mizer assumes scaling exponent of 0.7 and it scales with the total body mass. To get from structure to total body mass we need to assume some level of reserve to structure ratio. However, the key point is that mass specific metabolic rate clearly decreases with maximum body size So overall we assume a scaling exponent of -0.25 and adjust the  If we take the total body maintenance, the unit value then should be lower, because reserves don't need structure. 


### Pred-prey interactions

Output values for beta, sigma, and resource availability

```{r}

tab4 <- mariaParams %>% select(species, beta, sigma, avail_PP, avail_BB, avail_AA)
#write.csv(tab4, file = "../suplTables/TableS4.csv")
knitr::kable(tab4, digits = 2)

write.csv(inter, file = "../suplTables/TableS5inter.csv")
knitr::kable(inter, digits = 2)

```

### empty

```{r}

```

### Plankton spectrum: historical and projected

This is based on Julia's global runs. Need more explanation here, but I have time series. 

```{r}
lme_resource_ts <- readRDS("../inputs/lme_scale_gcm_inputs.rds")
#glimpse(lme_resource_ts)

sst <- lme_resource_ts %>% filter(variable == "sst") %>% filter (lme == 46)
area46 <- sst
area46$year <- as.numeric(substr(area46$month, 1,4))
area46$monthonly <- substr(area46$month, 6,7)

#Extreme future 
hist_rcp85 <- area46 %>% filter (scenario == "historical" | scenario == "rcp85")
#area46 <- as.data.frame(area46)

#get annual values 
annual_hist_rcp85 <- hist_rcp85 %>% group_by(year) %>% summarise (meanSST = mean(value))

#low emission scenario 
rcp45 <- area46 %>% filter (scenario == "rcp45")
#get annual values 
annual_rcp45 <- rcp45 %>% group_by(year) %>% summarise (meanSST = mean(value))

#plot lambda
plot(annual_hist_rcp85$year, (annual_hist_rcp85$meanSST - 273), pch = 19, xlab = "Year", ylab = "Projected SST in C")
points(annual_rcp45$year, (annual_rcp45$meanSST -273), col = 'orange', pch = 19)
abline (v= 2005, lty =2)

## projected temperature change by 2100 in high emission scenario
mean(annual_hist_rcp85$meanSST[which(annual_hist_rcp85$year > 2090)]) - 273
mean(annual_hist_rcp85$meanSST[which(annual_hist_rcp85$year == 2000)]) - 273

## projected temperature change by 2100 in high emission scenario
mean(annual_rcp45$meanSST[which(annual_rcp45$year > 2090)]) - 273



## get kappa and lambda values

lme_resource_ts <- readRDS("../inputs/lme_resource_ts.rds")

#Filter out only area 46 - SE AUstrlaian slope 
area46 <- lme_resource_ts %>% filter (lme == 46) 

#separate year and month, and be able to get annual mean slope values, since we don't model seasonal dynamics anyway
area46$year <- as.numeric(substr(area46$month, 1,4))
area46$monthonly <- substr(area46$month, 6,7)

#Extreme future 
hist_rcp85 <- area46 %>% filter (scenario == "historical" | scenario == "rcp85")
#area46 <- as.data.frame(area46)

#get annual values 
annual_hist_rcp85 <- hist_rcp85 %>% group_by(year) %>% summarise (meanLam = mean(lambda), meanKap = mean(kappa))

#low emission scenario 
rcp45 <- area46 %>% filter (scenario == "rcp45")
#get annual values 
annual_rcp45 <- rcp45 %>% group_by(year) %>% summarise (meanLam = mean(lambda), meanKap = mean(kappa))

#plot lambda
plot(annual_hist_rcp85$year, annual_hist_rcp85$meanLam, pch = 19, xlab = "Year", ylab = "Slope of the plankton spectrum")
points(annual_rcp45$year, annual_rcp45$meanLam, col = 'orange', pch = 19)
abline (v= 2005, lty =2)

#plot kappa
plot(annual_hist_rcp85$year, annual_hist_rcp85$meanKap, pch = 19, xlab = "Year", ylab = "Intercept of the plankton spectrum")
points(annual_rcp45$year, annual_rcp45$meanKap, col = 'orange', pch= 19)
abline (v= 2005, lty =2)

#Julia's kappa values are 0.03, which are presumably per m3. We 
0.03*100

```



### Benthos spectrum: data preparation

In this section I use data from very small benthic invertebrates collected by Kate Fraser (PhD student), and standardised per m2. For invertebrates bigger than 2g, data from RLS is used and compiled by Freddie Heather into weight bins on log2 scale. The data is combined, binned into equal weight bins on log10 scale and then a regression slope is fitted. 
From the first regression and by plotting abundances we can see that there is a big increase in abundance at largest weight groups, which is mostly due to urchins and partly lobsters. Given that urchins and lobsters are modelled explicitly we want to exclude them from teh background spectrum. Ideally this should be done by reanalysing Freddie's data without urchins and lobsters, but for now I just test a regression with a steeper sloe. Assuming a steeper slope and actually gives a better fit to small weight groups. We have to remember that Kate's data can underestimate the abundance (critters escape), but is less likely to overestimate it

```{r, eval = F}
Freddie <- read.csv(file = "../inputs/benthos/Freddie.csv") #data of large invertebrates
Kate <- read.csv(file = "../inputs/benthos/all_bysample_size.csv") #small invertebrates
KateCodes <- read.csv(file = "../inputs/benthos/sample_data_env_vectors.csv") #site codes for Kate's data

# coordinates for eastern Tasmanian coast
#TasmCoorLon <- c(146.5, 148.5) 
#TasmCoorLat <- c(-41.00, -43.60)
KateWgtGroups <- c(1.8E-06,4.8E-06, 1.1E-05, 2.9E-05, 7.1E-05, 1.8E-04, 4.5E-04, 1.1E-03, 2.8E-03, 6.8E-03, 1.7E-02, 4.2E-02, 1.1E-01, 2.5E-01, 6.8E-01, 1.6E+00) #weight groups used in Kate's data (size of sieves)

TasmCodes <- KateCodes %>% filter (lat > -43.60 & lat < -41.00) %>% filter (lon > 146.5 & lon < 148.5)
TasmCodes.l <- unique(TasmCodes$SampleCode)
TasmInvSmall <- Kate %>% filter (SampleCode %in% TasmCodes.l) 
TasmInvSmall <- TasmInvSmall[,-c(1:2)]

MeanAbund <- apply(TasmInvSmall, 2, mean)
MinAbund <- apply(TasmInvSmall, 2, min)
MaxAbund <- apply(TasmInvSmall, 2, max)

InvData <- list()
InvData$wgt <- KateWgtGroups
InvData$meanAb <- MeanAbund
InvData$minAb <- MinAbund
InvData$maxAb <- MaxAbund
InvData <- as.data.frame(InvData)
InvData <- InvData[-c(which(InvData$meanAb ==0)),] # remove size groups that have 0 abundance

#combine with Freddie's data about average abundance at size in Tasmania
InvData <- rbind(InvData, Freddie)
#save(InvData, file = "../inputs/benthos/BenticInvAbund_Tasm.RData")
```

###Benthos spectrum: derive the size slope

```{r}
load(file = "../inputs/benthos/BenticInvAbund_Tasm.RData")

#What is the mean abundance per m2 
sum(InvData$meanAb)

## now I have to bin data into bins of equal size on log10 scale 
InvData$cat <- NA
log10(min(InvData$wgt)) # minimum size on log10 scale
log10(max(InvData$wgt))

breaks <- seq(from = -6, to = 4) #make a vector of breaks on a log10 scale

#for each empirical weight put assign the bin on the log10 scale
for (i in 1:length(breaks)) {
  temp <- which((log10(InvData$wgt) > breaks[i]) & (log10(InvData$wgt) < breaks[i+1]))
  InvData$cat[c(temp)] <- i
}

#get abundances for the weight groups on the equal log10 scale (normalised)
InvDataBinned <- InvData %>% group_by(cat) %>% summarise (mean_ab = sum(meanAb), min_ab = sum(minAb), max_ab = sum(maxAb), meanWgt = mean(wgt))

#add the midpoint weight for each of the log10 weight groups 
InvDataBinned$wgtBinLog10 <- seq(from = -5.5, to = 3.5, by = 1) #mean weight in the bin on log 10 scale
InvDataBinned$wgtGroup <- 10^(InvDataBinned$wgtBinLog10)
InvDataBinned$bioPerm2 <- InvDataBinned$wgtGroup * InvDataBinned$mean_ab
#save(InvDataBinned, file = "../inputs/benthos/InvDataBinned.RData")

#Now we fit linear regression to the total abundance data 
bs <- lm(log10(InvDataBinned$mean_ab) ~ log10(InvDataBinned$wgtGroup))
summary(bs)

#Plot it 
plot(log10(InvDataBinned$wgtGroup), log10(InvDataBinned$mean_ab), type = 'l', ylim = c(-4, 6), main = "Benthos slopes in Tasmania: log10(Abund) = 1.1 - 0.62*log10(wgt_bin)", xlab = "Log10 (w,g)", ylab = "Log10 (Abundance: min, mean, max)")
points(log10(InvDataBinned$wgtGroup), log10(InvDataBinned$min_ab), type = 'l', lty = 2)
points(log10(InvDataBinned$wgtGroup), log10(InvDataBinned$max_ab), type = 'l', lty = 2)
abline(lm(log10(InvDataBinned$mean_ab) ~ log10(InvDataBinned$wgtGroup)), col = 'red')

plot(log10(InvDataBinned$wgtGroup), log10(InvDataBinned$mean_ab), type = 'l', lwd =4, ylim = c(-4, 6), xlab = "Log10 (w,g)", ylab = "Log10 (Abundance: min, mean, max)")
points(log10(InvDataBinned$wgtGroup), log10(InvDataBinned$min_ab), type = 'l', lty = 2,  lwd =2)
points(log10(InvDataBinned$wgtGroup), log10(InvDataBinned$max_ab), type = 'l', lty = 2, lwd = 2)
abline(lm(log10(InvDataBinned$mean_ab) ~ log10(InvDataBinned$wgtGroup)), lwd =3, col = 'orange')


## We can see that there is a big increase in abundance at largest weight groups, which is mostly due to urchins and partly lobsters. Given that urchins and lobsters are modelled explicitly we want to exclude them from teh background spectrum. Assuming a steeper slope and actually gives a better fit to small weight groups 
#AbNoUr <- 0.8 - 0.85*log10(InvDataBinned$wgtGroup)
## this equation is now used a very general approximation of the benthic slope
AbNoUr <- 0.8 - 0.9*log10(InvDataBinned$wgtGroup)

points(log10(InvDataBinned$wgtGroup), AbNoUr, col = 'blue', type = 'l', lwd =3)

abline(v = log10(0.7), lty = 3, lwd = 2)
abline(v = log10(2), lty = 3, lwd = 2) #this is where Freddie's data starts and Kate's data ends
abline(v = log10(5), lty = 2, lwd = 2)

#or if just plotting the original (nonbinned) weights 
plot(log10(InvData$wgt), log10(InvData$meanAb), type = 'l', ylim = c(-4, 6), main = "Benthos slopes in Tasmania: not normalised weight groups", xlab = "Log10 (w,g)", ylab = "Log10 (Abundance: min, mean, max)")
points(log10(InvData$wgt), log10(InvData$minAb), type = 'l', lty = 2)
points(log10(InvData$wgt), log10(InvData$maxAb), type = 'l', lty = 2)
abline(lm(log10(InvData$meanAb) ~ log10(InvData$wgt)), col = 'red')
points(log10(InvDataBinned$wgtGroup), AbNoUr, col = 'blue', type = 'l')
abline(v = log10(2), lty = 3)

```


### Fish size spectra 

```{r}
#data file with 10% smallest sizes removed and errors filtered (hopefully)
load(file="../inputs/rlsbas_mar2019.RData") 
glimpse(rls_bas)
## 1990s, wrasse, Maria Island

df <- rls_bas %>% 
  filter (SiteLat < -40.8) %>%
  filter(Method == "1") %>%
  filter (TAXONOMIC_NAME %in% ModelSpecies$TAXONOMIC_NAME) %>%  
  filter (year < 2005) %>% 
  select(TAXONOMIC_NAME, SizeClass, Abundance, LWa, LWb, SurveyID)

df$modelName <- ModelSppStatistics$modelName[match(df$TAXONOMIC_NAME, ModelSppStatistics$TAXONOMIC_NAME)]

#group by wgt group and count numbers per m2

empSizes <- df %>% group_by(modelName, SizeClass) %>% summarise(numb = sum(Abundance), meanLWa = mean(LWa), meanLWb = mean(LWb))
empSizes$wgt <- empSizes$meanLWa * empSizes$SizeClass^ empSizes$meanLWb

empSizes$perSurvey <- empSizes$numb/length(unique(df$SurveyID)) ## divide by the total number of surveys to get average number per survey
empSizes$perSurvM2 <- empSizes$perSurvey/500 #divide by method 1 survey area 

save(empSizes, file = "../inputs/empSizes.RData")

#### Or use only Maria data

df <- rls_bas %>% 
  filter (Location %in% MariaLocs) %>%
  filter(Method == "1") %>%
  filter (TAXONOMIC_NAME %in% ModelSpecies$TAXONOMIC_NAME) %>%  
  filter (year < 2005) %>% 
#  filter (mpa == "1")
  select(TAXONOMIC_NAME, SizeClass, Abundance, LWa, LWb, SurveyID)

df$modelName <- ModelSppStatistics$modelName[match(df$TAXONOMIC_NAME, ModelSppStatistics$TAXONOMIC_NAME)]

#group by wgt group and count numbers per m2

empSizes <- df %>% group_by(modelName, SizeClass) %>% summarise(numb = sum(Abundance), meanLWa = mean(LWa), meanLWb = mean(LWb))
empSizes$wgt <- empSizes$meanLWa * empSizes$SizeClass^ empSizes$meanLWb

empSizes$perSurvey <- empSizes$numb/length(unique(df$SurveyID))
empSizes$perSurvM2 <- empSizes$perSurvey/500
empSizesMaria <- empSizes

save(empSizesMaria, file = "../inputs/empSizesMaria.RData")

##

load(file="../inputs/VertData_Temporal.RData") 
glimpse(VertData_temporal)
## 1990s, wrasse, Maria Island

df <- VertData_temporal %>% 
  filter (Locs == "Maria ") %>%
 # filter(Method == "1") %>%
  filter (mpa == "1")
  filter (TAXONOMIC_NAME %in% ModelSpecies$TAXONOMIC_NAME) %>%  
  filter (year > 2000 & year < 2015) %>% 
  select(TAXONOMIC_NAME, SizeClass, LWa, LWb, SurveyID)

df$modelName <- ModelSppStatistics$modelName[match(df$TAXONOMIC_NAME, ModelSppStatistics$TAXONOMIC_NAME)]

#group by wgt group and count numbers per m2

empSizes <- df %>% group_by(modelName, SizeClass) %>% summarise(numb = n(), meanLWa = mean(LWa), meanLWb = mean(LWb))
empSizes$wgt <- empSizes$meanLWa * empSizes$SizeClass^ empSizes$meanLWb

empSizes$perSurvey <- empSizes$numb/length(unique(df$SurveyID)) ## divide by the total number of surveys to get average number per survey
empSizes$perSurvM2 <- empSizes$perSurvey/500 #divide by method 1 survey area 
empSizesMariaMPA <-empSizes


save(empSizesMariaMPA, file = "../inputs/empSizesMarMPA.RData")






```


### Fig1: map: TODO

```{r}
rls_aus_geo <- main_data %>% 
    group_by(geogroup) %>% 
      summarise (location = first(Location), latt = round(mean(SiteLat),3), long = round(mean(SiteLong),3), year = n_distinct(year), surveys = n_distinct(SurveyID), locatnum = n_distinct(Location), anntemp = mean(meansst), species = n_distinct(TAXONOMIC_NAME), gdd = mean(scaledGDD)) 

## Now plot the geographic groups but the colour of the dot reflects the mean geosite temperature
rls_aus_geo$tempF <- floor(rls_aus_geo$anntemp) #round the annual SST to the nearest degree 
colvector <- list(NA)
colfunc <- colorRampPalette(c("yellow", "red")) #create colour ramp pallele
tempcol = colfunc(18) # sample 18 colours from it, as the difference between min and max geosite temperature is 18 degrees
colvector$col <- tempcol
colvector$tempF <- seq(from = 12, to = 29)
# add a temperature colour identifier to each geosite
rls_aus_geo$color <- colvector$col[match(rls_aus_geo$tempF, colvector$tempF)]

#load long term location coordinates
load(file = "inputs/longLoc.RData")

### code from Freddie 

list.of.packages <- 
  c("tidyverse",
    "cowplot", 
    "googleway", 
    "ggrepel", 
    "ggspatial", 
    "libwgeom", 
    "sf", 
    "rnaturalearth", 
    "rnaturalearthdata",
    "rgeos"
  )

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, dependencies = T)
lapply(list.of.packages, require, character.only = T)
rm(list.of.packages, new.packages)

theme_set(theme_bw())

world <- ne_countries(scale = "medium", returnclass = "sf")
class(world)

#WHere are we centering? 
#center_tas <- c(-41.4545, 145.9707)

ggplot(data = world) +
  geom_sf(col="blue", fill="green") +
  coord_sf(xlim = c(140, 155), ylim = c(-35.5, -50), expand = FALSE) +
  geom_point(aes(x = 147, y = -42), size = 1) +
  theme_void()
###





#Plot sites on a shapefile
rgdal::readOGR(dsn = ".", "aust_cd66states") %>% 
  fortify() %>% 
  ggplot() +
  geom_path(aes(x = long, y = lat, group = group), color = 'darkgrey', size = .3) +
  geom_point(aes(x = rls_aus_geo$long, y = rls_aus_geo$latt), data = rls_aus_geo, size = (rls_aus_geo$species/30), color = rls_aus_geo$color) + 
  geom_point(aes(x = longLoc$long, y = longLoc$lat), data = longLoc, shape = 8, size = 2, color = "black") +
  geom_text(x=111.5, y=-30, label= "Jurien Bay", size = 4, fontface = 3) + 
  geom_text(x=154, y=-35, label= "Jervis Bay", size = 4, fontface = 3) + 
  geom_text(x=144, y=-37, label= "Port Phillip Bay", size = 4, fontface = 3) + 
  geom_text(x=151, y=-39, label= "Bass Strait", size = 4, fontface = 3) + 
  geom_text(x=151, y=-41.5, label= "Bicheno", size = 4, fontface = 3) + 
  geom_text(x=152, y=-42.8, label= "Maria Island", size = 4, fontface = 3) + 
  geom_text(x=152.7, y=-44, label= "Ninepin & Tinderbox", size = 4, fontface = 3) + 
  geom_text(x=142.5, y=-43, label= "Port Davey", size = 4, fontface = 3) + 
  ggtitle("Mean annual SST of each geographic cell (12 to 29)") + 
  xlab("Longitutde") + ylab("Latitude")


```


#### ###########

### MODEL SETUP ###

### Install mizer, load libraries 

```{r warning=F, message=FALSE, echo=T}
#rm(list=ls())
#library(devtools)
#install.packages(vegan)
#install_github("astaaudzi/mizer", ref = "rewire-temp")
library(mizerRewire)
library(tidyverse)

```

### Background spectra

The slope for the plankton spectrum is assumed to be 2.1. 
For the benthic spectrum I use AbNoUr <- 0.8 - 0.85*log10(InvDataBinned$wgtGroup) equation and calibrate the kappa to ensure initial abundances are within the range of observed abundances per m2 (Freddie's and Kate's data used to get equation, see above)
May2 optimisation: 
after optim parallel runs I still can't get Trachinops to exist and predators don't get enough food. Decreasing kappa_ben from 4 to 2 actually helps, predators grow better and there is more Trachinops (increasing kappa_ben makes things worse)

```{r warning=T, message=FALSE, echo=T}

#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

## resource params
kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
lambda = 2.15 #2.1 # 
w_pp_cutoff = 1 #g
r_pp = 1 #2 # rate of regeneration
min_w_pp = 1e-10 #g

kappa_ben = 6 #2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
w_bb_cutoff = 5 #
r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
min_w_bb = 0.001 # 0.01

kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
w_aa_cutoff = 50 
r_aa = 2 #1 #something to be calibrated
min_w_aa = 0.001

```

### Load saved params, if you have them

Here I load my saved parameter sets and initial abundances

```{r, warning=F, message=FALSE, echo=F, eval = T}

  load(file = "modelParams/mariaParamsMs.RData") #species parameter file 
  load(file = "modelParams/paramsMs.RData") #built params file
  load(file = "modelParams/inter_N19.RData") #interaction matrix (it is also included in the params file)
  # now load stable numbers at size for all species. I start the runs from equilibrium abundances 
  load(file = "modelParams/abund_N19.RData")
  load(file = "modelParams/npp_N19.RData")
  load(file = "modelParams/nbb_N19.RData")
  load(file = "modelParams/naa_N19.RData")
  
  ## data for invertebrate abundances
  load(file = "modelParams/BenticInvAbund_Tasm.RData")

  #load empirical size spectra in underwater visual survey length bins. Species are grouped as in model groups. Their length-weight conversion is included, and weights per size bins are also calculated. Not sure this is the best way to compare observed spectra to model spectra. Either way we need to bin model size spectra into similar bins. How? 
  load(file = "modelParams/empSizes.RData")

  ## earlier parameter rounds, where I was saving subsequent combinations
# runname <- "N19"
# 
# load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
# #write.csv(params@species_params, file = "mariaParams_N20.csv")
# load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
# 
# load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
# #write.csv(inter, file = "inter_N20.csv")
# 
# load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
# #write.csv(stable_abund, file = "stable_abund.N20")
# load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
# #write.csv(stable_pl, file = "stable_pl.csv")
# load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
# #write.csv(stable_ben, file = "stable_ben.csv")
# load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
# #write.csv(stable_alg, file = "stable_alg.csv")
# #and invert abundance data from surveys for the benthic spectrum
# load(file = "../inputs/benthos/BenticInvAbund_Tasm.RData")
# load(file = "../inputs/benthos/InvDataBinned.RData")

```

### Senescence mort functions and params 

Since May2 juvenile mortality is not used. Senescence morality is still used

```{r warning=T, message=FALSE, echo=T}

## Senescence

## function to set senescence mortality and add it on top of mu_b. The function needs mizer params object to be set up first to know the number of size classes. So I run MizerParams here, but can overwrite it later as long as no_w does not change

params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

#parameters for senescence mortality as used in Law et al. 2009
k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)

sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
  
  sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
  
  for (i in 1: length(sppParams$species)) {
    
    mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
    
    sen.mort.m[i,] <- mu_Sen    
  }

  # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
  sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
  return(sen.mort.m)
  
}

## Juvenile mort 

## I also add extra juvenile mortality, because in reality background spectrum species would be imposing mortality on tiny fish, yet we don't model it here. As a result mortality curves look bell-shaped when instead they should be exponential 

juv.sm <- 5 #10 #5 # mortality per year at threshold
juvsw <- 2 # Size of w_min at which mortality is at juv.sm. Note that at the moment w_min is setup at 5x the egg size. 
juv.e <- 0.3 #0.5 #exponent, larger values will give steeper decrease (orignal was 0.3, but it may be too slow decrease)

juv_mort = function(sppParams, params, juv.sm, juvsw, juv.e) {
  
  juv.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
  
  for (i in 1: length(sppParams$species)) {
    mu_Juv = juv.sm * 10^-(juv.e*(log(params@w) - log(juvsw*sppParams$w_min[i])))
    juv.mort.m[i,] <- mu_Juv
  }
  
  # It is most likely that for sharks or other species with large eggs (w_min of at least 1 gram), this early steep mortalit does not apply. So get rid of it
  juv.mort.m[which(params@species_params$w_min > 0.99),] <- 0
  
  return(juv.mort.m)
}

```

### ##########

### CALIBRATION 

### Calibrate benthic kappa

Mizer does not have defined units and can be calibrated for m3, m2 or the total model area. I am using measures per m2, because this is how RLS data is presented. 
AbNoUr <- 0.8 - 0.85*log10(InvDataBinned$wgtGroup)

```{r, eval = F}
#inferred observed abundance (on log10 scale from Kate's and Freddie's data)
#Data using the estimated regression slope
obsab <- 0.8 - 0.85*log10(params@w_full) ## expected abundance using the equation applied to the weight groups used in mizer

# Now we get model abundance per size class
#length(params@dw_full[c(min(which(params@w_full > min_w_bb)):max(which(params@w_full < w_bb_cutoff)))])
modbb <- log10(params@initial_n_bb * params@dw_full) 
modpl <- log10(params@initial_n_pp * params@dw_full)
modaa <- log10(params@initial_n_aa * params@dw_full)

plot(log10(params@w_full), obsab, type = 'l', lwd = 1.5, xlim = c(-6,2), ylim = c(-3, 5), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w_full), modbb, type = 'l', col = 'red')
points(log10(params@w_full),modpl, type = 'l', col = 'green')
points(log10(params@w_full),modaa, type = 'l', col = 'blue')
#abline(v = log10(0.05), lty = 2)
abline(v = log10(min_w_bb), lty =2)

```

Comment on the above: there is a big dip in the observed abundance data at around the size of 1g. This could be because the two methods used are just diverging on their sampling accuracy at this size or because at this size there is indeed a strong benthos depletion and a dip in the slope. I actually do get a dip at this point. The theoretical abundance at 1g would be 10individuals per m2, while we get less than 1 in observations. 

### Data files: DON'T RUN if loaded

For initial start of the calibration load your parameter files here. During the calibration I then save all params and initial abundances, and load them later. So this chunk is not needed. I use a scalar from observed abundances to rescale model default initial abundances, because they seem to be too far from the observations 

```{r warning=T, message=FALSE, echo=F, eval = F}

#mariaParams <- read.csv(file = "../modelParams/Tasm_parametersN18.csv") #16 species
mariaParams <- read.csv(file = "../modelParams/Tasm_paramsN19.csv") #16 species
#inter <- read.csv(file = "../modelParams/Tasm_interaction.csv") #16 species
inter <- read.csv(file = "../modelParams/Tasm_interN19.csv") #16 species
inter <- as.matrix(inter)

```

### Fixed params: DON'T RUN if loaded 

I am not optimising or exploring these much

```{r warning=T, message=FALSE, echo=T, eval = F}

#### egg size, rmax, exponents ####
mariaParams$w_min <- round(((0.0015* mariaParams$w_inf^0.14) *10),4)  # Barneche et al. 2018 equation for egg sizes, but let's start with at least 10 times bigger individuals, as they don't start feeding when they are eggs and we don't track the dynamics of early days very well
mariaParams$w_min[which(mariaParams$species == "C_laticeps")] <- 1  #assume that shark eggs are 5 grams?

mariaParams$w_min <- params@species_params$w_min

#scaling exponents. Who knows what they should be!! 
mariaParams$n <- 0.75 # maximum intake scaling, mizer default is 2/3, but the growth curves don't look so good
mariaParams$p <- 0.8 # metabolism scaling
mariaParams$q <- 0.75 # search rate scaling

#### h & ks  ####
# by default mizer will set  h values, calcualted as h = [3*k_vb/(alfa*f0)]*W_inf^(1/3)
# I use size dependent scaling, derived from earlier explorations based on daily consumption rates or minimum intake needed to get juvenile growth right
mariaParams$h = 50 * (mariaParams$w_inf/1000)^0.15

# then for herbivores, who have low assimilation efficiency, we triple the maximum intake rate (based on Graham Edgar daily intake calculations, ref in Soler et al. 2018)
mariaParams$h[which(mariaParams$funcgr == "herbi")] <- mariaParams$h[which(mariaParams$funcgr == "herbi")]*3
#See thoughts above on whether these values give reasonable estimates

#set size dependent ks based on my earlier explorations based on the DEB dataset. This is just a guess, but the key is that ks scales NEGATIVELY with w_inf (not positively as it is set in mizer)
mariaParams$ks <- 20*mariaParams$w_inf^(-0.25)
#however this relationship gives Trachinops (smallest planktivore) very high ks, so I decrease it. The relationship seems too steep for smallest species. Even though small species have high per unit body mass ks, this apppears much too high
mariaParams$ks[which(mariaParams$species == "T_caudimaculatus")] <- 4.5 #instead of 8 which this equation gives
#invertebrates are expected to have lower maintenance costs than fish, but urchin maintenance is very high. So I reduce it by 1.5
ksUrchinsOld <- mariaParams$ks[which(mariaParams$species == "urchins")]
mariaParams$ks[which(mariaParams$species == "urchins")] <- ksUrchinsOld/1.5
plot(mariaParams$w_inf, mariaParams$ks, pch = 19)

## Is ks for urchins too high? 
#which(mariaParams$species == "urchins")
#mariaParams$h[16]
# Let's assume they are are feeding at maximum possible rate
#energy <- (mariaParams$h[16]*mariaParams$w_mat[16]^mariaParams$n[16])*mariaParams$alpha[16]
#metab <- mariaParams$ks[16]*mariaParams$w_mat[16]^mariaParams$p[16]
#energy- metab # plenty of net energy left! So the value should be ok

### Background mortality 

#I am  using mizer default values for background mortality, as z0 = z0pre * w_inf ^ (n-1)
basic_z0 = mariaParams$z0pre * mariaParams$w_inf ^ (mariaParams$n -1 )
basic_z02 = 0.3 * mariaParams$w_inf ^ (mariaParams$n -1 )
## these mortality values seem too high when I ahve strong species interactions and pred mortality already. so i halve them
mariaParams$z0 <- basic_z0/2
#min(mariaParams$z0)


```

### Dynamic parameters(gamma, erepro, rmax): DON'T RUN if loaded 

These are to be explored

```{r warning=T, message=FALSE, echo=T, eval = F}

## Erepro 

# Initial erepro is set using a general approximation now but will be optimised later. This way the steady state optimiser finds values easier
#mariaParams$erepro <- 0.05 * mariaParams$w_inf^(-0.5)
#These are initial values but then they are tuned with steady()
#The equation above actually gives too low erepro values, so I start with 10x larger values
mariaParams$erepro <- 0.5 * mariaParams$w_inf^(-0.5)
#plot(mariaParams$w_inf, mariaParams$erepro)

## Gamma 

## In the MizerParams we asked mizer to set gamma's based on the defaults: 
## gamma = f0*h*beta^(2-lambda)/((1-f0)*2*3.14*kappa*sigma)
#since we use three background spectra I calculate mean lambda and kappa
mean_lam = mean(lambda, lambda_ben, lambda_alg)
mean_kappa = mean(kappa, kappa_ben, kappa_alg)

#as an initial setup we use default mizer gamma parameters, but note this is a very crude approximation because we have 3 size spectra and species have different access to these spectra
gammaDef = mariaParams$f0 *mariaParams$h*mariaParams$beta^(2-mean_lam)/((1-mariaParams$f0)*2*3.14*mean_kappa*mariaParams$sigma)

#for herbivores gamma values might need to be doubled
#gammaDef[which(mariaParams$funcgr == "herbi")] <- gammaDef[which(mariaParams$funcgr == "herbi")] *2

# for predators gamma values should be much higher or else they don't get enough food, because they generally search for food actively 
gammaDef[which(mariaParams$funcgr == "predat")] <- gammaDef[which(mariaParams$funcgr == "predat")] * 3

#And then total gamma is increased for all species, because they just don't need enough otherwise!!
mariaParams$gamma <- gammaDef * 3

#what is the area searched per day? Am I happy with it? Remember that this area should account for the fact that most of the time species hide and not search. so this is the actual active feeding per day
areaSearchedPerDay <- (mariaParams$gamma*mariaParams$w_mat^params@q)/365
areaSearchedPerDay

# R MAX and Q
basic_rmax = mean_kappa * mariaParams$w_inf^(-1.5) # if you are using r_max instead, here is Julia's formula for deep sea
# this rmax just gives extremely low relative abundances for the kappa values and they only eat background. Presumably these values give recruitment per m3 in pelagic ecosystems, while I have coastal areas and values per m2. So I convert the depth of say 500m to 1m2 and increase it further by 2 to account for higher coastal productivity. This gives a multiplier of 1000
#The values are further tuned 
mariaParams$r_max <- basic_rmax *1000
## for small pelagics the default value seems too high (and default abundance is far too high compared to the observations)
mariaParams$r_max[which(mariaParams$species == "T_caudimaculatus")] <- 0.5

#write.csv(mariaParams, file = "mariaParams_basic.csv")

```

### Initial abundance scalar: DON'T RUN if loaded

I want to calibrate initial model abundances with the relative abundances observed in the surveys (in the first 5 years), so that I at least start in the correct ballpark for relative abundances. For this I only use model abundances that are likely to be in the range observable by RLS divers, e.g. bigger than 4cm (the smallest size group is 2cm, but few individuals are observed in this group), or very roughly 1g

```{r warning=T, message=FALSE, echo=T, eval = F}

temp <- params@initial_n * params@dw * params@w #biomass 
initBiom <- apply(temp, 1, sum) # total biomass
initBiom[1] #wrasse
initBiom[3] #trachinops

temp_ben <- params@initial_n_bb * params@dw_full * params@w_full #biomass of benthos
initBiomBen <- sum(temp_ben)
initBiomBen

load(file = "../inputs/InvDataBinned.RData")
obsBenBio <- sum(InvDataBinned$bioPerm2[c(1:7)])
#obsBenBio <- 19

initBiomBen/obsBenBio  #initial benthos biomass is about 2 times bigger than observed

initBiom[1]/(mariaParams$BioM2[1]) #initial biomass of wrasse 158 times bigger than observed
initBiom[3]/(mariaParams$BioM2[3]) #for trachinops it is 40K times bigger than observed
obsBiom <- mariaParams$BioM2

#Now this is a scalar to modify initial densities while accounting for the match of observed vs modelled initial benthos densities. I will have to divide initial densities by this scalar
scalarForInitial <- (initBiom/obsBiom)/(initBiomBen/obsBenBio)
#tt <- round(as.vector(scalarForInitial),1)
mariaParams$initScalar <- round(as.vector(scalarForInitial),1)
#write.csv(mariaParams, file = "../modelParams/Tasm_paramsN19.csv")

```

### Interaction: DON'T RUN if loaded 

Four parameters to be optimised and explored here. Other values are set to 0.7 or 0. This is a tricky one, but with fewer species it should be easier 

```{r warning=T, message=FALSE, echo=T, eval = F}

availUr = 0.15 #urchins to fish
availUrLob = 0.55 #0.65 #Urchins to lobsters
availSchooling = 0.4# 0.45 #avaiability of schooling fish to predators
availTrach = 0.4 # 0.45 #avaiability of schooling fish to predators

# and overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availTrach
inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling

inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob


```

### Background availability: DON'T RUN if loaded

Eight parameters define this. It is important to explore these values, because if predators have too much access to background resource and the resource is abundant, they wont eat fish

```{r warning=T, message=FALSE, echo=T, eval = F}

availBenToPred <- 0.25
availBenToBen <- 0.7

availPlaToPred <- 0.15
availPlaToBen <- 0.2
availPlaToPla <- 0.8
availPlaToHer <- 0.2

availAlgToHer <- 0.7
availAlgToLea <- 0.02

mariaParams$avail_BB <- 0
mariaParams$avail_BB[which(mariaParams$funcgr == "predat")] <- availBenToPred
mariaParams$avail_BB[which(mariaParams$funcgr == "omni")] <- availBenToBen

mariaParams$avail_PP <- 0
mariaParams$avail_PP[which(mariaParams$funcgr == "predat")] <- availPlaToPred
mariaParams$avail_PP[which(mariaParams$funcgr == "omni")] <- availPlaToBen
mariaParams$avail_PP[which(mariaParams$funcgr == "plankt")] <- availPlaToPla
mariaParams$avail_PP[which(mariaParams$funcgr == "herbi")] <- availPlaToHer

mariaParams$avail_AA <- 0
mariaParams$avail_AA[which(mariaParams$funcgr == "herbi")] <- availAlgToHer
mariaParams$avail_AA[which(mariaParams$species == "leather_cool")] <- availAlgToLea
mariaParams$avail_AA[which(mariaParams$species == "M_freycineti")] <- availAlgToLea

```

#### ###########
### SEQUENTIAL NUDGING

### Steady state to get erepro

Now I get erepro to approximately reasonable values, they will be tuned later. Make sure initial abundances are in the right ballpark

```{r warning=T, message=FALSE, echo=T, eval = F}

### setup  
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

#update initial abundances

params@initial_n <- params@initial_n/mariaParams$initScalar
#params@initial_n <- params@initial_n*init_scalar

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## find a steady state by modifying erepro
stedTas <- steady(params, t_max = 300) #t_max gives the number of interations needed 

#plot erepro values and check if they are realistic 
plot(log(stedTas@species_params$w_inf), stedTas@species_params$erepro, xlab = 'log w_inf', ylab = 'erepro', pch = 19)

#just output the values
round(stedTas@species_params$erepro,5)

mariaParams$erepro <- round(stedTas@species_params$erepro,5)

```

### Tune Rmax   

This is a fancy "sequencial nudging" algorithm! :) However at least for me, if I start with values that are not too far off, it seems to work. At each iteration you see the plot and relative abundances, and if some species are just getting worse at each step, then you will need to stop the run and explore options manually for that species. Why is it crashing? 

First tune Rmax by slightly modifying starting Rmax values for species that are lower than 0.7, 0.3 and 0.1 of the relative observed biomass, or higher than 1.2, 1.5 and 1.8. These are just arbitrary values, set your own. 
Make sure intial abundances are scaled with your scalar or some saved stable abundances

```{r warning=FALSE, message=FALSE, echo=T}

## setup an array 
rmaxarr <- matrix(nrow = 100, ncol = 23) # this will save values at each iteration to explore them further if needed
rmaxarr[1,c(1:17)] <- mariaParams$r_max # initial r_max value

for (i in 2:100) {

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- params@initial_n/mariaParams$initScalar

#now that I have saved abundances from earlier tuned runs I use them to overwrite initial abundances
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)

plot(tasm1)

#getBiomass(tasm1)[tmax,]
#(getBiomass(tasm1)[tmax,]*10)/mariaParams$BioM2

relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
relbio

tinyhigherrmax <- which(relbio < 0.8)
print(tinyhigherrmax)
mariaParams$r_max[c(tinyhigherrmax)] <- mariaParams$r_max[c(tinyhigherrmax)] * 1.1

higherrmax <- which(relbio < 0.3)
print(higherrmax)
mariaParams$r_max[c(higherrmax)] <- mariaParams$r_max[c(higherrmax)] * 1.1

muchhigherrmax <- which(relbio < 0.1)
print(muchhigherrmax)
mariaParams$r_max[c(muchhigherrmax)] <- mariaParams$r_max[c(muchhigherrmax)] * 1.2


tinylowerrmax <- which(relbio > 1.2)
print(tinylowerrmax)
mariaParams$r_max[c(tinylowerrmax)] <- mariaParams$r_max[c(tinylowerrmax)] / 1.1

lowerrmax <- which(relbio > 1.5)
print(lowerrmax)
mariaParams$r_max[c(lowerrmax)] <- mariaParams$r_max[c(lowerrmax)] / 1.1

muchlowerrmax <- which(relbio > 1.8)
print(muchlowerrmax)
mariaParams$r_max[c(muchlowerrmax)] <- mariaParams$r_max[c(muchlowerrmax)] / 1.2

ba <- length(tinyhigherrmax) + length(tinylowerrmax)
print('tiny higher and lower')
print(ba)

ca <- length(higherrmax) + length(lowerrmax)
print('higher and lower')
print(ca)

da <- length(muchhigherrmax) + length(muchlowerrmax)
print('much higher and much lower')
print(da)

relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
print(relbio)

rmaxarr[i,c(1:17)] <- mariaParams$r_max
rmaxarr[i,18] <- length(tinyhigherrmax)
rmaxarr[i,19] <- length(higherrmax)
rmaxarr[i,20] <- length(muchhigherrmax)
rmaxarr[i,21] <- length(tinylowerrmax)
rmaxarr[i,22] <- length(lowerrmax)
rmaxarr[i,23] <- length(muchlowerrmax)

aa = ba+ca+da

if (aa == 0) {
        print("finished adjusting")
        break
      }


}

#save(rmaxarr, file = "RmaxArray_redAlg_incrBen.RData")

```

### Save abundances to update intial abundances

```{r}
stable_abund <- tasm1@n[tmax,,]
stable_pl <- tasm1@n_pp[tmax,]
stable_ben <- tasm1@n_bb[tmax,]
stable_alg <- tasm1@n_aa[tmax,]

```

### Tune erepro 1: all species at a time

Next, tune erepro to the desired level of density dependence. We do need some level of DD and it seems ratio of RDD/rmax = 0.9-0.97 might give reasonable relatively strong species interactions (where RDI/RDD = 10 or 20), although Ken thinks it should be much higher (RDI/RDD at 100)

```{r}
## setup an array 
topvalue = 0.98
bottomvalue = 0.85

erepro_arr <- matrix(nrow = 100, ncol = 23)
erepro_arr[1,c(1:17)] <- mariaParams$erepro # initial r_max value

for (i in 2:100) {

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)

plot(tasm1)

model <- tasm1
a2 <- getRDD(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], sex_ratio = 0.5, model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD to rmax ratio
rmaxratio <- round (a2/mariaParams$r_max,4)

## I want the rmax ratio to be between 0.85 and 0.95 

#if rmax ratio is lower than 0.4, I need to increase erepro
tinyhigher <- which(rmaxratio < bottomvalue)
print(tinyhigher)
mariaParams$erepro[c(tinyhigher)] <- mariaParams$erepro[c(tinyhigher)] * 1.1

higher <- which(rmaxratio < (bottomvalue - 0.1))
print(higher)
mariaParams$erepro[c(higher)] <- mariaParams$erepro[c(higher)] * 1.1

muchhigher <- which(rmaxratio < (bottomvalue - 0.2))
print(muchhigher)
mariaParams$erepro[c(muchhigher)] <- mariaParams$erepro[c(muchhigher)] * 1.2

## if rmax ratio is higher than 0.8, I need to decrease erepro 

tinylower <- which(rmaxratio > topvalue)
print(tinylower)
mariaParams$erepro[c(tinylower)] <- mariaParams$erepro[c(tinylower)] / 1.05

lower <- which(rmaxratio > (topvalue+0.02))
print(lower)
mariaParams$erepro[c(lower)] <- mariaParams$erepro[c(lower)] / 1.05

muchlower <- which(rmaxratio > (topvalue+0.04))
print(muchlower)
mariaParams$erepro[c(muchlower)] <- mariaParams$erepro[c(muchlower)] / 1.05

ba <- length(tinyhigher) + length(tinylower)
print('tiny higher and lower')
print(ba)

ca <- length(higher) + length(lower)
print('higher and lower')
print(ca)

da <- length(muchhigher) + length(muchlower)
print('much higher and much lower')
print(da)

erepro_arr[i,c(1:17)] <- mariaParams$erepro
erepro_arr[i,18] <- length(tinyhigher)
erepro_arr[i,19] <- length(higher)
erepro_arr[i,20] <- length(muchhigher)
erepro_arr[i,21] <- length(tinylower)
erepro_arr[i,22] <- length(lower)
erepro_arr[i,23] <- length(muchlower)

print(rmaxratio)
relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
print(relbio)

aa = ba+ca+da

if (aa == 0) {
        print("finished adjusting")
        break
      }


}

#save(erepro_arr, file = "ereproTune_May7.RData")

```

### Tune erepro 2: one spp at a time, assumptions 

This part is essential to assess species interactions. Now we fish one species at a time and see how that will affect the community. 

```{r}

## Here are my assumption about the sensitivity to fishing

sensitivity <- c("medium", "high", "low", "low", "medium", "medium", "high", "high", "low", "high", "medium", "medium", "medium", "medium", "high", "low", "medium")
mariaParams$sensitivity <- sensitivity

sensitivity <- mariaParams$sensitivity

exp.biom.decrease.min <- rep(NA, 17)
exp.biom.decrease.max <- rep(NA, 17)

fish.mort <- 0.2 ## for this fishing mortality I expect below levels of biomass decrease

exp.biom.decrease.min[which(sensitivity == "low")] <- 0.2
exp.biom.decrease.min[which(sensitivity == "medium")] <- 0.3
exp.biom.decrease.min[which(sensitivity == "high")] <- 0.5

exp.biom.decrease.max[which(sensitivity == "low")] <- 0.4
exp.biom.decrease.max[which(sensitivity == "medium")] <- 0.5
exp.biom.decrease.max[which(sensitivity == "high")] <- 0.75
```

### Tune erepro 2: one spp at a time, run 

```{r}

#Which species do you want to tune? Enter the number here
spptune <- which(mariaParams$species == species[13])
print(mariaParams$species[spptune])
print(mariaParams$sensitivity[spptune])

erepro_vec <- rep(NA, 100)
erepro_vec[1] <- mariaParams$erepro[spptune] # initial r_max value

tmax = 150

eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
dimnames(eff_arr) = list (rowtest, params@species_params$gear)
eff_arr[,spptune] <- fish.mort

for (i in 2:100) {
  print(i)

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
#params@initial_n <- params@initial_n*init_scalar

params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  
tasm1ef1 <- project(params, t_max = tmax, effort=eff_arr, dt = 0.2, diet_steps = 0)  
#plot(tasm1ef1)

bio.decrease <- 1- round(getBiomass(tasm1ef1)[tmax,spptune]/getBiomass(tasm1)[tmax,spptune],5)

#if the decrease in biomass is lower than the expected decrease the erepro is too high, spp recovers too fast
print(bio.decrease)

if (bio.decrease < exp.biom.decrease.min[spptune]) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]/1.05
  print("decreased erepro by 1.05")
}

if (bio.decrease < (exp.biom.decrease.min[spptune]/2)) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]/1.05
  print("decreased erepro by another 1.05")
}

##
if (bio.decrease > exp.biom.decrease.max[spptune]) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]*1.05
  print("increased erepro by 1.05 ")
}

if (bio.decrease > (exp.biom.decrease.max[spptune]*1.5)) {
  mariaParams$erepro[spptune] <- mariaParams$erepro[spptune]*1.05
  print("increased erepro by another 1.05")
}

erepro_vec[i] <- mariaParams$erepro[spptune]
print("erepro now is")
print(mariaParams$erepro[spptune])

if (bio.decrease  < exp.biom.decrease.max[spptune] & bio.decrease > exp.biom.decrease.min[spptune]) {
  print("finished adjusting")
  break
}

}

```

### Tune daily intake with gamma 

I want daily intake to be around 4% of body weight for small fish and ca 1% for adults

```{r}
## setup an array 
gamma_arr <- matrix(nrow = 100, ncol = 21)
gamma_arr[1,c(1:17)] <- mariaParams$gamma # initial r_max value

diettime <- tmax # year to get diet
no_pred <- length(model@params@species_params$species)
no_prey <- length(model@params@species_params$species) + 3
tmax = 150
#which size class corresponds to ca 1g
onegsize <- max(which(params@w < 1)) + 1
## herbivores are expected to consume 3x higher daily intake as proportion of their body weight. So create an adjustment vector to tune all gamma at once
adj_vector <- rep(1,17)
adj_vector[which(mariaParams$funcgr == "herbi")] <- 3
## small species also would consume relatively higher proportion of their body weight when they are (small) adults compared to big species, so adjust those as well 
adj_vector[which(mariaParams$w_inf < 100)] <- 2
## relative intake for inverebrates is higher, so adjust urchins even more (allow adult urchins to have higher intake than normal fish herbivores)
adj_vector[which(mariaParams$species == "urchins")] <- 4

for (i in 2:100) {

### setup again with new erepro
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
#plot(tasm1)

#simulation name

model <- tasm1 

### Consumption as a proportion of weight

cons_juv <- as.numeric(vector())
cons_ad <- as.numeric(vector())

diet2 <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = F)

  for (ab in 1:no_pred) {
    #mean juvenile feeding level at the last time step. Same for adults below
    matsize <- max(which(params@w < model@params@species_params$w_mat[ab]))
    maxsize <- max(which(params@w < model@params@species_params$w_inf[ab]))
    
    temp <- diet2[ab,,]
    tot.diet <- round(apply(temp, 1, sum),4)
    prop_cons <- ((tot.diet/model@params@w)/365)*100

    #mean juvenile feeding level at the last time step. Same for adults below
    juv_cons <- round(mean(prop_cons[c(onegsize:matsize)]), 3)
    ad_cons <- round(mean(prop_cons[c((matsize+1):maxsize)]), 3)
    cons_juv <- c(cons_juv, juv_cons)
    cons_ad <- c(cons_ad, ad_cons)

  }

cons_juv <- round(cons_juv/adj_vector,3)
cons_ad <- round(cons_ad/adj_vector,3)

## Now tune adult consumption and hopefully juvenile consumption will fix itself 
## I want adult daily intake to be between 0.5 and 1% of body weight 
# If daily intake is < 0.5% of body weight I want to increase gamma a bit
#tinyhigher <- which(cons_ad < 0.5)
#print(tinyhigher)
#mariaParams$gamma[c(tinyhigher)] <- mariaParams$gamma[c(tinyhigher)] * 1.01

higher <- which(cons_ad < 0.4)
print(higher)
mariaParams$gamma[c(higher)] <- mariaParams$gamma[c(higher)] * 1.03

#tinylower <- which(cons_ad > 1)
#print(tinylower)
#mariaParams$gamma[c(tinylower)] <- mariaParams$gamma[c(tinylower)] / 1.01

lower <- which(cons_ad > 1.2)
print(lower)
mariaParams$gamma[c(lower)] <- mariaParams$gamma[c(lower)] / 1.03


#aa <- length(tinyhigher) + length(tinylower)
#print('tiny higher and lower')
#print(aa)

aa <- length(higher) + length(lower)
print('higher and lower')
print(aa)
print(cons_ad)
relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
print("relative biomass")
print(relbio)

gamma_arr[i,c(1:17)] <- mariaParams$gamma
#gamma_arr[i,18] <- length(tinyhigher)
gamma_arr[i,19] <- length(higher)
#gamma_arr[i,20] <- length(tinylower)
gamma_arr[i,21] <- length(lower)

if (aa == 0) {
        print("finished adjusting")
        break
      }
}


```

### Save

```{r}
runname <- "N19" #November 19, with fixed initial abundances

save(mariaParams, file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
save(params, file = paste("../modelParams/params_", runname, ".RData", sep = ""))
save(inter, file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
stable_abund <- tasm1@n[tmax,,]
stable_pl <- tasm1@n_pp[tmax,]
stable_ben <- tasm1@n_bb[tmax,]
stable_alg <- tasm1@n_aa[tmax,]
save(stable_abund, file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
save(stable_pl, file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
save(stable_ben, file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
save(stable_alg, file = paste("../modelParams/naa_", runname, ".RData", sep = ""))

```

### ###########
### MAIN RUNS

### Basic run

```{r warning=FALSE, message=FALSE, echo=T}

### setup 
params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg
## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- mizerRewire::project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 2)
plot(tasm1)

#getBiomass(tasm1)[tmax,]

relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
relbio

obsInvAb <- sum(InvData$meanAb[which(InvData$wgt > min_w_bb & InvData$wgt < w_bb_cutoff)])
modelInvAb <- sum(tasm1@n_bb[tmax,]*params@dw_full)
#ratio of model vs observed inv abundances (benthic spectrum) in the relevant range
modelInvAb/obsInvAb

```

### Run with fishing   

Here is an important test of the model!! Are species able to sustain small amounts of fishing? If RDI/RDD is too low, then some species will start going extinct even with low fishing

```{r warning=FALSE, message=FALSE, echo=T}

#now run with some fishing mortality (equal to all)
tmax = tmax
#tasm1 <- project(params, t_max = tmax, effort=0, dt = 0.2, diet_steps = 0)  

tasm1ef <- project(params, t_max = tmax, effort=0.2, dt = 0.2, diet_steps = 0)  
plot(tasm1ef)

getBiomass(tasm1ef)[mean((tmax-10):tmax),]/getBiomass(tasm1)[tmax,]

getBiomass(tasm1ef)[mean((tmax-10):tmax),]

#plotDietComp(tasm1ef)
```

### Fish one species in a loop

This part is essential to assess species interactions. Now we fish one species at a time and see how that will affect the community. How do we visualise the output matrix?

```{r, eval = F}
tmax = tmax
fish.mort <- 0.2

relbiomFishOne <- data.frame()

for (i in 1:length(params@species_params$species)) {

#set up the effort array
eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
dimnames(eff_arr) = list (rowtest, params@species_params$gear)
eff_arr[,i] <- fish.mort

#run the model with fishing using previously set params set
tasm1ef1 <- project(params, t_max = tmax, effort=eff_arr, dt = 0.2, diet_steps = 0)  
plot(tasm1ef1)

print(round(getBiomass(tasm1ef1)[tmax,]/getBiomass(tasm1)[tmax,],5))

temp <- round(getBiomass(tasm1ef1)[tmax,]/getBiomass(tasm1)[tmax,],5)
relbiomFishOne <- rbind(relbiomFishOne, temp)

}

colnames(relbiomFishOne) <- params@species_params$species #biomasses of species as you fish species in rows
rownames(relbiomFishOne) <- paste("fish_",params@species_params$species, sep="")

#save(relbiomFishOne, file = "../outputs/FishOneSppBiom_Nov20.RData")

knitr::kable(relbiomFishOne, digits = 2)

#look at how each species responds to its own fishing
responseToF <- diag(as.matrix(relbiomFishOne))
which(responseToF < 0.4)

## explore correlations among species, etc
## Look if biomass of one species (T_caudimaculatus in my case) is strongly correlated to other species
#cor_Tra <- rep(NA, 17)
#p_Tra <- rep(NA, 17)

#for (i in 1:length(params@species_params$species)) {
#onesp <- relbiomFishOne[,i]
#temp <- cor.test(relbiomFishOne$T_caudimaculatus, onesp)
#cor_Tra[i] <- temp$statistic
#p_Tra[i] <- round(temp$p.value,5)
#}
#trach_inter <- cbind(as.character(mariaParams$species), round(cor_Tra,3), round(p_Tra,4))  


```

Now if interactions are too strong or some species are too much or too little sensitive to fishing we might want to tune this by modifying erepro of one species 

### Diet 
Why doesn't the plot work from mizer??? 

#Function
```{r}

 plotDiet <- function(object, diettime = tmax) {
  model <- object
  diet <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = T)
  prey <- dimnames(diet)$prey
  predator <- dimnames(diet)$predator
  prey <- factor(prey, levels = rev(prey))
  predator <- factor(predator, levels = (predator))
  w.temp = rep(params@w, each = length(predator))
  w = rep(w.temp, times = length(prey))
  plot_dat <- data.frame(
    Proportion = c(diet),
    w = w,
    Prey = rep(prey, each = (length(params@w)*length(predator))),
#    Predator = rep(predator, each = (length(params@w)*length(prey))))
    Predator = rep(predator))
  plot_dat <- plot_dat[plot_dat$Proportion > 0, ]
#  colorvalues <- c(params@linecolour[c(1:length(params@species_params$species))])
#  colorvalues <- c(colorvalues,"green","brown","yellow")
  ggplot(plot_dat) +
    geom_area(aes(x = w, y = Proportion, fill = Prey)) +
    facet_wrap(~ Predator, ncol=5) +
    scale_x_log10() +
    labs(x = "Size [g]") 
}

```

```{r}

diettime <- tmax # year to get diet
model <- tasm1 #simulation name

## diet function can give output as proportion or as total consumed weight, depending on the "proportion" parameter
diet <- getDiet(params,model@n[diettime,,],model@n_pp[diettime,], model@n_bb[diettime,], model@n_aa[diettime,], proportion = T)

#Plot diet  
plotDiet(tasm1, diettime = tmax)

plotPPMR(tasm1) #plot realised PPMR - this is also a function Jon wrote and they are now all incorporated into rewire-temp


#I want my large predators to eath fish!
# which size class to check the diets for (500g for example)
dietsize = max(which(params@w < 1000))
#sppdiet <- round(diet[,dietsize,],3)

# or just look at one species
round(diet[which(mariaParams$species == "Notolabrus"),dietsize,],3)
round(diet[which(mariaParams$species == "D_lewini"),dietsize,],3)
round(diet[which(mariaParams$species == "predator"),dietsize,],3)
round(diet[which(mariaParams$species == "lobsters"),dietsize,],3)
round(diet[which(mariaParams$species == "L_forsteri"),dietsize,],3)
round(diet[which(mariaParams$species == "leather_cool"),dietsize,],3)
round(diet[which(mariaParams$species == "M_freycineti"),dietsize,],3)
#round(diet[which(mariaParams$species == "urchins"),dietsize,],3)

dietsize = max(which(params@w < 100))
#Alternatively look who eats certain species
diet[,dietsize,which(mariaParams$species == "T_caudimaculatus")]
diet[,dietsize,which(mariaParams$species == "C_rasor")]
diet[,dietsize,which(mariaParams$species == "P_laticlavius")]
diet[,dietsize,which(mariaParams$species == "Notolabrus")]
diet[,dietsize,which(mariaParams$species == "urchins")]


```

### Get FMSY
F and max sustain yield should be at around 0.2 if no other info is available (higher for small species). If it is too low it means reproduction is not fast enough, and we need to increase RDI/RDD ratio or decrease linear dependence on stock biomass. 
This takes a while to run!

NOTE: THE run is saved, so make sure to load the file rather than run everything again 

```{r}
#might beed to run it for longer for biomasses to stabilise
tmax = 200
yield_final <- data.frame()
eff_vector1 = seq(from = 0.01, to = 0.09, by = 0.01)
eff_vector2 = seq(from = 0.1, to = 0.2, by = 0.02)
eff_vector3 = seq(from = 0.25, to = 0.7, by = 0.05)
eff_vector = c(eff_vector1, eff_vector2, eff_vector3)

for (i in 1:length(eff_vector)) {
  print("eff_number")
  print(i)
  yield_array <- as.data.frame(matrix(ncol = 17, nrow = tmax))
  colnames(yield_array) <- mariaParams$species
  
  eff.now <- eff_vector[i]
  yield_array$fishing <- eff.now
  yield_array$year <- c(1:tmax)
  
  for (b in 1:length(mariaParams$species)) {
    print("sp_no")
    print(b)
    #Setup effort array
    eff_arr = array(0, dim = c(tmax,17))
    rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
    dimnames(eff_arr) = list (rowtest, params@species_params$gear)
    eff_arr[,b] <- eff.now
    
    tasm1ef <- project(params, t_max = tmax, effort=eff_arr, dt = 0.2, diet_steps = 0)
    yield <- getYield(tasm1ef)
    yield_array[,b] <- yield[,b]
    
  }
  
  yield_final <- rbind(yield_final, yield_array)   
  
}   

save(yield_final, file = "../outputs/yield001to07.RData")
```

something does not work here, need to check:
```{r}
## check if yields have stabilised for a given fishing level
load(file = "../outputs/yield001to07_lessDD.RData")

#which(yield_final$fishing == 0.2)
#test <- yield_final[-c(4001:4250),] #0.2 mort was used two times so remove some rows
#test2 <- test[-c(2251:2500),]

oneeffort <- yield_final %>% filter (fishing == 0.2) ## decide which fishign level to use
par(mfrow = c(4,5), mar = c(1,1,1,1))

for (i in 1:length(mariaParams$species)) {
  onespp <- oneeffort[,i]
  plot(x = c(1:length(onespp)), y = onespp, type= 'l', ylim = c(0, max(onespp)))
}

yieldF <- yield_final %>% filter (year == tmax)  

## get the actual F at max yield
fmsy = rep(NA, length(mariaParams$species))

for (i in 1:length(mariaParams$species)) {
  
fmsy[i] <- yieldF$fishing[which(yieldF[,i] == max(yieldF[,i]))]
}

MaxYield <- list()
MaxYield$fmsy <- as.vector(fmsy)
MaxYield$species <- as.character(mariaParams$species)
MaxYield$erepro <- round(mariaParams$erepro,3)
MaxYield <- as.data.frame(MaxYield)

write.csv(MaxYield, file = "../outputs/Fmsy.csv")

```

### Growth curves    

Plot and check individual growth curves. Note that the reference curves are based on vb_k and Linf, and vb_k is a highly uncertain parameter for many species. So black refrence curves are not good in many species. 

```{r warning=FALSE, message=FALSE, echo=T}
tasm1 <- tasm1

#All species
plotGrowthCurves(tasm1, percentage = T)



#Individual species 
plotGrowthCurves(tasm1, species = params@species_params$species[3], max_age = 10, percentage = F)

max_age = c(15, 20, 10, 10, 10, 6, 80, 40, 5, 20, 10, 15, 10, 10, 20, 10, 20)

par(mfrow = c(4,5))

## growth curves
for (i in 1:17) {
  
  plotGrowthCurves(tasm1, species = params@species_params$species[i], max_age = max_age[i], percentage = F)

}

```

#Plot all sizespectra at a chosen time

```{r warning=FALSE, message=FALSE, echo=T}
par(mfrow = c(1,1), mar = c(4,4,4,4))

tplot = 150 #which time to plot

model <- tasm1

#plot size spectra
plot(log10(model@params@w_full), log10(model@n_pp[tplot,]*params@dw_full), type = 'l', ylim = c(-10,10), xlim = c(-5,5),lwd = 2, xlab = 'size, g', ylab = 'abundance')
points(log10(model@params@w_full), log10(model@n_bb[tplot,]*params@dw_full), type = 'l', lwd = 2, col = 'red')
points(log10(model@params@w_full), log10(model@n_aa[tplot,]*params@dw_full), type = 'l', lwd = 1, col = 'green')

for (i in 1: length(params@species_params$species)) {
  points(log10(model@params@w), log10(model@n[tplot,i,]*params@dw), type = 'l')
  
}

ppatmat = log10(mariaParams$w_mat/mariaParams$beta) # prefered prey size at predators maturation size
abline(v = c(ppatmat), lty = 2, col = 'grey')

abline(v = log10(mariaParams$w_mat), lty = 2, col = 'yellow')

```

### Backgr mort: functions 

```{r}
## need to pass functions separately

getBenthosMort <- function(object, n, n_pp, n_bb, n_aa, intakeScalar,
             pred_rate = getPredRate(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar)) {
    temp <- matrix(object@species_params$avail_BB, nrow = 1, ncol = length(object@species_params$avail_BB), byrow = T)
    m2_benthos <- temp %*% pred_rate
    return(m2_benthos)
}


getPlanktonMort <- function(object, n, n_pp, n_bb, n_aa, intakeScalar,
             pred_rate = getPredRate(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar)) {

    temp <- matrix(object@species_params$avail_PP, nrow = 1, ncol = length(object@species_params$avail_PP), byrow = T)
    m2_plankton <- temp %*% pred_rate

    return(m2_plankton)
}

getAlgalMort <- 
  function(object, n, n_pp, n_bb, n_aa, intakeScalar,
           pred_rate = getPredRate(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar)) {
        temp <- matrix(object@species_params$avail_AA, nrow = 1, ncol = length(object@species_params$avail_AA), byrow = T)
    m2_algae <- temp %*% pred_rate
    
    return(m2_algae)
  }
```

### Benthos mort

```{r}
tasm1 <- tasm1 #put your model name here
params <- params
tmax <- tmax #time to plot

## Benthos 
#get ranges for plotting 
w_full_bb <- params@w_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
#dw_full_bb <- params@dw_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]

## to run the line below you need to run the functions in the chunk above!
ben_mort <- getBenthosMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

ben_mort <- getBenthosMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

#only get relevant size ranges
ben_mort <- ben_mort[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]

#plot
plot(log(w_full), ben_mort, type = 'l', lwd = 2, main = "Inst benthos mortality rate per year", xlab = "log size, g", ylab = "mortality 1/years")
```

### Plankton mort 

```{r}
tasm1 <- tasm1 #put your model name here
params <- params
tmax <- tmax #time to plot

#get ranges for plotting 
w_full_pp <- params@w_full[which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
#dw_full_pp <- params@dw_full[which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]

pla_mort <- getPlanktonMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

#only get relevant size ranges
pla_mort <- pla_mort[which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]

#plot
plot(log(w_full_pp), pla_mort, type = 'l', lwd = 2, main = "Inst plankton mortality rate per year", xlab = "log size, g", ylab = "mortality 1/years")
```


### Algal mort

```{r}
tasm1 <- tasm1 #put your model name here
params <- params
tmax <- tmax #time to plot

#get ranges for plotting 
w_full_aa <- params@w_full[which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]

alg_mort <- getAlgalMort(params, n = tasm1@n[tmax,,], n_pp = tasm1@n_pp[tmax,],n_bb = tasm1@n_bb[tmax,],n_aa = tasm1@n_aa[tmax,],intakeScalar = tasm1@intTempScalar[,,(tmax/dt)])

#only get relevant size ranges
alg_mort <- alg_mort[which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]

#plot
plot(log(w_full_aa), alg_mort, type = 'l', lwd = 2, main = "Inst algal mortality rate per year", xlab = "log size, g", ylab = "mortality 1/years")


```

### starv mort function

```{r}

getSMort <- function(object, n, n_pp, n_bb, n_aa, intakeScalar, metScalar,
                     e = getEReproAndGrowth(object, n = n, n_pp = n_pp, n_bb = n_bb, n_aa = n_aa, intakeScalar = intakeScalar, metScalar = metScalar)){

            if (!all(dim(e) == c(nrow(object@species_params), length(object@w)))) {
              stop("e argument must have dimensions: no. species (",
                   nrow(object@species_params), ") x no. size bins (",
                   length(object@w), ")")
            }

        mu_S <- e # assign net energy to the initial starvation mortality matrix

        #x_old <- t(t(mu_S)/(0.1*object@w)) # apply the mortality formula to the whole matrix
        #print (dim(x_old))
        #print(x_old[c(3:6, 50:60)])
        #remember, 0.1 is a parameter here, which is a scaling constant on how negative e translates to starvation mortality. For a 100g fish with a negative e of -1, it will give starvation value of 0.1. For a 10 g fish with e of -1, it will give mortality of 1. This seems reasonable for a start, but a more conmplex relationship could be explored in the future 
        ### TODO ### a small value added here to avoid division by zero, but not sure this is ideal
        x <- t(t(mu_S)/((1/(object@c+1e-12))*object@w))
        #print (dim(x))
        #print(x[c(3:6, 50:60)])
        mu_S[mu_S<0] <- x[x<0] # replace the negative values of e by the starvation mortality
        mu_S[mu_S>0] <- 0 # replace the positive values of e by 0

        mu_S = - mu_S # this returns negative mortality values, because negative e is divided by weight. So to get the actual mortality we turn them into positive values 
        #comment to test
    return(mu_S)
}

```

### Predation mort proportion: TODO

```{r}
sim <- tasm1

final_time_idx <- dim(sim@n)[[1]]
n <- sim@n[final_time_idx, , ]
n_pp <- sim@n_pp[final_time_idx, ]
n_bb <- sim@n_bb[final_time_idx, ]
n_aa <- sim@n_aa[final_time_idx, ]

#test <- getPredMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)])

total_pred_mort <- rowSums(getPredMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)]) * n)
total_starv_mort <- rowSums(getSMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)], metScalar = sim@metTempScalar[,,(final_time_idx/dt)]) * n)

total_mort <- rowSums(getMort(sim@params, n, n_pp, n_bb, n_aa, intakeScalar = sim@intTempScalar[,,(final_time_idx/dt)], morScalar = sim@morTempScalar[,,(final_time_idx/dt)], metScalar = sim@metTempScalar[,,(final_time_idx/dt)], effort = 0) * n)

total_mort <- rowSums(getMort(sim@params, n, n_pp) * n)
proportion <- total_pred_mort / total_mort
st_proportion <- total_starv_mort / total_mort


```



### Background depletion 

In the stabilised set of parameters, where initial abundances are set from final abundances the depletion is of course 1, because everything is stable 

```{r warning=FALSE, message=FALSE, echo=T}

model <- tasm1

smallcut <- max(which(model@params@w_full < min_w_bb)) +1
largecut <- min(which(model@params@w_full > w_bb_cutoff)) -1

largecutP <- min(which(model@params@w_full > w_pp_cutoff)) -1

smallcutA <- max(which(model@params@w_full < min_w_aa)) +1
largecutA <- min(which(model@params@w_full > w_aa_cutoff)) -1

plot(log10(model@params@w_full[c(smallcut:largecut)]), (model@n_bb[tmax,c(smallcut:largecut)]/model@n_bb[1,c(smallcut:largecut)]),ylim = c(0,1.5), xlim = c( log10(model@params@w_full[1]), log(model@params@w_full[largecutA])), type = 'l', col = 'red', xlab = "log weight,g", ylab = "depletion compared to initial abundance", main = "Depletion of plankton, benthos(red) and algae(green)")
points(log10(model@params@w_full[c(1:largecutP)]), (model@n_pp[tmax,c(1:largecutP)]/model@n_pp[1,c(1:largecutP)]),type = 'l', col = 'black')
points(log10(model@params@w_full[c(smallcutA:largecutA)]), (model@n_aa[tmax,c(smallcutA:largecutA)]/model@n_aa[1,c(smallcutA:largecutA)]),type = 'l', col = 'green')


```

### Get RDD/rmax

This tells you where the species are on their rmax level, but I found that this is not necessarily an indication of their sensitivity to fishing...

```{r warning=FALSE, message=FALSE, echo=T}

#Check where they are at rmax level
tmax =tmax
model <- tasm1

a1 <- getRDI(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD 
a2 <- getRDD(params,model@n[tmax,,],model@n_pp[tmax,], model@n_bb[tmax,], model@n_aa[tmax,], sex_ratio = 0.5, model@intTempScalar[,,(tmax/dt)], model@metTempScalar[,,(tmax/dt)])

#get RDD to rmax ratio
rmaxratio <- a2/mariaParams$r_max
#plot(rmaxratio)
round(rmaxratio,4)
round(a1/a2, 4)


```

### Sp params

Write species params for the publication 

```{r}
para <- params@species_params

sppPprint <- para %>% select(species, w_inf, w_min, w_mat, beta, sigma, avail_PP, avail_BB, avail_AA, r_max, erepro, gamma, ks, h, z0)

sppPprint[,10] <- round(sppPprint[,10],5)
sppPprint[,11] <- round(sppPprint[,11],4)
sppPprint[,c(12:14)] <- round(sppPprint[,c(12:14)],2)
sppPprint[,15] <- round(sppPprint[,15],3)

write.csv(sppPprint, file = "../suplTables/TableSppParams2.csv")


```

##### ###########
#### ABC

### ABC first round on clusters

Run lots of combinations and only save relative biomass

```{r, eval = F}
#rm(list=ls())
#library(devtools)
#install.packages(vegan)
#library(vegan)
#install_github("astaaudzi/mizer", ref = "rewire-temp")
library(mizer, lib.loc = "/home/astaa/R/x86_64-pc-linux-gnu-library/3.5")
library(future.apply)
#library(furrr)
plan(multiprocess)

abcres <- function(...)  {
  
  # Load parameter files to initialise the runs. Presumably they will be available to all cores and I don't need to do it inside the function 
  runname <- "N19"
  load(file = paste("mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("params_", runname, ".RData", sep = ""))
  load(file = paste("inter_", runname, ".RData", sep = ""))
  load(file = paste("abund_", runname, ".RData", sep = ""))
  load(file = paste("npp_", runname, ".RData", sep = ""))
  load(file = paste("nbb_", runname, ".RData", sep = ""))
  load(file = paste("naa_", runname, ".RData", sep = ""))
  
  ## These are global variables, can they be loaded here, rather than inside the function? 
  #global initial parameter values which will be multiplied by random vectors at each iteration
  availUr = 0.15 #urchins to fish
  availUrLob = 0.55 #0.65 #Urchins to lobsters
  availSchooling = 0.4# 0.45 #avaiability of schooling fish to predators
  
  rmax_basic <- mariaParams$r_max
  gamma_basic <- mariaParams$gamma
  inter_basic <- c(availUr, availUrLob, availSchooling)
  
  init_params <- c(rmax_basic, gamma_basic, inter_basic)
  
  ## setup run time 
  tmax = 150
  #number of size groups 
  no_size_groups = 200
  #timestep used in the integration 
  dt = 0.5
  
  ## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
  
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
  ## Now the main analysis
  
  #random multiplier of initial rmax values
  multipl.1 <- runif(n = 17, min = 0.8, max = 1.2)
  
  rmax <- rmax_basic * multipl.1  
  mariaParams$r_max <- rmax
  
  ##random multiplier of initial gamma values
  multipl.2 <- runif(n = 17, min = 0.8, max = 1.2)
  gamma <- gamma_basic * multipl.2
  mariaParams$gamma <- gamma
  
  #random multiplier of initial interaction values
  multipl.3 <- runif(n = 3, min = 0.8, max = 1.2)
  availUr <- round((inter_basic[1] * multipl.3[1]),3)
  availUrLob <- round((inter_basic[2] * multipl.3[2]),3)
  availSchooling <- round((inter_basic[3] * multipl.3[3]),3)
  
  # and overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  
  #get relative biomasses
  relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
  
  inter_new <- c(availUr, availUrLob, availSchooling)
  
  ## write down current param values
  param_values <- as.numeric(c(mariaParams$r_max, mariaParams$gamma, inter_new))
  
  #report results
  result_values <- as.numeric(round(relbio, 4))
  
  ## now fish everything at 0.2
  #tasm1ef <- project(params, t_max = tmax, effort= 0.2, dt = dt)
  #get relative fished versus unfished biomass 
  #fishbiom <- getBiomass(tasm1ef)[tmax,]/getBiomass(tasm1)[tmax,]
  #report results 
  #result_values <- c(result_values, as.numeric(round(fishbiom, 4)))
  
  abcresult <- c(param_values, result_values)
  return(abcresult)
  
}

iter <- 200000

set.seed(123)

abc1 <- future_lapply(seq_len(iter), abcres, future.seed = TRUE)

#future_map(iter, abcres, .progress = TRUE)

saveRDS(abc1, file = "abc1.rds")

```

### Analyse ABC first round 

from the 2.2mln combinations select those that have 4x times bigger or smaller relative biomass

```{r}
#load the file
#First run with narrower "priors"
#load(file = "../ABCruns/ABCNov16.RData")
## These are multiplied by 20% (0.8-1.2)
load(file = "../ABCruns/ABC1_new_N20.RData") ## new run, 200K, no fishing
load(file = "../ABCruns/ABC2_new_N20.RData") ## new run, 200K, no fishing
ABC20p <- rbind(ab1, ab2) #400K
rm(ab1, ab2)

#These are multiplied by 40% (0.6-1.4)
load(file = "../ABCruns/ABC1_wider.RData") ## 200K
ABC40p <- abw1

## Now I have 1.6mln runs with 0.5-2x multiplier on rmax, gamma and inter
load(file = "../ABCruns/ABCTwice.RData")
load(file = "../ABCruns/ABCTwice2.RData") 
ABC100p <- rbind(abcTwice, abcTwice2) 
rm(abcTwice, abcTwice2)

#ABCresult <- abw1
#param_values <- as.numeric(c(mariaParams$r_max, mariaParams$gamma, inter_new))
#result_values <- as.numeric(round(relbio, 4))
#result_values <- c(result_values, as.numeric(round(fishbiom, 4)))
#abcresult <- c(param_values, result_values)


#name columns 
cc1 <- paste("rmax", mariaParams$species, sep="_")
cc2 <- paste("gamma", mariaParams$species, sep="_")
cc3 <- c("availUr", "availUrLob", "availSch")
#cc4 <- c("lambda", "lambda_ben", "lambda_alg")
cc5 <- paste("relbiom", mariaParams$species, sep="_")
#cc6 <- paste("fishedbiom", mariaParams$species, sep="_")

#column <- c(cc1, cc2, cc3, cc4, cc5, cc6)
#column <- c(cc1, cc2, cc3, cc4, cc5)
column <- c(cc1, cc2, cc3, cc5)


#colnames(abw1) <- column


## Fix relative biomasses relative to the new relative biomasses

## The runs reported relative biomases based on all scaled biomasses
#relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
#mariaParamsGood <- mariaParams
#load(file = "../ABCruns/mariaParams_BEST_N.RData")
#scaledAbOld <-mariaParams$scaledBio
#scaledAbNew <- mariaParamsGood$scaledBio
#temp1 <- as.matrix(ABCresult[,c(38:54)])
#correction <- function(x){
#  (x*scaledAbOld)/scaledAbNew
#}
#test <- t(apply(temp1,1,correction))
#ABCresult[,c(38:54)] <- test

###
#for 20% variation out of 400K I have 42K of 0.5-2x relative biomasses, for 0.4-2.5 there are 135K; for 0.33-3x biomass - 209K cases
#for 40% variation out of 200K I have 49 cases; for 0.4-2.5 there are 718 cases, for 0.33-3x there are 3623 cases
#for 100% variation out of 1.6mln I have 0 cases, for 0.4-2.5 there are 32 cases; for 0.33-3x biomass there are 307 cases


#ABCresult <- ABC20p
ABCresult <- rbind(ABC20p, ABC40p, ABC100p)
colnames(ABCresult) <- column
#save(ABCresult, file = "../ABCruns/abc_firstRound.RData")
#initialise result columns for the first criterion: relative biomass
ABCresult$reject <- 0
ABCresult$temp <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.25
upper.rel.abun <- 4

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp <- which(ABCresult[,(i+ 37)] < lower.rel.abun  | ABCresult[,(i + 37)] > upper.rel.abun) #38 is the first column of results
  ABCresult$temp[temp] <- 1
  ABCresult$reject <- ABCresult$reject + ABCresult$temp
}

accepted.result <- ABCresult[which(ABCresult$reject == 0),]
save(accepted.result, file = "accepted.RData")
test <- accepted.result[c(200001:287490),c(1:37)]

#save(test, file = "accepted5.RData")

load(file = "../ABCruns/accepted.RData")


write.csv(accepted.result[c(100001:200000),c(1:37)], file = "accept2.csv")
accept.save <- accepted.result[c(100001:200000),c(1:37)]
save(accept.save, file = "accep2.RData", version = 2)

#Get original values
runname <- "N19"
load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
#load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))

rmax_orig <- mariaParams$r_max
gamma_orig <- mariaParams$gamma
inter_orig <- c(0.15,0.55,0.4)
#  availUr = 0.15 #urchins to fish
#  availUrLob = 0.55 #0.65 #Urchins to lobsters
#  availSchooling = 0.4# 0.45 #avaiability of schooling fish to predators

## now plot rmax values  
rmaxplot <- accepted.result[,c(1:17)] #just select first 17 rmax variables
gammaplot <- accepted.result[,c(18:34)] #just select second 17 gamma variables
interplot <- accepted.result[,c(35:37)] #select inter variables
#lambdaplot <- accepted.result[,c(38:40)] #select inter variables

## plot rmax

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(rmaxplot[,i], breaks = 50, col = "grey", xlim = c((min(rmaxplot[,i])- mean(rmaxplot[,i])/2), (max(rmaxplot[,i])+ (mean(rmaxplot[,i])/2))), main = colnames(rmaxplot)[i])
  abline(v = rmax_orig[i], lwd = 2, col = 'red')
  abline (v  = (rmax_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (rmax_orig[i]*2), lty =2, col = 'red')
  abline (v  = (rmax_orig[i]*0.6), lty =2, col = 'blue')
  abline (v  = (rmax_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (rmax_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (rmax_orig[i]*1.2), lty =2, col = 'green')
}

#plot gamma

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(gammaplot[,i], breaks = 50, col = "grey", xlim = c((min(gammaplot[,i])- mean(gammaplot[,i])/2), (max(gammaplot[,i])+ (mean(gammaplot[,i])/2))), main = colnames(gammaplot)[i])
  abline(v = gamma_orig[i], lwd = 2, col = 'red')
  abline (v  = (gamma_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (gamma_orig[i]*2), lty =2, col = 'red')
  abline (v  = (gamma_orig[i]*0.6), lty =2, col = 'blue')
  abline (v  = (gamma_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (gamma_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (gamma_orig[i]*1.2), lty =2, col = 'green')
}

#inter plot 
par(mfrow = c(1,3), mar = c(3,3,3,3))

for (i in 1:3) {
  
  hist(interplot[,i], breaks = 50, col = "grey", xlim = c((min(interplot[,i])- mean(interplot[,i])/2), (max(interplot[,i])+ (mean(interplot[,i])/2))), main = colnames(interplot)[i])
  abline(v = inter_orig[i], lwd = 2, col = 'red')
  abline (v  = (inter_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (inter_orig[i]*2), lty =2, col = 'red')
  abline (v  = (inter_orig[i]*0.6), lty =2, col = 'blue')
  abline (v  = (inter_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (inter_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (inter_orig[i]*1.2), lty =2, col = 'green')
}


#lambda plot 
par(mfrow = c(1,3), mar = c(3,3,3,3))

for (i in 1:3) {
  
  hist(lambdaplot[,i], breaks = 15, col = "grey", xlim = c((min(lambdaplot[,i])- mean(lambdaplot[,i])/4), (max(lambdaplot[,i])+ (mean(lambdaplot[,i])/4))), main = colnames(lambdaplot)[i])
  abline(v = lambda_orig[i], lwd = 2, col = 'red')
  abline (v  = (lambda_orig[i]*0.9), lty =2, col = 'red')
  abline (v  = (lambda_orig[i]*1.1), lty =2, col = 'red')
}

save(accepted.result, file = "acceptedABC1150values.RData")
save(values, file = "originalABCvalues.RData")
```

### ABC second round on clusters

Run 287K selected param combinations but this time run more scenarios with each and get more data (diets, fishing response)
 
```{r, eval = F}
#rm(list=ls())
#library(devtools)
#install.packages(vegan)
#library(vegan)
#install_github("astaaudzi/mizer", ref = "rewire-temp")
library(mizer, lib.loc = "/home/astaa/R/x86_64-pc-linux-gnu-library/3.5")
library(future.apply)
#library(furrr)
plan(multiprocess)

abcres <- function(iter)  {
  
  # Load parameter files to initialise the runs. Presumably they will be available to all cores and I don't need to do it inside the function 
  runname <- "N19"
  load(file = paste("mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("params_", runname, ".RData", sep = ""))
  load(file = paste("inter_", runname, ".RData", sep = ""))
  load(file = paste("abund_", runname, ".RData", sep = ""))
  load(file = paste("npp_", runname, ".RData", sep = ""))
  load(file = paste("nbb_", runname, ".RData", sep = ""))
  load(file = paste("naa_", runname, ".RData", sep = ""))
  load(file = "accepted1.RData")
  
  
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  ## setup run time 
  tmax = 150
  #number of size groups 
  no_size_groups = 200
  #timestep used in the integration 
  dt = 0.5
  #
  fish.mort = 0.2
  
  
  ## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
  
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
  ## Now the main analysis
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  #get relative biomasses
  unfishedBio <- getBiomass(tasm1)[tmax,]
  
  #get diet 
  ## diet function can give output as proportion or as total consumed weight, depending on the "proportion" parameter
  diet <- getDiet(params,tasm1@n[tmax,,],tasm1@n_pp[tmax,], tasm1@n_bb[tmax,], tasm1@n_aa[tmax,], proportion = T)
  
  #I want my large predators to eath fish! So I get diet at 2/3 of the maximum size
  size <- mariaParams$w_inf[which(mariaParams$species == "predator")]*0.66
  PredDiet <- as.numeric(round(diet[which(mariaParams$species == "predator"),max(which(params@w < size)),],3))
  PredF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "predator"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "lobsters")]*0.66
  LobsDiet <- as.numeric(round(diet[which(mariaParams$species == "lobsters"),max(which(params@w < size)),],3))
  LobsF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "lobsters"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "D_lewini")]*0.66
  LewiDiet <- as.numeric(round(diet[which(mariaParams$species == "D_lewini"),max(which(params@w < size)),],3))
  LewiF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "D_lewini"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "Notolabrus")]*0.66
  NotoDiet <- as.numeric(round(diet[which(mariaParams$species == "Notolabrus"),max(which(params@w < size)),],3))
  NotoF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "Notolabrus"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "urchins")]*0.66
  UrcDiet <- as.numeric(round(diet[which(mariaParams$species == "urchins"),max(which(params@w < size)),],3))
  UrcF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "urchins"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "T_caudimaculatus")]*0.66
  TrachDiet <- as.numeric(round(diet[which(mariaParams$species == "T_caudimaculatus"),max(which(params@w < size)),],3))
  TrachF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "T_caudimaculatus"),max(which(params@w < size))],3))
  
  size <- mariaParams$w_inf[which(mariaParams$species == "C_rasor")]*0.66
  RasoDiet <- as.numeric(round(diet[which(mariaParams$species == "C_rasor"),max(which(params@w < size)),],3))
  RasoF <- as.numeric(round(getFeedingLevel(tasm1)[tmax,which(mariaParams$species == "C_rasor"),max(which(params@w < size))],3))
  
  Diets <- c(PredDiet, LobsDiet, LewiDiet, NotoDiet, UrcDiet, TrachDiet, RasoDiet) #140 values
  FeedLevel <- c(PredF, LobsF, LewiF, NotoF, UrcF, TrachF, RasoF)
  
  #run with fishing 
  tasm1 <- project(params, t_max = tmax, effort=0.2, dt = dt)  
  fishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only predator
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "predator")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  PredfishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only lobsters
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "lobsters")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  LobsfishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only urchins
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "urchins")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  UrchfishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  ## fish only Trachinops
  eff_arr = array(0, dim = c(tmax,length(params@species_params$species)))
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  eff_arr[,which(params@species_params$species == "T_caudimaculatus")] <- fish.mort
  tasm1 <- project(params, t_max = tmax, effort=eff_arr, dt = dt, diet_steps = 0)
  TrafishedBio <- getBiomass(tasm1)[mean((tmax-10):tmax),]
  
  results <- c(unfishedBio, Diets, FeedLevel, fishedBio, PredfishedBio, LobsfishedBio, UrchfishedBio, TrafishedBio)
  #report results
  result_values <- as.numeric(round(results, 4))
  
  return(result_values)
  
}

iter <- 100000

set.seed(123)

abc1 <- future_lapply(seq_len(iter), abcres, future.seed = TRUE)

#future_map(iter, abcres, .progress = TRUE)

saveRDS(abc1, file = "abc1.rds")

```

### ABC2: load and prepare

```{r}

#load the file
#First run with narrower "priors"
#load(file = "../ABCruns/ABCNov16.RData")
## These are multiplied by 20% (0.8-1.2)
load(file = "../ABCruns/abc_secondRound.RData") ## new run, 200K, no fishing = results
load(file = "../ABCruns/accepted.RData") ## parameters

#This is how results were saved
#Diets <- c(PredDiet, LobsDiet, LewiDiet, NotoDiet, UrcDiet, TrachDiet, RasoDiet) #140 values
#FeedLevel <- c(PredF, LobsF, LewiF, NotoF, UrcF, TrachF, RasoF)
#results <- c(unfishedBio, Diets, FeedLevel, fishedBio, PredfishedBio, LobsfishedBio, UrchfishedBio, TrafishedBio)

#And here are params values
cc1p <- paste("rmax", mariaParams$species, sep="_")
cc2p <- paste("gamma", mariaParams$species, sep="_")
cc3p <- c("availUr", "availUrLob", "availSch")
ccP <- c(cc1p, cc2p, cc3p)
params <- accepted.result[,c(1:37)]

abc_second <- cbind(abc_second, params)

#name columns of results - there are lots of them!
 
cc1 <- paste("unfBio", mariaParams$species, sep="_")
cc2 <- c(paste("PredDiet", mariaParams$species, sep="_"),paste("PredDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc3 <- c(paste("LobsDiet", mariaParams$species, sep="_"),paste("LobsDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc4 <- c(paste("LewiDiet", mariaParams$species, sep="_"),paste("LewiDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc5 <- c(paste("NotoDiet", mariaParams$species, sep="_"),paste("NotoDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc6 <- c(paste("UrcDiet", mariaParams$species, sep="_"),paste("UrcDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc7 <- c(paste("TrachDiet", mariaParams$species, sep="_"),paste("TrachDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc8 <- c(paste("RasoDiet", mariaParams$species, sep="_"),paste("RasoDiet", c("plankton", "benthos", "algae"), sep = "_"))
cc9 <- c("PredF", "LobsF", "LewiF", "NotoF", "UrcF", "TrachF", "RasoF")
cc10 <- paste("fishAllBio", mariaParams$species, sep="_")
cc11 <- paste("PredFishBio", mariaParams$species, sep="_")
cc12 <- paste("LobsFishBio", mariaParams$species, sep="_")
cc13 <- paste("UrchFishBio", mariaParams$species, sep="_")
cc14 <- paste("TraFishBio", mariaParams$species, sep="_")

#combine all columns names (including param names at the end)
column <- c(cc1, cc2, cc3, cc4, cc5, cc6, cc7, cc8, cc9, cc10, cc11, cc12, cc13, cc14, ccP)
#clear environment
rm(cc1, cc2, cc3, cc4, cc5, cc6, cc7, cc8, cc9, cc10, cc11, cc12, cc13, cc14, cc1p, cc2p, cc3p, ccP, params)

colnames(abc_second) <- column
#save(abc_second, file = "../ABCruns/abc_secondNamed.RData")
#save(column, file = "../ABCruns/colnames.RData")

```

### ABC2: lobster fishing response

Second, response to fishing lobsters 
 
```{r}
load(file = "../ABCruns/abc_secondNamed.RData")
load(file = "../ABCruns/colnames.RData")
#first generate a matrix of relative biomasses 

#overwirte the file so I can use the same code
#abc_second <- abc_second_afterPredF
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = dim(abc_second)[1], ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "LobsFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
breaks <- seq(from = 0, to = 5, by = 0.1)
breaks <- c(breaks, 10, 50, 100, 500)

for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,5))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.33
upper.rel.abun <- 3

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodLobsFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeLobsF <- abc_second
abc_second <- abc_second[goodLobsFish,]

```


### ABC2: urchin fishing response

Third, response to fishing urchins 
 
```{r}
#overwirte the file so I can use the same code
#abc_second <- abc_second_afterLobsF
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = dim(abc_second)[1], ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "UrchFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
breaks <- seq(from = 0, to = 2, by = 0.1)
breaks <- c(breaks, 3, 5, 10, 50, 100, 500)

for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,2))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits. Since response to urchin fishing is not so huge, we narrow down these limits
lower.rel.abun <- 0.67
upper.rel.abun <- 1.5

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodUrchFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeUrchF <- abc_second
abc_second <- abc_second[goodUrchFish,]

```

### ABC2: predator fishing response

Screen results in successive importance. First, response to fishing a predator 
 
```{r}
#abc_second <- abc_second_relbioUnf
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = length(abc_second[,1]), ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "PredFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
#these are just breaks for histogram plots
breaks <- seq(from = 0, to = 3, by = 0.1)
breaks <- c(breaks, 10, 50, 100, 500)

## get relative biomases when fishing predator (column ff+i) compared to unfished biomases (in column i)
for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,3))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.25
upper.rel.abun <- 2

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodPredFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeFishPred <- abc_second
abc_second <- abc_second[goodPredFish,]

```

### ABC2: trachinops fishing response

```{r}
#overwirte the file so I can use the same code
#abc_second <- abc_second_afterUrchF
dim(abc_second)

#first generate a matrix of relative biomasses 
relativeBiomsPredF <- matrix(nrow = dim(abc_second)[1], ncol = 17)

#unfished biomases are in columns 1 to 17; which columns are specific fished biomases (in the same order); subtract one so I can loop through species
ff <- as.numeric(which(column == "TraFishBio_Notolabrus")) - 1 
par(mfrow = c(4,5))
breaks <- seq(from = 0, to = 3, by = 0.1)
breaks <- c(breaks, 5, 10, 50, 100, 500)

for (i in 1:length(mariaParams$species)) {
  temp <- abc_second[,(ff+i)]/abc_second[,i] 
  hist(temp, breaks = breaks, main = mariaParams$species[i], xlim = c(0,2))
  relativeBiomsPredF[,i] <- temp
}

relativeBiomsPredF <- as.data.frame(relativeBiomsPredF)
colnames(relativeBiomsPredF) <- as.character(mariaParams$species)

##
relativeBiomsPredF$temp <- 0
relativeBiomsPredF$reject <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits. Since response to urchin fishing is not so huge, we narrow down these limits
lower.rel.abun <- 0.67
upper.rel.abun <- 1.5

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp.1 <- which(relativeBiomsPredF[,i] < lower.rel.abun  | relativeBiomsPredF[,i] > upper.rel.abun) #38 is the first column of results
  relativeBiomsPredF$temp[temp.1] <- 1
  relativeBiomsPredF$reject <- relativeBiomsPredF$reject + relativeBiomsPredF$temp
}

length(which(relativeBiomsPredF$reject == 0))
goodTrachFish <- which(relativeBiomsPredF$reject == 0)

accept_PredFish <- relativeBiomsPredF[which(relativeBiomsPredF$reject == 0),]

#plot responses of accepted parameter sets
par(mfrow = c(4,5))

for (i in 1:17) {
  hist(accept_PredFish[,i], breaks = 50, main = mariaParams$species[i])
}  

abc_second_beforeTrachF <- abc_second
abc_second <- abc_second[goodTrachFish,]

```

### ABC2: feeding level
we are now working with a much reduced set of parameters 

```{r}
#abc_second <- abc_second_afterTrachF
dim(abc_second)
par(mfrow = c(2,4))
#First explore various outputs 
#ranges of predator feeding level at 66% of Winf
hist(abc_second$PredF, breaks = 50)
#same for lobster
hist(abc_second$LobsF, breaks = 50)
#same for D lewini
hist(abc_second$LewiF, breaks = 50)
#same for Notolabrus
hist(abc_second$NotoF, breaks = 50)
#same for urchins
hist(abc_second$UrcF, breaks = 50)
#same for Trachinops
hist(abc_second$TrachF, breaks = 50)
#same for Caesioperca
hist(abc_second$RasoF, breaks = 50)

## first only use feeding level criterion (don't use lobsters as they always feed well)
#THis was used for the first 194 params
#length(which(abc_second$PredF > 0.6 & abc_second$LobsF > 0.6 & abc_second$LewiF > 0.6 & abc_second$NotoF > 0.50 #& abc_second$TrachF > 0.45 & abc_second$RasoF > 0.4))

length(which(abc_second$PredF > 0.55 & abc_second$LobsF > 0.55 & abc_second$LewiF > 0.55 & abc_second$NotoF > 0.55 & abc_second$TrachF > 0.5 & abc_second$PredF < 0.8 & abc_second$LobsF < 0.8 & abc_second$LewiF < 0.8 & abc_second$NotoF < 0.8 & abc_second$TrachF < 0.8))

#we save a vector of accepted values
goodfeed <- which(abc_second$PredF > 0.55 & abc_second$LobsF > 0.55 & abc_second$LewiF > 0.55 & abc_second$NotoF > 0.55 & abc_second$TrachF > 0.5 & abc_second$PredF < 0.8 & abc_second$LobsF < 0.8 & abc_second$LewiF < 0.8 & abc_second$NotoF < 0.8 & abc_second$TrachF < 0.8)

abc_second_beforeFeed <- abc_second
abc_second <- abc_second_beforeFeed[goodfeed,]

```

### ABC2: diets

Continue screening 

```{r}
## Now let's look at the proportion of benthos in various species diets (at 66% of max size)
par(mfrow = c(2,3))
#Pred, Lobs, Urch, Noto, Lewi, Trach, Raso
hist(abc_second$LewiDiet_benthos, breaks = 50)
hist(abc_second$PredDiet_benthos, breaks = 50)
hist(abc_second$LobsDiet_benthos, breaks = 50)
hist(abc_second$NotoDiet_benthos, breaks = 50)

par(mfrow = c(2,3))
## Or proportion of plankton
hist(abc_second$UrcDiet_plankton, breaks = 50)
hist(abc_second$LewiDiet_plankton, breaks = 50)
hist(abc_second$PredDiet_plankton, breaks = 50)
hist(abc_second$LobsDiet_plankton, breaks = 50)
hist(abc_second$TrachDiet_plankton, breaks = 50)
hist(abc_second$RasoDiet_plankton, breaks = 50)
## It all looks reasonable

par(mfrow = c(2,3))
## Lobsters shoudl eat urchins and fish
hist(abc_second$LobsDiet_urchins, breaks = 50)
hist(abc_second$LobsDiet_Notolabrus, breaks = 50)
hist(abc_second$LobsDiet_T_caudimaculatus, breaks = 50)
hist(abc_second$LobsDiet_D_lewini, breaks = 50)
hist(abc_second$LobsDiet_C_rasor, breaks = 50)
hist(abc_second$LobsDiet_leatherjack, breaks = 50)
## it all looks reasonable, don't want to restrict it without data

par(mfrow = c(2,2))
## who eats urchins?
hist(abc_second$LobsDiet_urchins, breaks = 50)
hist(abc_second$NotoDiet_urchins, breaks = 50)
hist(abc_second$PredDiet_urchins, breaks = 50)
hist(abc_second$LewiDiet_urchins, breaks = 50)
#we don't want predators to each that many urchins, max proportion at 0.3 or 0.25

par(mfrow = c(2,3))
## most diet of Lewini should consist of small pelagics I suppose
hist(abc_second$LewiDiet_T_caudimaculatus, breaks = 50)
hist(abc_second$LewiDiet_Notolabrus, breaks = 50)
hist(abc_second$LewiDiet_C_rasor, breaks = 50)
hist(abc_second$LewiDiet_P_laticlavius, breaks = 50)
hist(abc_second$LewiDiet_D_lewini, breaks = 50)
hist(abc_second$LewiDiet_leatherjack, breaks = 50)
#this looks reasonable

#criteria limiting consumption of benthos and urchins, and predator consumption of pelagics
#This was the original 194
#length(which(abc_second$PredDiet_benthos < 0.15 & abc_second$NotoDiet_benthos > 0.75 & abc_second$LewiDiet_urchins < 0.15 & abc_second$PredDiet_urchins < 0.3 & abc_second$LobsDiet_urchins > 0.3 & abc_second$LewiDiet_T_caudimaculatus > 0.10))

#Just restrict predators from eating too many urchins
length(which(abc_second$LewiDiet_urchins < 0.10 & abc_second$PredDiet_urchins < 0.20))

gooddiet <- which(abc_second$LewiDiet_urchins < 0.1 & abc_second$PredDiet_urchins < 0.2)

abc_second_beforeDiet <- abc_second
abc_second <- abc_second_beforeDiet[gooddiet,]

```

### ABC2: relative biomases 

```{r}


BiomsNoFish <- abc_second[,c(1:17)]

relative <- function(x){
  x/mariaParams$BioM2
}

RelativeBiomsNoFish <- as.data.frame(t(apply(BiomsNoFish,1,relative)))

RelativeBiomsNoFish$reject <- 0
RelativeBiomsNoFish$temp <- 0

#  I want to reject all results where relative abundance at the end of the run are outside the limits
lower.rel.abun <- 0.5
upper.rel.abun <- 2

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  
  temp <- which(RelativeBiomsNoFish[,i] < lower.rel.abun  | RelativeBiomsNoFish[,i] > upper.rel.abun) 
  RelativeBiomsNoFish$temp[temp] <- 1
  RelativeBiomsNoFish$reject <- RelativeBiomsNoFish$reject + RelativeBiomsNoFish$temp
}

length(which(RelativeBiomsNoFish$reject == 0))
goodBiomass <- which(relativeBiomsPredF$reject == 0)


#abc_second_relbioUnf <- abc_second[which(RelativeBiomsNoFish$reject == 0),]

abc_second_beforeRelBiom <- abc_second
abc_second <- abc_second[which(RelativeBiomsNoFish$reject == 0),]
dim(abc_second)

```

### Final ABC2 set

```{r}
ff <- which(column == "rmax_Notolabrus")
rmaxplot <- abc_second[,c(ff:(ff+16))] #just select rmax variables

ff <- which(column == "gamma_Notolabrus")
gammaplot <- abc_second[,c(ff:(ff+16))] # gamma variables

ff <- which(column == "availUr")
interplot <- abc_second[,c(ff:(ff+2))] #select inter variables

## plot rmax
rmax_orig <- mariaParams$r_max

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(rmaxplot[,i], breaks = 50, col = "grey", xlim = c((min(rmaxplot[,i])- mean(rmaxplot[,i])/2), (max(rmaxplot[,i])+ (mean(rmaxplot[,i])/2))), main = colnames(rmaxplot)[i])
  abline(v = rmax_orig[i], lwd = 2, col = 'red')
  abline (v  = (rmax_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (rmax_orig[i]*2), lty =2, col = 'red')
#  abline (v  = (rmax_orig[i]*0.6), lty =2, col = 'blue')
#  abline (v  = (rmax_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (rmax_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (rmax_orig[i]*1.2), lty =2, col = 'green')
}

#plot gamma
gamma_orig <- mariaParams$gamma

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(gammaplot[,i], breaks = 50, col = "grey", xlim = c((min(gammaplot[,i])- mean(gammaplot[,i])/2), (max(gammaplot[,i])+ (mean(gammaplot[,i])/2))), main = colnames(gammaplot)[i])
  abline(v = gamma_orig[i], lwd = 2, col = 'red')
  abline (v  = (gamma_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (gamma_orig[i]*2), lty =2, col = 'red')
#  abline (v  = (gamma_orig[i]*0.6), lty =2, col = 'blue')
#  abline (v  = (gamma_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (gamma_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (gamma_orig[i]*1.2), lty =2, col = 'green')
}

#inter plot 
inter_orig <- c(0.15, 0.55, 0.4)

par(mfrow = c(1,3), mar = c(3,3,3,3))

for (i in 1:3) {
  
  hist(interplot[,i], breaks = 50, col = "grey", xlim = c((min(interplot[,i])- mean(interplot[,i])/2), (max(interplot[,i])+ (mean(interplot[,i])/2))), main = colnames(interplot)[i])
  abline(v = inter_orig[i], lwd = 2, col = 'red')
  abline (v  = (inter_orig[i]*0.5), lty =2, col = 'red')
  abline (v  = (inter_orig[i]*2), lty =2, col = 'red')
#  abline (v  = (inter_orig[i]*0.6), lty =2, col = 'blue')
#  abline (v  = (inter_orig[i]*1.4), lty =2, col = 'blue')
  abline (v  = (inter_orig[i]*0.8), lty =2, col = 'green')
  abline (v  = (inter_orig[i]*1.2), lty =2, col = 'green')
}

## save the selected file with outputs and params
save(abc_second, file = "../ABCruns/acceptedSecond28ms.RData")

## save only the params
ff <- which(column == "rmax_Notolabrus")
#params194 <- abc_second[,c(ff:dim(abc_second)[2])]
#save(params194, file = "../modelParams/params194.RData")

params28 <- abc_second[,c(ff:dim(abc_second)[2])]

#add original params 
origParams <- c(params@species_params$r_max, params@species_params$gamma, inter_orig)
params28 <- rbind(origParams, params28)

save(params28, file = "../modelParams/params28ms.RData")

```

### ########
### FOOD SCENARIOS

### backgr params

```{r}
## resource params
kappa = 2  # intercept assuming g/m2
lambda = 2.15 
r_pp = 1 #rate of regeneration

kappa_ben = 6 #intercept assuming g/m2  
lambda_ben = 1.9 # 1.9 is baseline!
r_bb = 1 # something to be calibrated. Default mizer option is 10

kappa_alg = 16  #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
r_aa = 2 #something to be calibrated

### setup initial theoretical slopes
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

```


### Calibrate benthic spectrum abundance

Mizer does not have defined units and can be calibrated for m3, m2 or the total model area. I am using measures per m2, because this is how RLS data is presented. 
AbNoUr <- 0.8 - 0.9*log10(InvDataBinned$wgtGroup)

    res@rr_bb[] <- r_bb * res@w_full^(n - 1) # weight specific benthos growth rate
    res@cc_bb[] <- kappa_ben *res@w_full^(-lambda_ben) # benthos carrying capacity
    res@cc_bb[res@w_full > w_bb_cutoff] <- 0  # set density of sizes < benthic cutoff size
    res@cc_bb[res@w_full < min_w_bb] <- 0 #set density of sizes < min size of benthos ##AAdec
    res@initial_n_bb <- res@cc_bb  # put this as initial density
    
     # Dynamics of benthic spectrum uses a semi-chemostat model 
    # currently it follows exactly the same rules as plankton but has it's own parameters
        tmp <- (sim@params@rr_bb * sim@params@cc_bb / (sim@params@rr_bb + m2_benthos))
        n_bb <- tmp - (tmp - n_bb) * exp(-(sim@params@rr_bb + m2_benthos) * dt)
        n_bb[sim@params@initial_n_bb == 0] <- 0 # destroy what's below (and above) threshold sizes
 
1. The model is initialised using background spectra from equilibrium conditions; using theoretically expected initial abundance of background spectra leads the same results as the simulations converge on the same solution within about 50 years. So the model outptus are not sensitive to the initial background spectra abudnaces. This is because at each time step background regenerates towards the theoretical expectation set by the kappa and lambda parameters. The regeneration rate is set by r_bb and can vary from 1 used in this model to 10 used in xx models. When regeneration rate is close to 10, after mortality of 1/year the background regenerates to theoerical slope almost within one time step, for slower regeneration rate this can take a few time steps. However, if backgrund mortality at each time step is high and regeneration rate is lower, the spectrum of the background resource might deviate substantially from a theoretically expected linear slope set by kappa and lambda.  

2. By changing the lambda parameter of the background spectrum we are changing its carrying capacity, which together with the regeneration rate will affect the spectrum dynamics 

3. Background mortality rates in the model are quite high because a lot of species feed on the background. In the equilibrium model benthos mortality ranges from 1 to 6 in the largest sizes, and plankton mortality goes all the way to 2 for the largest sizes (it is 0.75 at size of 0.007g, which is still quite high)

4. We know that the benthos abundance is decreasing and Kate's work shows that slopes are getting steeper with temperature. So let's compare just two scenarios - baseline and decreased kappa (from 6 to 4) combined with steeper lambda (from 1.9 to 2.1)

### Explore spectra dynamics

How would small changes in kappa and lambda affect the spectrum. 

```{r, eval = F}
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

w_full <- params@w_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
dw_full <- params@dw_full[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
n_bb <- stable_ben[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
n_bb_C <- n_bb*dw_full
init_nbb <- params@initial_n_bb[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
init_nbb_C <- init_nbb*dw_full

n <- 0.75
m2_benthos <- ben_mort
dt.t = 0.2

r_bb <- 1 #baseline is 1
r_bb21 <- 1
lambda_ben <- 1.9
lambda_ben21 <- 2.1
kappa_ben <- 6
kappa_ben21 <- 4

rr_bb <- r_bb * w_full^(n - 1) # weight specific benthos growth rate
rr_bb21 <- r_bb21 * w_full^(n - 1) 

cc_bb <- kappa_ben *w_full^(-lambda_ben) # benthos carrying capacity: this sets initial abundance 
cc_bb21 <- kappa_ben21 *w_full^(-lambda_ben21) # benthos carrying capacity

# Dynamics of benthic spectrum uses a semi-chemostat model 
tmp <- (rr_bb * cc_bb / (rr_bb + m2_benthos))
tmp21 <- (rr_bb21 * cc_bb21 / (rr_bb21 + m2_benthos))

n_bb_next <- tmp - (tmp - n_bb) * exp(-(rr_bb + m2_benthos) * dt.t)
n_bb_next21 <- tmp21 - (tmp21 - n_bb) * exp(-(rr_bb21 + m2_benthos) * dt.t)

n_bb_next_C <- n_bb_next*dw_full
n_bb_next21_C <- n_bb_next21*dw_full

plot(log(w_full), log(n_bb_C), type = "l", col = "orange", lwd = 1.5, main = "Benthos spectrum", xlab = "log weigth(g)", ylab = "log abundance per m2")
points(log(w_full), log(init_nbb_C), type = 'l', col = 'black', lwd = 1.5)
points(log(w_full), log(n_bb_next_C), type = 'l', col = 'blue', lwd = 1.5)
points(log(w_full), log(n_bb_next21_C), type = 'l', col = 'red', lwd = 1.5)
abline(v=0, lty=2)


```


```{r, eval = F}
#inferred observed abundance (on log10 scale from Kate's and Freddie's data)
#Data using the estimated regression slope
obsab <- -0.3 - 0.9*log10(params@w_full) ## expected abundance using the equation applied to the weight groups used in mizer

#length(params@dw_full[c(min(which(params@w_full > min_w_bb)):max(which(params@w_full < w_bb_cutoff)))])
modbb_base <- log10(params@initial_n_bb * params@dw_full) 
modbb_21 <- log10(params@initial_n_bb * params@dw_full) 
modbb_23 <- log10(params@initial_n_bb * params@dw_full) 

plot(log10(params@w_full), obsab, type = 'l', lwd = 1.5, xlim = c(-6,2), ylim = c(-3, 5), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w_full), modbb_base, type = 'l', col = 'red', lwd = 1.5)
points(log10(params@w_full), modbb_21, type = 'l', col = 'blue', lwd = 1.5)
points(log10(params@w_full), modbb_23, type = 'l', col = 'purple', lwd = 1.5)
points(log10(params@w_full), modbbend, type = 'l', col = 'red', lwd = 2)

abline(v=0)



modpl <- log10(params@initial_n_pp * params@dw_full)
modaa <- log10(params@initial_n_aa * params@dw_full)

modbbend <- log10(tasm1@n_bb[tmax,] * params@dw_full) 
modppend <- log10(tasm1@n_pp[tmax,] * params@dw_full)
modaaend <- log10(tasm1@n_aa[tmax,] * params@dw_full)


plot(log10(params@w_full), obsab, type = 'l', lwd = 1.5, xlim = c(-6,2), ylim = c(-3, 5), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w_full), modbb, type = 'l', col = 'red')
points(log10(params@w_full), modbbend, type = 'l', col = 'red', lwd = 2)
points(log10(params@w_full),modpl, type = 'l', col = 'darkgreen')
points(log10(params@w_full),modppend, type = 'l', col = 'green', lwd = 2)
points(log10(params@w_full),modaa, type = 'l', col = 'blue')
points(log10(params@w_full),modaaend, type = 'l', col = 'blue', lwd = 2)

#abline(v = log10(0.05), lty = 2)
abline(v = log10(min_w_bb), lty =2)


##


noto_ini <- log10(params@initial_n[1,]*params@dw)
noto_upd <- log10(stable_abund[1,]*params@dw)

plot(log10(params@w), noto_ini, type = 'l', lwd = 1.5, ylim = c(-8, -2), main = "Slopes of initial benthic abundance versus observed abundance", xlab = "Log10, w, g", ylab = "Log10(Abundance per m2")
points(log10(params@w), noto_upd, type = 'l', col = 'red')




for (i in 1: length(params@species_params$species)) {
  points(log10(model@params@w), log10(model@n[tplot,i,]*params@dw), type = 'l')
  
}


```

### Kappa, lambda, r_ scenarios

Before each change in explored parameters reload baseline background data

```{r}
## resource params
kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
lambda = 2.15 #2.1 # 
r_pp = 1 #2 # rate of regeneration

kappa_ben = 6 #2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10

kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
r_aa = 2 #1 #something to be calibrated

## in 6 productivity scnearios benthos and plankton kappa and lambda change

prod_scen<-list( 
  "baseline"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "more_plankt"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_plankt"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_plankt"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9), 
  "more_benth"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_benth"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_benth"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0)) 



#weight at 5 cm - we will calculate mean weight of all fish above 5 cm length to compare with observed trends  
mariaParams$cm2 <- mariaParams$a * 5 ^mariaParams$b 

```

### Run in a list - in progress

```{r}

## load params
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)
  

## define senescence moratlity
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
  
  

modelRunFun <- function(prod_scen, 
                        sppParams,
                        params, 
                        stable_abund, 
                        stable_alg, 
                        stable_ben, 
                        stable_pl,
                        accepted1, 
                        dietstep = 2) 
  
  {
  
## fixed resource params
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001

    
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
    inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)
  
  
  
}




  
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all <- array(data=NA, c(17, dim(params28)[1]))
plankt_all <- array(data=NA, c(326, dim(params28)[1]))
bent_all <- array(data=NA, c(120, dim(params28)[1]))
alg_all <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:dim(params28)[1]) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
    inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)

  ####
  #baseline <- tasm1
  #saveRDS(baseline, file = "../examRuns/baseline.rds")
  ####
  
  #plot(tasm1)
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

for (xx in 1:length(mariaParams$species)) {
  PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
  MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
}
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[,iter] <- apply(ttemp, 2, mean)
  numb_all[,,iter] <- numbers
  biom_all[,iter] <- biomass
  PropLarFish_all[,iter] <- PropLarFish
  MeanWgtMat_all[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all[,iter] <- MeanWgtHalfMat
  
  }

save(numb_all, file = "../altRuns28/numbBase.RData")
save(biom_all, file = "../altRuns28/biomBase.RData")
save(plankt_all, file = "../altRuns28/planktBase.RData")
save(bent_all, file = "../altRuns28/bentBase.RData")
save(alg_all, file = "../altRuns28/algBase.RData")
save(PropLarFish_all, file = "../altRuns28/PropLargFishBase.RData")
save(MeanWgtMat_all, file = "../altRuns28/MeanWgtMatBase.RData")
save(MeanWgtHalfMat_all, file = "../altRuns28/MeanWgtHalfMatBase.RData")

```

### food web stats function

```{r}

getFoodWebStats<-function(model, diet_steps=10, link_strength=0.01, backgroundTL=0){
  
  #average n over the same time period diet was averaged 
  n_ave<- apply(model@n[tail(1:dim(model@n)[1],diet_steps),,], c(2,3), FUN="mean")
  
  # Get predator biomass 
  b_ave<-sweep(n_ave, 2, model@params@w *model@params@dw, "*")
  predbio<-reshape2::melt(b_ave)
  
  # Sum up prey consumed by prey species and prey size for each predator species and size class 
  diet_comp<-model@diet_comp
  
  dimnames(diet_comp)$pred_size<- floor(log10(as.numeric(dimnames(diet_comp)$pred_size)))+.5
  dimnames(diet_comp)$prey_size<- floor(log10(as.numeric(dimnames(diet_comp)$prey_size)))+.5
  
  diet_df<-reshape2::melt(diet_comp)
  
  # Sum up prey consumed in each predator size class / prey size class 
  dietmat<-reshape2::dcast(diet_df, predator + pred_size ~ prey + prey_size, value.var="value", sum) 
  dietmat_PreyPred<-reshape2::dcast(diet_df, prey + prey_size ~predator + pred_size , value.var="value", sum) 
  
  #Take out rows and columns with zero entries.
  dietmat<- dietmat[rowSums(dietmat[,3:dim(dietmat)[2]])!=0, ]
  idx<-colSums(dietmat[,3:dim(dietmat)[2]])!=0
  dietmat<- dietmat[,c(TRUE, TRUE, idx)]
  
  dietmat_PreyPred<- dietmat_PreyPred[rowSums(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]])!=0, ]
  idx<-colSums(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]])!=0
  dietmat_PreyPred<- dietmat_PreyPred[,c(TRUE, TRUE, idx)]
  
  #Restandardize diets
  dietmat_prop<-dietmat
  dietmat_prop[,3:dim(dietmat)[2]]<-sweep( dietmat_prop[,3:dim(dietmat_prop)[2]], 1, rowSums(dietmat_prop[,3:dim(dietmat_prop)[2]]), "/")
  
  #Food web metrics  
  totLinks <- sum(dietmat_prop[,3:dim(dietmat_prop)[2]]>link_strength) 
  Connectance <- totLinks / ( dim(dietmat_prop[,3:dim(dietmat_prop)[2]])[1] * dim(dietmat_prop[,3:dim(dietmat_prop)[2]])[2])
  AveLinks <- totLinks /  dim(dietmat_prop[,3:dim(dietmat_prop)[2]])[1] 
  
  #Predator metrics: 
  datPredSize<-data.frame(predator=dietmat$predator, pred_size=dietmat$pred_size) 
  
  #Predator metrics:
  datPredSize$generality <- rowSums(sweep(dietmat_prop[,3:dim(dietmat_prop)[2]], 1, apply(dietmat_prop[,3:dim(dietmat_prop)[2]],1,FUN="max"),"/"))
  datPredSize$shannon <- diversity(dietmat_prop[,3:dim(dietmat_prop)[2]])
  datPredSize$evenness <-  diversity(dietmat_prop[,3:dim(dietmat_prop)[2]])/log(specnumber(dietmat_prop[,3:dim(dietmat_prop)[2]])) #https://cran.r-project.org/web/packages/vegan/vignettes/diversity-vegan.pdf
  
  # Cannibalism? Aggregate prey sizes according to prey species 
  
  t_dietmat<-t(dietmat_prop)
  t_dietmat<- as.matrix(t_dietmat[-c(1:2),])
  t_dietmat<- matrix(as.numeric(as.character(t_dietmat)), nrow=dim(t_dietmat)[1], ncol=dim(t_dietmat)[2])
  dimnames(t_dietmat)<- list(prey=dietmat_PreyPred$prey, predator=dietmat$predator)
  t_dietmat<- aggregate(t_dietmat, by=list(dietmat_PreyPred$prey), FUN="sum")
  rownames(t_dietmat)<-t_dietmat[,1]
  t_dietmat<-t_dietmat[,-1]
  diet_matsp<-t(t_dietmat)
  
  datPredSize$cannibalism<- 0
  ma<-match( dietmat$predator, colnames(diet_matsp))
  for(i in 1:length(ma)){
    datPredSize$cannibalism[i]<- diet_matsp[i,ma[i]]
  }
  
  #Prey vulnerability 
  
  datPreySize<-data.frame(prey=dietmat_PreyPred$prey, prey_size=dietmat_PreyPred$prey_size) 
  
  #sweep(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]], 1, apply(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]],1,FUN="max"),"/")
  datPreySize$vulnerability<- rowSums(sweep(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]], 1, apply(dietmat_PreyPred[,3:dim(dietmat_PreyPred)[2]],1,FUN="max"),"/"))
  
  ###PPMR #
  
  # Sum prey eaten within prey size classes
  diet_compSum<- apply(model@diet_comp, c(1,2,4), sum)
  
  # Calculate PPMR 
  ppmr_df<-reshape2::melt(diet_compSum)
  ppmr_df$ppmr<- ppmr_df$pred_size/ppmr_df$prey_size
  ppmr_df$pred_size<- floor(log10(as.numeric(ppmr_df$pred_size)))+.5
  
  # Sum up diet proporation across prey species within prey size class 
  ppmr_DT <- data.table(ppmr_df)
  ppmr_DT <- ppmr_DT[,list(ppmr_ave = weighted.mean(ppmr, value)), by=.(predator , pred_size)]
  
  #Add PPMR into Predator food web metics   
  ppmr_df<-as.data.frame(ppmr_DT)
  ma<-match(paste(datPredSize$predator, datPredSize$pred_size), paste(ppmr_df$predator, ppmr_df$pred_size))
  datPredSize$ppmr<- ppmr_df$ppmr_ave[ma]
  
  #### Calculate trophic level #
  
  #Pull out diet composition, put into proportional contribution witin a predator species and predator size class
  tlsum<-model@diet_comp[1,1,,]
  tlsum<-drop(tlsum)
  names(dimnames(tlsum))<-c("predator","pred_size")
  
  ##DoesNotWork####
  predator<- dimnames(model@diet_comp)$predator
  prey<-dimnames(model@diet_comp)$prey
  pred_size<- dimnames(model@diet_comp)$pred_size
  prey_size<- dimnames(model@diet_comp)$prey_size
  
  tlsum[]<-0
  
  #Load in specific backgroundTL if supplied 
  tlsum[dimnames(tlsum)$predator=="background", ] <- backgroundTL
  
  for(i in 1:length(pred_size)){      # Predator size 
    for (j in 1:length(predator)){  # Predator species
      
      tl<- 1 + weighted.mean(tlsum,  model@diet_comp[dimnames(model@diet_comp)$predator==predator[j], dimnames(model@diet_comp)$pred_size==pred_size[i], ,] ) 
      tlsum[dimnames(tlsum)$predator==predator[j], dimnames(tlsum)$pred_size==pred_size[i]]<-tl
    }
  }
  
  # Melt the arrays to make data frame with species, wt, biomass, num, tl 
  tldat<-reshape2::melt(tlsum)
  tldat<-na.omit(tldat)
  
  b_ave<-sweep(n_ave, 2, model@params@w *model@params@dw, "*")
  predbio<-reshape2::melt(b_ave)
  
  
  ma<-match(paste(tldat$predator, signif(tldat$pred_size,3)), paste(predbio$sp, signif(predbio$w,3)))
  
  tldat$predbio<- predbio$value[ma]
  tldat$pred_size<- floor(log10(as.numeric(tldat$pred_size)))+.5
  
  DFtl<- data.table(tldat)
  tldatave<-DFtl[,list(tl_ave = weighted.mean(value, predbio, na.rm = TRUE)),by=.(predator , pred_size)]
  
  # Add to predator food web metrics 
  ma<-match( paste(datPredSize$predator, datPredSize$pred_size), paste(tldatave$predator, tldatave$pred_size))
  datPredSize$relTL <- tldatave$tl_ave[ma]
  
  #Organize and return objects  
  FWmetrics<-list(datPredSize=datPredSize,
                  datPreySize=datPreySize,
                  dietmat=dietmat,
                  dietmat_PreyPred=dietmat_PreyPred,
                  predbio=predbio)
  
  return(FWmetrics)
  
}

```


### Baseline runs - v2

Get uncertainty around baseline runs

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)

#weight at 5 cm - we will calculate mean weight of all fish above 5 cm length to compare with observed trends  
mariaParams$cm2 <- mariaParams$a * 5 ^mariaParams$b 


  prod_scen<-list( 
  "baseline"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "more_plankt"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_plankt"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_plankt"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9), 
  "more_benth"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9), 
  "less_benth"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9), 
  "small_benth"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0)) 
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
     
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2
#calcualte diet?
diet_steps = 2

## fixed background params
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001

  
#setup arrays to store results 
numb_all <-array(data=NA,c(7,17,200,dim(params28)[1]))
biom_all <- array(data=NA, c(7,17, dim(params28)[1]))
plankt_all <- array(data=NA, c(7,326, dim(params28)[1]))
bent_all <- array(data=NA, c(7,120, dim(params28)[1]))
alg_all <- array(data=NA, c(7,153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(7,17, dim(params28)[1]))
MeanWgtMat_all <- array(data= NA, c(7,17, dim(params28)[1]))
MeanWgtHalfMat_all <- array(data= NA, c(7,17, dim(params28)[1]))
CommunitySlope_all <- array(data= NA, c(7,3, dim(params28)[1]))
   
foodWebStats <- list()
#dietCompList <- list()

## loop through 7 scenarios
  
for (scen in 1:7) {
  
  print("scenario = ")
  print (scen)

## resource params
  kappa = as.numeric(prod_scen[[scen]][1])
  kappa_ben = as.numeric(prod_scen[[scen]][2])  
  lambda = as.numeric(prod_scen[[scen]][3])
  lambda_ben = as.numeric(prod_scen[[scen]][4])

    for (iter in 1:dim(params28)[1]) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- mizerRewire::project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = diet_steps)

  ### Calculate various statistics inside the run to avoid saving massive 
  
  #plot(tasm1)
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((mizerRewire::getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

      for (xx in 1:length(mariaParams$species)) {
        PropLarFish[xx] <- mean(mizerRewire::getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
        MeanWgtMat[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        MeanWgtHalfMat[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
      }
  
  
  #get mean values of various statistics over the last 30 years and save them in arrays 
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[scen,,iter] <- apply(ttemp, 2, mean)
  numb_all[scen,,,iter] <- numbers
  biom_all[scen,,iter] <- biomass
  PropLarFish_all[scen,,iter] <- PropLarFish
  MeanWgtMat_all[scen,,iter] <- MeanWgtMat
  MeanWgtHalfMat_all[scen,,iter] <- MeanWgtHalfMat
  CommunitySlope_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1)[c((tmax-29):tmax),]),2,mean))
  
  food.t <- getFoodWebStats(tasm1, diet_steps = diet_steps)
  
  foodWebStats <- c(foodWebStats, food.t)
  #dietCompList <- c(dietCompList, tasm1@diet_comp)
  
  }

}
  
save(numb_all, file = "../altRuns28/numb.RData")
save(biom_all, file = "../altRuns28/biom.RData")
save(plankt_all, file = "../altRuns28/plankt.RData")
save(bent_all, file = "../altRuns28/bent.RData")
save(alg_all, file = "../altRuns28/alg.RData")
save(PropLarFish_all, file = "../altRuns28/PropLargFish.RData")
save(MeanWgtMat_all, file = "../altRuns28/MeanWgtMat.RData")
save(MeanWgtHalfMat_all, file = "../altRuns28/MeanWgtHalfMat.RData")
save(CommunitySlope_all, file = "../altRuns28/CommunitySlope.RData")
saveRDS(foodWebStats, file = "../altRuns28/foodwebstats.rds")

```


### Baseline runs 

Get uncertainty around baseline runs

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all <- array(data=NA, c(17, dim(params28)[1]))
plankt_all <- array(data=NA, c(326, dim(params28)[1]))
bent_all <- array(data=NA, c(120, dim(params28)[1]))
alg_all <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:dim(params28)[1]) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
    inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = T)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)

  ####
  #baseline <- tasm1
  #saveRDS(baseline, file = "../examRuns/baseline.rds")
  ####
  
  #plot(tasm1)
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

for (xx in 1:length(mariaParams$species)) {
  PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
  MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
}
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[,iter] <- apply(ttemp, 2, mean)
  numb_all[,,iter] <- numbers
  biom_all[,iter] <- biomass
  PropLarFish_all[,iter] <- PropLarFish
  MeanWgtMat_all[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all[,iter] <- MeanWgtHalfMat
  
  }

save(numb_all, file = "../altRuns28/numbBase.RData")
save(biom_all, file = "../altRuns28/biomBase.RData")
save(plankt_all, file = "../altRuns28/planktBase.RData")
save(bent_all, file = "../altRuns28/bentBase.RData")
save(alg_all, file = "../altRuns28/algBase.RData")
save(PropLarFish_all, file = "../altRuns28/PropLargFishBase.RData")
save(MeanWgtMat_all, file = "../altRuns28/MeanWgtMatBase.RData")
save(MeanWgtHalfMat_all, file = "../altRuns28/MeanWgtHalfMatBase.RData")

```



### Sc1: incr benthos kappa  50%

kappa_ben = 3, lambda_ben = 2.2
kappa_ben = 9 (not 6), lambda = 1.9 (1.9)

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
    accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 9 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc1 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc1 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc1 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc1 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc1 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc1 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc1 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc1 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #more_bent <- tasm1
  #saveRDS(more_bent, file = "../examRuns/more_bent.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
          MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
  }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc1[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc1[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc1[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc1[,,iter] <- numbers
  biom_all_sc1[,iter] <- biomass
  PropLarFish_all_sc1[,iter] <- PropLarFish
  MeanWgtMat_all_sc1[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc1[,iter] <- MeanWgtHalfMat
  
}

#save(numb_all_sc1, file = "../altRuns28/numbS1.RData")
#save(biom_all_sc1, file = "../altRuns28/biomS1.RData")
#save(plankt_all_sc1, file = "../altRuns28/planktS1.RData")
#save(bent_all_sc1, file = "../altRuns28/bentS1.RData")
#save(alg_all_sc1, file = "../altRuns28/algS1.RData")
#save(PropLarFish_all_sc1, file = "../altRuns28/PropLargFishS1.RData")
#save(MeanWgtMat_all_sc1, file = "../altRuns28/MeanWgtMatS1.RData")
#save(MeanWgtHalfMat_all_sc1, file = "../altRuns28/MeanWgtHalfMatS1.RData")

```

### Sc2: decr benthos kappa 50%

kappa_ben = 4 (not 6), lambda_ben = 1.9

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 4 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc2 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc2 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc2 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc2 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc2 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc2 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc2 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc2 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #less_bent <- tasm1
  #saveRDS(less_bent, file = "../examRuns/less_bent.rds")
  ###
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
    PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
          MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc2[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc2[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc2[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc2[,,iter] <- numbers
  biom_all_sc2[,iter] <- biomass
    PropLarFish_all_sc2[,iter] <- PropLarFish
  MeanWgtMat_all_sc2[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc2[,iter] <- MeanWgtHalfMat

  
}

save(numb_all_sc2, file = "../altRuns28/numbS2.RData")
save(biom_all_sc2, file = "../altRuns28/biomS2.RData")
save(plankt_all_sc2, file = "../altRuns28/planktS2.RData")
save(bent_all_sc2, file = "../altRuns28/bentS2.RData")
save(alg_all_sc2, file = "../altRuns28/algS2.RData")
save(PropLarFish_all_sc2, file = "../altRuns28/PropLargFishS2.RData")
save(MeanWgtMat_all_sc2, file = "../altRuns28/MeanWgtMatS2.RData")
save(MeanWgtHalfMat_all_sc2, file = "../altRuns28/MeanWgtHalfMatS2.RData")

```

### Sc3: incr plankton kappa 50%

kappa = 2.6, lambda = 2.15

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2.6#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc3 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc3 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc3 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc3 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc3 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc3 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc3 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc3 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #more_plank <- tasm1
  #saveRDS(more_plank, file = "../examRuns/more_plank.rds")
  ###
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
      PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
                  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc3[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc3[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc3[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc3[,,iter] <- numbers
  biom_all_sc3[,iter] <- biomass
      PropLarFish_all_sc3[,iter] <- PropLarFish
  MeanWgtMat_all_sc3[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc3[,iter] <- MeanWgtHalfMat
  
}

save(numb_all_sc3, file = "../altRuns28/numbS3.RData")
save(biom_all_sc3, file = "../altRuns28/biomS3.RData")
save(plankt_all_sc3, file = "../altRuns28/planktS3.RData")
save(bent_all_sc3, file = "../altRuns28/bentS3.RData")
save(alg_all_sc3, file = "../altRuns28/algS3.RData")
save(PropLarFish_all_sc3, file = "../altRuns28/PropLargFishS3.RData")
save(MeanWgtMat_all_sc3, file = "../altRuns28/MeanWgtMatS3.RData")
save(MeanWgtHalfMat_all_sc3, file = "../altRuns28/MeanWgtHalfMatS3.RData")

```

### Sc4: decr plankton kappa 25%

kappa = 1.5, lambda = 2.15

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 1.5#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc4 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc4 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc4 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc4 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc4 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc4 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc4 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc4 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #less_plank <- tasm1
  #saveRDS(less_plank, file = "../examRuns/less_plank.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
      PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc4[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc4[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc4[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc4[,,iter] <- numbers
  biom_all_sc4[,iter] <- biomass
      PropLarFish_all_sc4[,iter] <- PropLarFish
  MeanWgtMat_all_sc4[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc4[,iter] <- MeanWgtHalfMat
  
}

save(numb_all_sc4, file = "../altRuns28/numbS4.RData")
save(biom_all_sc4, file = "../altRuns28/biomS4.RData")
save(plankt_all_sc4, file = "../altRuns28/planktS4.RData")
save(bent_all_sc4, file = "../altRuns28/bentS4.RData")
save(alg_all_sc4, file = "../altRuns28/algS4.RData")
save(PropLarFish_all_sc4, file = "../altRuns28/PropLargFishS4.RData")
save(MeanWgtMat_all_sc4, file = "../altRuns28/MeanWgtMatS4.RData")
save(MeanWgtHalfMat_all_sc4, file = "../altRuns28/MeanWgtHalfMatS4.RData")

```

### Sc5: steeper plankton lambda

kappa = 2, lambda = 2.18

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2.5#2 intercept assuming g/m2
  lambda = 2.18 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc5 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc5 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc5 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc5 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc5 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc5 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc5 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc5 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #small_plank <- tasm1
  #saveRDS(small_plank, file = "../examRuns/small_plank.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
      PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
                  MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc5[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc5[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc5[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc5[,,iter] <- numbers
  biom_all_sc5[,iter] <- biomass
      PropLarFish_all_sc5[,iter] <- PropLarFish
  MeanWgtMat_all_sc5[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc5[,iter] <- MeanWgtHalfMat
}

save(numb_all_sc5, file = "../altRuns28/numbS5.RData")
save(biom_all_sc5, file = "../altRuns28/biomS5.RData")
save(plankt_all_sc5, file = "../altRuns28/planktS5.RData")
save(bent_all_sc5, file = "../altRuns28/bentS5.RData")
save(alg_all_sc5, file = "../altRuns28/algS5.RData")
save(PropLarFish_all_sc5, file = "../altRuns28/PropLargFishS5.RData")
save(MeanWgtMat_all_sc5, file = "../altRuns28/MeanWgtMatS5.RData")
save(MeanWgtHalfMat_all_sc5, file = "../altRuns28/MeanWgtHalfMatS5.RData")

```

### Sc6: steeper benthos lambda 

kappa = 6, lambda = 2.0

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
  
  accepted1 <- as.data.frame(params28)
  
## resource params
  kappa = 2#2 intercept assuming g/m2
  lambda = 2.15 #2.15  
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6 #6 intercept assuming g/m2  
  lambda_ben = 2.0 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    
## setup run time 
tmax = 100
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

#setup arrays to store results 
numb_all_sc6 <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc6 <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc6 <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc6 <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc6 <- array(data=NA, c(153, dim(params28)[1]))
PropLarFish_all_sc6 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtMat_all_sc6 <- array(data= NA, c(17, dim(params28)[1]))
MeanWgtHalfMat_all_sc6 <- array(data= NA, c(17, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  plot(tasm1)
  
  ### 
  #small_bent <- tasm1
  #saveRDS(small_bent, file = "../examRuns/small_bent.rds")
  ###
  
  
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtHalfMat <- rep(NA,17)

        for (xx in 1:length(mariaParams$species)) {
          PropLarFish[xx] <- mean(getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[tmax:tmax-29])
          MeanWgtMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$w_mat[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
         MeanWgtHalfMat[xx]  <- mean(getMeanWeight(tasm1, min_w = mariaParams$cm2[xx], max_w = mariaParams$w_inf[xx])[tmax:tmax-29])
        }
  
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all_sc6[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all_sc6[,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all_sc6[,iter] <- apply(ttemp, 2, mean)
  numb_all_sc6[,,iter] <- numbers
  biom_all_sc6[,iter] <- biomass
      PropLarFish_all_sc6[,iter] <- PropLarFish
  MeanWgtMat_all_sc6[,iter] <- MeanWgtMat
  MeanWgtHalfMat_all_sc6[,iter] <- MeanWgtHalfMat
  
}

save(numb_all_sc6, file = "../altRuns28/numbS6.RData")
save(biom_all_sc6, file = "../altRuns28/biomS6.RData")
save(plankt_all_sc6, file = "../altRuns28/planktS6.RData")
save(bent_all_sc6, file = "../altRuns28/bentS6.RData")
save(alg_all_sc6, file = "../altRuns28/algS6.RData")
save(PropLarFish_all_sc6, file = "../altRuns28/PropLargFishS6.RData")
save(MeanWgtMat_all_sc6, file = "../altRuns28/MeanWgtMatS6.RData")
save(MeanWgtHalfMat_all_sc6, file = "../altRuns28/MeanWgtHalfMatS6.RData")

```


### ####################
### OUTPUT PLOTS 

what kind of outputs to show 
1. Relative changes in biomasses 
2. Total fish community biomass? 
3. Relative changes in size-at-age 
4. Relative changes in mean size (above 2 cm in length)
5. Entire community size spectrum 
6. Emergent ppmr at species and community level?
7. Production to biomass ratio
8. Stability with alpha max? 

### Food web stats

```{r}
#Make sure you give the right path and load extra required packages
library(data.table)
source("FoodWebStats.R")

plotDietComp(tasm1) #plot proportion of prey in diets - this is a function Jon wrote 
plotPPMR(tasm1) #plot realised PPMR - this is also a function Jon wrote and they are now all incorporated into rewire-temp

## Now we can get all sorts of other food web statistics, using a code that Jon wrote. 
#the code is not a part of mizer rewiring, so we source it separately 

foodwebstats <- getFoodWebStats(tasm1, diet_steps = 2)
```

### Total biomass plot

```{r}

par(mfrow = c(1,1))
#how much variation among plausible parameters?
biom_mean_base <- apply(biom_all, 1, mean)
biom_min_base <- apply(biom_all, 1, min)
biom_max_base <- apply(biom_all, 1, max)

x = c(1:17)
plot(x, biom_mean_base, pch=19, ylim = c(0,4), xlab = "Species", ylab = "Biomass, g/m2")
arrows(x, biom_min_base, x, biom_max_base, length = 0.05, angle = 90, code = 3)

#points(biom_min_base, pch=19, col = 'red')
#points(biom_max_base, pch=19, col = 'red')
```

#Relative biomass plot

```{r}

#plot(x, avg,
#    ylim=range(c(avg-sdev, avg+sdev)),
#    pch=19, xlab="Measurements", ylab="Mean +/- SD",
#    main="Scatter plot with std.dev error bars"
#)
# hack: we draw arrows but with very special "arrowheads"
#arrows(x, avg-sdev, x, avg+sdev, length=0.05, angle=90, code=3)
#n the arrows(...) function length=0.05 is the size of the "arrowhead" in inches, angle=90 specifies that the "arrowhead" is perpendicular to the shaft of the arrow, and the particularly intuitive code=3 parameter specifies that we want to draw an arrowhead on both ends of the arrow.

#For horizontal error bars the following changes are necessary, assuming that the sdev vector now contains the errors in the x values and the y values are the ordinates:
#
#plot(x, y,
#    xlim=range(c(x-sdev, x+sdev)),
#    pch=19,...)
# horizontal error bars
#arrows(x-sdev, y, x+sdev, y, length=0.05, angle=90, code=3

 par(mfrow = c(2,3))
#We want to compare DIFFERENCE in biomass from baseline scenario
  BiomDiffs1 <- (biom_all_sc1 - biom_all)/biom_all
  MedianBiomDiffs1 <- apply(BiomDiffs1, 1, median)
  MinBiomDiffs1 <- apply(BiomDiffs1, 1, min)
  MaxBiomDiffs1 <- apply(BiomDiffs1, 1, max)
  SDBiomDiffs1 <- apply(BiomDiffs1, 1, sd)
  
plot(x, MedianBiomDiffs1, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs1, x, MaxBiomDiffs1, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs1, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs1, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#We want to compare DIFFERENCE in biomass from baseline scenario
  BiomDiffs2 <- (biom_all_sc2 - biom_all)/biom_all
  MedianBiomDiffs2 <- apply(BiomDiffs2, 1, median)
  MinBiomDiffs2 <- apply(BiomDiffs2, 1, min)
  MaxBiomDiffs2 <- apply(BiomDiffs2, 1, max)
  SDBiomDiffs2 <- apply(BiomDiffs2, 1, sd)
  
plot(x, MedianBiomDiffs2, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs2, x, MaxBiomDiffs2, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs2, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs2, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

 BiomDiffs6 <- (biom_all_sc6 - biom_all)/biom_all
  MedianBiomDiffs6 <- apply(BiomDiffs6, 1, median)
  MinBiomDiffs6 <- apply(BiomDiffs6, 1, min)
  MaxBiomDiffs6 <- apply(BiomDiffs6, 1, max)
  SDBiomDiffs6 <- apply(BiomDiffs6, 1, sd)
  
plot(x,MedianBiomDiffs6, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs6, x, MaxBiomDiffs6, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs6, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs6, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#
  BiomDiffs3 <- (biom_all_sc3 - biom_all)/biom_all
  MedianBiomDiffs3 <- apply(BiomDiffs3, 1, median)
  MinBiomDiffs3 <- apply(BiomDiffs3, 1, min)
  MaxBiomDiffs3 <- apply(BiomDiffs3, 1, max)
  SDBiomDiffs3 <- apply(BiomDiffs3, 1, sd)
  
plot(x, MedianBiomDiffs3, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs3, x, MaxBiomDiffs3, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs3, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs3, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

  BiomDiffs4 <- (biom_all_sc4 - biom_all)/biom_all
  MedianBiomDiffs4 <- apply(BiomDiffs4, 1, median)
  MinBiomDiffs4 <- apply(BiomDiffs4, 1, min)
  MaxBiomDiffs4 <- apply(BiomDiffs4, 1, max)
  SDBiomDiffs4 <- apply(BiomDiffs4, 1, sd)
  
plot(x, MedianBiomDiffs4, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs4, x, MaxBiomDiffs4, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs4, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs4, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)
abline(h=-1, lty=2)

 BiomDiffs5 <- (biom_all_sc5 - biom_all)/biom_all
  MedianBiomDiffs5 <- apply(BiomDiffs5, 1, median)
  MinBiomDiffs5 <- apply(BiomDiffs5, 1, min)
  MaxBiomDiffs5 <- apply(BiomDiffs5, 1, max)
  SDBiomDiffs5 <- apply(BiomDiffs5, 1, sd)
  
plot(MedianBiomDiffs5, pch=19, ylim = c(-1,2), xlab = NA, ylab = NA)
arrows(x, MinBiomDiffs5, x, MaxBiomDiffs5, length = 0.05, angle = 90, code = 3)
#points(MaxBiomDiffs5, pch=19, ylim = c(-1,1), col = 'red')
#points(MinBiomDiffs5, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)


```

### Compare proportion of large fish

```{r}

 par(mfrow = c(1,1))
#how much variation among plausible parameters?
PropLarFish_mean_base <- apply(PropLarFish_all, 1, mean)
PropLarFish_min_base <- apply(PropLarFish_all, 1, min)
PropLarFish_max_base <- apply(PropLarFish_all, 1, max)

plot(PropLarFish_mean_base, pch=19, ylim = c(0,1))
points(PropLarFish_min_base, pch=19, col = 'red')
points(PropLarFish_max_base, pch=19, col = 'red')

 par(mfrow = c(3,2))
#We want to compare DIFFERENCE in PropLarFishass from baseline scenario
  PropLarFishDiffs1 <- (PropLarFish_all_sc1 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, median)
  MinPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, min)
  MaxPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, max)
  SDPropLarFishDiffs1 <- apply(PropLarFishDiffs1, 1, sd)
  
plot(MedianPropLarFishDiffs1, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs1, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs1, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#We want to compare DIFFERENCE in PropLarFishass from baseline scenario
  PropLarFishDiffs2 <- (PropLarFish_all_sc2 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, median)
  MinPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, min)
  MaxPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, max)
  SDPropLarFishDiffs2 <- apply(PropLarFishDiffs2, 1, sd)
  
plot(MedianPropLarFishDiffs2, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs2, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs2, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

#
  PropLarFishDiffs3 <- (PropLarFish_all_sc3 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, median)
  MinPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, min)
  MaxPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, max)
  SDPropLarFishDiffs3 <- apply(PropLarFishDiffs3, 1, sd)
  
plot(MedianPropLarFishDiffs3, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs3, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs3, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

  PropLarFishDiffs4 <- (PropLarFish_all_sc4 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, median)
  MinPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, min)
  MaxPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, max)
  SDPropLarFishDiffs4 <- apply(PropLarFishDiffs4, 1, sd)
  
plot(MedianPropLarFishDiffs4, pch=19, ylim = c(-1,1))
points(MaxPropLarFishDiffs4, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs4, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)
abline(h=-1, lty=2)

 PropLarFishDiffs5 <- (PropLarFish_all_sc5 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, median)
  MinPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, min)
  MaxPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, max)
  SDPropLarFishDiffs5 <- apply(PropLarFishDiffs5, 1, sd)
  
plot(MedianPropLarFishDiffs5, pch=19, ylim = c(-1,1.5))
points(MaxPropLarFishDiffs5, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs5, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)

 PropLarFishDiffs6 <- (PropLarFish_all_sc6 - PropLarFish_all)/PropLarFish_all
  MedianPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, median)
  MinPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, min)
  MaxPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, max)
  SDPropLarFishDiffs6 <- apply(PropLarFishDiffs6, 1, sd)
  
plot(MedianPropLarFishDiffs6, pch=19, ylim = c(-1,1.5))
points(MaxPropLarFishDiffs6, pch=19, ylim = c(-1,1), col = 'red')
points(MinPropLarFishDiffs6, pch=19, ylim = c(-1,1), col = 'red')
abline(h =0)
```




### Compare size spectra

```{r}
### 
# we only want to look at "observable" size spectra, i.e. individuals above 2cm in length. Assuming standard wl relationship this would correspond to w = 0.01*2^3 or 0.08 grams

par(mfrow = c(1,2))
#par(mfrow = c(1,1))

for (sp in 1:17) {
#sp = 1

#benthos scenarios
i = 1 #first set of params
temp <- which(params@w > params@species_params$w_inf[sp])
num.d1 <- (numb_all_sc1[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d2 <- (numb_all_sc2[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d6 <- (numb_all_sc6[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d1[temp] <- NA
num.d2[temp] <- NA
num.d6[temp] <- NA

plot(log(params@w), num.d1, type = 'l', col = 'grey', main = mariaParams$species[sp], xlab = "log size group, g", ylab = "relative number difference", ylim = c(-1, 1))
abline(v = log(params@species_params$w_mat[sp]), lty = 2)
abline(v = log(0.08))
abline(h = 0)
points(log(params@w), num.d2, type = 'l', col = 'pink')
points(log(params@w), num.d6, type = 'l', col = 'lightblue3')


for (i in 2:(dim(params28)[1])) {
num.d1 <- (numb_all_sc1[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d2 <- (numb_all_sc2[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d6 <- (numb_all_sc6[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d1[temp] <- NA
num.d2[temp] <- NA
num.d6[temp] <- NA
points(log(params@w), num.d1, type = 'l', col = 'grey')
points(log(params@w), num.d2, type = 'l', col = 'pink')
points(log(params@w), num.d6, type = 'l', col = 'lightblue3')
}


## plankton scenarios

i = 1 #first set of params
temp <- which(params@w > params@species_params$w_inf[sp])
num.d3 <- (numb_all_sc3[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d4 <- (numb_all_sc4[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d5 <- (numb_all_sc5[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d3[temp] <- NA
num.d4[temp] <- NA
num.d5[temp] <- NA

plot(log(params@w), num.d3, type = 'l', col = 'grey', main = mariaParams$species[sp], xlab = "log size group, g", ylab = "relative number difference", ylim = c(-1, 1))
abline(v = log(params@species_params$w_mat[sp]), lty = 2)
abline(v = log(0.08))
abline(h = 0)
points(log(params@w), num.d4, type = 'l', col = 'pink')
points(log(params@w), num.d5, type = 'l', col = 'lightblue3')


for (i in 2:(dim(params28)[1])) {
num.d3 <- (numb_all_sc3[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d4 <- (numb_all_sc4[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d5 <- (numb_all_sc5[sp,,i]*params@dw[] - numb_all[sp,,i]*params@dw[])/(numb_all[sp,,i]*params@dw[])
num.d3[temp] <- NA
num.d4[temp] <- NA
num.d5[temp] <- NA
points(log(params@w), num.d3, type = 'l', col = 'grey')
points(log(params@w), num.d4, type = 'l', col = 'pink')
points(log(params@w), num.d5, type = 'l', col = 'lightblue3')
}
}



```

1, 3, 7, 13, 16, 17

```{r}
ggplot(df_CI) +
  geom_abline(intercept = 0, slope = 0, linetype = "dashed") +
#  geom_point(data = df_fit, aes(x = x, y = y, color = color)) +
  geom_point(data = data_subset2, aes(x = x, y = y, col = "grey")) + 
  geom_errorbar(data = data_subset2, aes(x = x, ymin = p10, ymax = p90, color = "grey"), width=0) +
  geom_point(data = data_subset1, aes(x = x, y = y, color = "blue")) + 
  geom_errorbar(data = data_subset1, aes(x = x, ymin = p10, ymax = p90, color = "blue"), width=0) +
    geom_point(data = data_subset0, aes(x = x, y = y, color = "red")) + 
#  geom_errorbar(data = df_fit, aes(x = x, ymin = p10, ymax = p90, color = color), width=0) +
  geom_errorbar(data = data_subset0, aes(x = x, ymin = p10, ymax = p90, color = "red"), width=0) +
  geom_polygon(data = df_polygon, aes(x = x, y = y), fill = "#feb24c") +
  geom_line(aes(x = x, y = mu_500)) +
  labs(
    x = expression("Species thermal affinity ("~degree~"C)"),
    y = expression("Relative change in body length (per "~degree~"C)")
  ) +
  ylim(-0.25, 0.25) +   # add ylim to remove the outlier 
  #  xlim (-0.03, 0.03) +
  scale_colour_manual(values=c("#de2d26", "grey70", "#3182bd")) +
  guides(color=FALSE) +
#  geom_vline(xintercept = 23, linetype = "dashed") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.x = element_text(size=14),
    axis.title.y = element_text(size=14),
    axis.text=element_text(size=12)
  )
```




Actual runs 

```{r}
tmax = 150

#for benthos kappa
#kappa.v <- seq(from = (kappa_ben-2), to = (kappa_ben + 2), by = 0.5) #current kappa_ben is 6

#for benthos lambda
#kappa.v <- seq(from = (lambda_ben-0.3), to = (lambda_ben + 0.3), by = 0.05) #current lambda_ben is 1.9

#for benthos r_bb
#kappa.v <- seq(from = (r_bb-0.5), to = (r_bb + 2.5), by = 0.25) #current r_bb is 1

#for plankton kappa
#kappa.v <- seq(from = (kappa-1.5), to = (kappa + 1.5), by = 0.25) ## current kappa is 2

#for plankton lambda
#kappa.v <- seq(from = (lambda-0.3), to = (lambda + 0.3), by = 0.05) #current lambda is 2.15

#for plankton r_pp
kappa.v <- seq(from = (r_pp-0.5), to = (r_pp + 2.5), by = 0.25) #current r_pp is 1

#for algal kappa
#kappa.v <- seq(from = (kappa_alg-4), to = (kappa_alg + 4), by = 0.5) ## current kappa is 16

#for algal lambda
#kappa.v <- seq(from = (lambda_alg-0.3), to = (lambda_alg + 0.3), by = 0.05) #current lambda_alg is 1.6

relbiomKappaSens <- data.frame()

for (i in 1:length(kappa.v)) {

#update kappa for benthos
#kappa_ben = kappa.v[i]
#update lambda for benthos
#lambda_ben = kappa.v[i]  
#r_bb = kappa.v[i] 
  
#or if running for plankton update kappa 
#kappa = kappa.v[i]
#update plankton lambda
#lambda = kappa.v[i] 
r_pp = kappa.v[i] 
  
#kappa_alg <- kappa.v[i]
#lambda_alg <- kappa.v[i] 
      
### setup 
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tasm1kappa <- project(params, t_max = tmax, effort= 0, dt = dt)

plot(tasm1kappa)

## compare biomasses 
print(round(getBiomass(tasm1kappa)[tmax,]/getBiomass(tasm1)[tmax,],5))

temp <- round(getBiomass(tasm1kappa)[tmax,]/getBiomass(tasm1)[tmax,],5)
relbiomKappaSens <- rbind(relbiomKappaSens, temp)

}

colnames(relbiomKappaSens) <- params@species_params$species #biomasses of species as you fish species in rows
rownames(relbiomKappaSens) <- paste("r_pp",as.character(kappa.v), sep = "")

temp <- backgr_change

#backgr_change <- data.frame()
backgr_change <- rbind(backgr_change, relbiomKappaSens)

save(backgr_change, file = "../outputs/changeOneParamBackground.RData")
write.csv(backgr_change, file = "../outputs/changeOneParamBackground.csv")
```

### Alternative scenarios results

```{r}
load(file = "../outputs/changeOneParamBackground.RData")

pca_test <- prcomp(backgr_change)
plot(pca_test)
summary(pca_test)
biplot(pca_test)

## Look if biomass of one species (T_caudimaculatus in my case) is strongly correlated to other species
#cor_Tra <- rep(NA, 17)
#p_Tra <- rep(NA, 17)

#for (i in 1:length(params@species_params$species)) {
#onesp <- relbiomFishOne[,i]
#temp <- cor.test(relbiomFishOne$T_caudimaculatus, onesp)
#cor_Tra[i] <- temp$statistic
#p_Tra[i] <- round(temp$p.value,5)
#}
#trach_inter <- cbind(as.character(mariaParams$species), round(cor_Tra,3), round(p_Tra,4))  


```


### Time variable background

```{r}
### setup 
params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg

## add senescence and juvenile mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)

## setup run time 
tmax = 150
tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
plot(tasm1)


```




### #####################
#### OTHER STUFF


### Sc1_P: gradually incr benthos kappa 50%

kappa_ben = 3, lambda_ben = 2.2
kappa_ben = 9 (not 6), lambda = 1.9 (1.9)

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
    accepted1 <- as.data.frame(params28)
  
    ## setup run time 
tmax = 60
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2
    
    
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben_S = seq(from = 6, to = 9, length.out = (tmax/2)) #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    


#setup arrays to store results 
numb_all_sc1P <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc1P <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc1P <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc1P <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc1P <- array(data=NA, c(153, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters
  
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  #run iteratively every 2 years 
  for (yy in 1:(tmax/2)) {
    #print(yy)
   kappa_ben <- kappa_ben_S[yy]
   #print(kappa_ben)
    
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
    ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = 2, effort= 0, dt = dt)
  #plot(tasm1)
  stable_abund <- tasm1@n[dim(tasm1@n)[1],,]
  stable_pl <- tasm1@n_pp[dim(tasm1@n)[1],]
  stable_ben <- tasm1@n_bb[dim(tasm1@n)[1],]
  stable_alg <- tasm1@n_aa[dim(tasm1@n)[1],]
  }
  
  #plot(tasm1)
  #need to take an average of the last 30 years because it is oscilating
  biomass <- getBiomass(tasm1)[dim(tasm1@n)[1],]
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- tasm1@n[dim(tasm1@n)[1],,]
  
  plankt_all_sc1P[,iter] <- tasm1@n_pp[(dim(tasm1@n)[1]),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  bent_all_sc1P[,iter] <- tasm1@n_bb[(dim(tasm1@n)[1]),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  alg_all_sc1P[,iter] <- tasm1@n_aa[(dim(tasm1@n)[1]),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  numb_all_sc1P[,,iter] <- numbers
  biom_all_sc1P[,iter] <- biomass
  
  
  
  
}

save(numb_all_sc1P, file = "../altRuns28/numbS1P.RData")
save(biom_all_sc1P, file = "../altRuns28/biomS1P.RData")
save(plankt_all_sc1P, file = "../altRuns28/planktS1P.RData")
save(bent_all_sc1P, file = "../altRuns28/bentS1P.RData")
save(alg_all_sc1P, file = "../altRuns28/algS1P.RData")

```


### Sc2_P: gradually decr benthos kappa 50%

kappa_ben = 3, lambda_ben = 2.2
kappa_ben = 4 (not 6), lambda = 1.9 (1.9)

```{r}
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  #load(file = "../modelParams/params194.RData")
  load(file = "../modelParams/params28ms.RData")
    accepted1 <- as.data.frame(params28)
  
    ## setup run time 
tmax = 60
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2
    
    
## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben_S = seq(from = 6, to = 4, length.out = (tmax/2)) #6 intercept assuming g/m2  
  lambda_ben = 1.9 # 1.9 # this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
#parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
    


#setup arrays to store results 
numb_all_sc2P <-array(data=NA,c(17,200,dim(params28)[1]))
biom_all_sc2P <- array(data=NA, c(17, dim(params28)[1]))
plankt_all_sc2P <- array(data=NA, c(326, dim(params28)[1]))
bent_all_sc2P <- array(data=NA, c(120, dim(params28)[1]))
alg_all_sc2P <- array(data=NA, c(153, dim(params28)[1]))

for (iter in 1:(dim(params28)[1])) {

  print(iter)  
## update parameters
  
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  #run iteratively every 2 years 
  for (yy in 1:(tmax/2)) {
    #print(yy)
   kappa_ben <- kappa_ben_S[yy]
   #print(kappa_ben)
    
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
    ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = 2, effort= 0, dt = dt)
  #plot(tasm1)
  stable_abund <- tasm1@n[dim(tasm1@n)[1],,]
  stable_pl <- tasm1@n_pp[dim(tasm1@n)[1],]
  stable_ben <- tasm1@n_bb[dim(tasm1@n)[1],]
  stable_alg <- tasm1@n_aa[dim(tasm1@n)[1],]
  }
  
  #plot(tasm1)
  #need to take an average of the last 30 years because it is oscilating
  biomass <- getBiomass(tasm1)[dim(tasm1@n)[1],]
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- tasm1@n[dim(tasm1@n)[1],,]
  
  plankt_all_sc2P[,iter] <- tasm1@n_pp[(dim(tasm1@n)[1]),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  bent_all_sc2P[,iter] <- tasm1@n_bb[(dim(tasm1@n)[1]),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  alg_all_sc2P[,iter] <- tasm1@n_aa[(dim(tasm1@n)[1]),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  numb_all_sc2P[,,iter] <- numbers
  biom_all_sc2P[,iter] <- biomass
  
}

save(numb_all_sc2P, file = "../altRuns28/numbS2P.RData")
save(biom_all_sc2P, file = "../altRuns28/biomS2P.RData")
save(plankt_all_sc2P, file = "../altRuns28/planktS2P.RData")
save(bent_all_sc2P, file = "../altRuns28/bentS2P.RData")
save(alg_all_sc2P, file = "../altRuns28/algS2P.RData")

```


### Mortality - FIX the code, does not work now

The graph is not perfect, but a quick look at the assumed juvenile and senescence mortality functions and how they compare with the predation mortality. Minimum size is shown with dashed blue line, maturation size is shown with orange lines. Basically we see that juvenile mortality is very high at minimum sizes and drops quickly at around sizes 0.1g, by which time predation becomes a more important force. Note, no juvenile mortality is imposed on sharks, for which min size is assumed to be 1g. Senescence mortality kicks in just before the 90% of maximum size. The curves look steep, but the maximum values are around 1 at maximum size. 

```{r warning=FALSE, message=FALSE, echo=T}

#at which time to plot 
year = 50

m2mort <- getM2(params,model@n[year,,],model@n_pp[year,], model@n_bb[year,], model@n_aa[year,], model@intTempScalar[,,(year/dt)])

getPredMort <- function(object, n, n_pp, n_bb, n_aa, pred_rate, intakeScalar, time_range, drop = TRUE

# get predation mortality 
m2mort <- getM2(model, model@intTempScalar[,,(year/dt)], )[year,,]
#get non-predation mortality 
nonm2mort <- params@mu_b

#plot non predation mort
plot(log(params@dw), nonm2mort[1,], type = 'l', ylim = c(0, 5), col = 'grey', xlab = "log size, g", ylab = "instantaneous mortality", main = "Non-predation and predation (red) mortality")
for (i in 2:length(mariaParams$species)) {
  points(log(params@dw), nonm2mort[i,], type = 'l')  
}
#add predation 
for (i in 1:length(mariaParams$species)) {
  points(log(params@dw), m2mort[i,], type = 'l', col = 'red')  
}
#who w_min
abline(v = log(mariaParams$w_min), lty = 2, col  = 'blue')
abline(v = log(mariaParams$w_mat), lty = 2, col  = 'orange')

#totmort <- getM2(tasm1)[tmax,,] + params@mu_b

#or just explore non predation mortality
#plot(x = log(tasm1@params@w), tasm1@params@mu_b[1,], ylim = c(0,50), type = 'l')
#for (i in 1: length(params@species_params$species)) {
#  points(log(tasm1@params@w), tasm1@params@mu_b[i,], type = 'l')
#}
#abline(v = log(mariaParams$w_min), lty = 2, col  = 'red')
#abline(v = log(mariaParams$w_inf), lty = 2, col  = 'blue')


```

### Size spectra  

Initial and final abundance at size: still too many individuals at largest sizes

```{r warning=FALSE, message=FALSE, echo=T}
#plot initial and final abundance 
par(mfrow = c(1,2))

mycol = c('black','red', 'green', 'orange','blue','violet','pink','grey','yellow','black','red', 'green', 'orange','blue','violet','pink','grey','yellow')

#initial
plot(log(params@w), log(params@initial_n[1,]), type = 'l', ylim = c(-40, max(log(params@initial_n[]))), main = "initial n", xlab = "log w", ylab = "numbers")

for (i in 2:length(params@species_params$species)) {
  points(log(params@w), log(params@initial_n[i,]), type = 'l', col = mycol [i] )
}
abline (h = c(0,-10,-20,-30), lty = 2, col = 'grey')
abline (v = c(-5,0,5), lty = 2, col = 'grey')

#final
plot(log(params@w), log(tasm1ef@n[tmax,1,]), type = 'l', ylim = c(-40, max(log(params@initial_n[]))), main = "final n", xlab = "log w", ylab = "numbers")

for (i in 2:length(params@species_params$species)) {
  points(log(params@w), log(tasm1ef@n[tmax,i,]), type = 'l', col = mycol [i] )
}
abline (h = c(0,-10,-20,-30), lty = 2, col = 'grey')
abline (v = c(-5,0,5), lty = 2, col = 'grey')
par(mfrow = c(1,1))

```





### RLS/MPA data: relative biomasses and abundances in 3 decades


### Life-history parameters from FishBase and other 


### Maximum intake(h) and metabolism (ks) parameters



### OLD AND WRONG


### Compare size spectra old

```{r}
### 
# we only want to look at "observable" size spectra, i.e. individuals above 2cm in length. Assuming standard wl relationship this would correspond to w = 0.01*2^3 or 0.08 grams

par(mfrow = c(3,3))
#par(mfrow = c(1,1))

for (sp in 1:17) {
#sp = 1
i = 1 #first scenario
num.t <- numb_all[sp,,i]*params@dw[]
temp <- which(params@w > params@species_params$w_inf[sp])
num.t[temp] <- NA
#temptemp <- c((numb_all[sp,,]*params@dw[]), (numb_all_sc1[sp,,]*params@dw[]), (numb_all_sc1P[sp,,]*params@dw[]))
#temptemp <- c((numb_all[sp,,]*params@dw[]), (numb_all_sc2[sp,,]*params@dw[]), (numb_all_sc2P[sp,,]*params@dw[]))
temptemp <- c((numb_all[sp,,]*params@dw[]), (numb_all_sc1[sp,,]*params@dw[]), (numb_all_sc6[sp,,]*params@dw[]))
minplot <- min(temptemp[temptemp>0])
#maxplot <- max(c((numb_all[sp,,]*params@dw[]), (numb_all_sc1[sp,,]*params@dw[]), (numb_all_sc1P[sp,,]*params@dw[])))
maxplot <- max(c((numb_all[sp,,]*params@dw[]), (numb_all_sc1[sp,,]*params@dw[]), (numb_all_sc6[sp,,]*params@dw[])))

#maxplot <- max(c((numb_all[sp,,]*params@dw[]), (numb_all_sc3[sp,,]*params@dw[]), (numb_all_sc4[sp,,]*params@dw[])))

#ben_mort[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]

plot(log(params@w), log(num.t), type = 'l', col = 'grey', main = mariaParams$species[sp], xlab = "log size group, g", ylab = "Log numbers at size", ylim = c(log(minplot), log(maxplot)))
abline(v = log(params@species_params$w_mat[sp]), lty = 2)
abline(v = log(0.08))

for (i in 2:(dim(params28)[1])) {
num.t <- numb_all[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'grey')
}
#increase benthos kappa
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc1[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'pink')
}

#steeper benthos lambda
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc6[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'lightblue')
}
}



#decrease benthos kappa
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc2[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'pink')
}
#decrease benthos kappa progressively
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc2P[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'orange')
}




#increase benthos kappa progressively
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc1P[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'orange')
}
}


#decrease benthos kappa
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc2[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'lightblue')
}
}

## plankton
par(mfrow = c(3,3))
#par(mfrow = c(1,1))

for (sp in 1:17) {
#sp = 1
i = 1 #first scenario
num.t <- numb_all[sp,,i]*params@dw[]
temp <- which(params@w > params@species_params$w_inf[sp])
num.t[temp] <- NA
temptemp <- c((numb_all[sp,,]*params@dw[]), (numb_all_sc1[sp,,]*params@dw[]), (numb_all_sc2[sp,,]*params@dw[]))
#temptemp <- c((numb_all[sp,,]*params@dw[]), (numb_all_sc3[sp,,]*params@dw[]), (numb_all_sc4[sp,,]*params@dw[]))
minplot <- min(temptemp[temptemp>0])
maxplot <- max(c((numb_all[sp,,]*params@dw[]), (numb_all_sc1[sp,,]*params@dw[]), (numb_all_sc2[sp,,]*params@dw[])))
#maxplot <- max(c((numb_all[sp,,]*params@dw[]), (numb_all_sc3[sp,,]*params@dw[]), (numb_all_sc4[sp,,]*params@dw[])))

#ben_mort[which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]

plot(log(params@w), log(num.t), type = 'l', col = 'grey', main = mariaParams$species[sp], xlab = "log size group, g", ylab = "Log numbers at size", ylim = c(log(minplot), log(maxplot)))
abline(v = log(params@species_params$w_mat[sp]), lty = 2)
abline(v = log(0.08))

for (i in 2:(dim(params28)[1])) {
num.t <- numb_all[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'grey')
}

#increase plankton kappa
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc3[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'pink')
}
#decrease plankton kappa
for (i in 1:(dim(params28)[1])) {
num.t <- numb_all_sc4[sp,,i]*params@dw
num.t[temp] <- NA
points(log(params@w), log(num.t), type = 'l', col = 'lightblue')
}

}


```

### Compare progressive/immediate change

```{r}
par(mfrow = c(3,3))

for (i in 1:17) {
plot(numb_all_sc2[i,,1]/numb_all_sc2P[i,,1], type = 'l', ylim  = c(0.8, 1.2), main = mariaParams$species[i])
  for (x in 2:29) {
    points(numb_all_sc2[i,,x]/numb_all_sc2P[i,,x], type = 'l')
  }
  abline(h = 1)
}

```


### old biomasses
```{r}
points(biom_median_s1,pch=19, col = 'red')
#points(biom_median_s1P,pch=19, col = 'orange')
points(biom_median_s2,pch=19, col = 'pink')
#points(biom_median_s2P,pch=19, col = 'orange')

points(biom_median_s3,pch=19, col = 'blue')
points(biom_median_s4,pch=19, col = 'lightblue')
points(biom_median_s6,pch=19, col = 'blue')
  


#Plot biomases
biom_mean_base <- apply(biom_all, 1, mean)
biom_min_base <- apply(biom_all, 1, min)
biom_max_base <- apply(biom_all, 1, max)
biom_sd_base <- apply(biom_all, 1, sd)
biom_median_base <- apply(biom_all, 1, median) 
biom_quant_base <- apply(biom_all, 1, quantile)
biom_quant5_base <- apply(biom_all, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s1 <- apply(biom_all_sc1, 1, mean)
biom_min_s1 <- apply(biom_all_sc1, 1, min)
biom_max_s1 <- apply(biom_all_sc1, 1, max)
biom_sd_s1 <- apply(biom_all_sc1, 1, sd)
biom_median_s1 <- apply(biom_all_sc1, 1, median) 
biom_quant_s1 <- apply(biom_all_sc1, 1, quantile)
biom_quant5_s1 <- apply(biom_all_sc1, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s1P <- apply(biom_all_sc1P, 1, mean)
biom_min_s1P <- apply(biom_all_sc1P, 1, min)
biom_max_s1P <- apply(biom_all_sc1P, 1, max)
biom_sd_s1P <- apply(biom_all_sc1P, 1, sd)
biom_median_s1P <- apply(biom_all_sc1P, 1, median) 
biom_quant_s1P <- apply(biom_all_sc1P, 1, quantile)
biom_quant5_s1P <- apply(biom_all_sc1P, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s2 <- apply(biom_all_sc2, 1, mean)
biom_min_s2 <- apply(biom_all_sc2, 1, min)
biom_max_s2 <- apply(biom_all_sc2, 1, max)
biom_sd_s2 <- apply(biom_all_sc2, 1, sd)
biom_median_s2 <- apply(biom_all_sc2, 1, median) 
biom_quant_s2 <- apply(biom_all_sc2, 1, quantile)
biom_quant5_s2 <- apply(biom_all_sc2, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s2P <- apply(biom_all_sc2P, 1, mean)
biom_min_s2P <- apply(biom_all_sc2P, 1, min)
biom_max_s2P <- apply(biom_all_sc2P, 1, max)
biom_sd_s2P <- apply(biom_all_sc2P, 1, sd)
biom_median_s2P <- apply(biom_all_sc2P, 1, median) 
biom_quant_s2P <- apply(biom_all_sc2P, 1, quantile)
biom_quant5_s2P <- apply(biom_all_sc2P, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s3 <- apply(biom_all_sc3, 1, mean)
biom_min_s3 <- apply(biom_all_sc3, 1, min)
biom_max_s3 <- apply(biom_all_sc3, 1, max)
biom_sd_s3 <- apply(biom_all_sc3, 1, sd)
biom_median_s3 <- apply(biom_all_sc3, 1, median) 
biom_quant_s3 <- apply(biom_all_sc3, 1, quantile)
biom_quant5_s3 <- apply(biom_all_sc3, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s4 <- apply(biom_all_sc4, 1, mean)
biom_min_s4 <- apply(biom_all_sc4, 1, min)
biom_max_s4 <- apply(biom_all_sc4, 1, max)
biom_sd_s4 <- apply(biom_all_sc4, 1, sd)
biom_median_s4 <- apply(biom_all_sc4, 1, median) 
biom_quant_s4 <- apply(biom_all_sc4, 1, quantile)
biom_quant5_s4 <- apply(biom_all_sc4, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s5 <- apply(biom_all_sc5, 1, mean)
biom_min_s5 <- apply(biom_all_sc5, 1, min)
biom_max_s5 <- apply(biom_all_sc5, 1, max)
biom_sd_s5 <- apply(biom_all_sc5, 1, sd)
biom_median_s5 <- apply(biom_all_sc5, 1, median) 
biom_quant_s5 <- apply(biom_all_sc5, 1, quantile)
biom_quant5_s5 <- apply(biom_all_sc5, 1, quantile, probs = c(0.05, 0.95))

biom_mean_s6 <- apply(biom_all_sc6, 1, mean)
biom_min_s6 <- apply(biom_all_sc6, 1, min)
biom_max_s6 <- apply(biom_all_sc6, 1, max)
biom_sd_s6 <- apply(biom_all_sc6, 1, sd)
biom_median_s6 <- apply(biom_all_sc6, 1, median) 
biom_quant_s6 <- apply(biom_all_sc6, 1, quantile)
biom_quant5_s6 <- apply(biom_all_sc6, 1, quantile, probs = c(0.05, 0.95))



#plot(biom_mean_base, pch=19, ylim = c(0,8))
#points(biom_mean_s1,pch=19, col = 'red')
#points(biom_mean_base - biom_sd_base)
#points(biom_mean_base + biom_sd_base)
#points(biom_mean_s1 - biom_sd_s1, col = 'red')
#points(biom_mean_s1 + biom_sd_s1, col = 'red')

par(mfrow = c(1,1))
plot(biom_median_base, pch=19, ylim = c(0,8))
points(biom_median_s1,pch=19, col = 'red')
#points(biom_median_s1P,pch=19, col = 'orange')
points(biom_median_s2,pch=19, col = 'pink')
#points(biom_median_s2P,pch=19, col = 'orange')

points(biom_median_s3,pch=19, col = 'blue')
points(biom_median_s4,pch=19, col = 'lightblue')
points(biom_median_s6,pch=19, col = 'blue')

points(biom_quant5_base[1,])
points(biom_quant5_base[2,])
points(biom_quant5_s1[1,], col = 'red')
points(biom_quant5_s1[2,], col = 'red')
#points(biom_quant5_s1P[1,], col = 'orange')
#points(biom_quant5_s1P[2,], col = 'orange')
points(biom_quant5_s2[1,], col = 'pink')
points(biom_quant5_s2[2,], col = 'pink')
points(biom_quant5_s6[1,], col = 'blue')
points(biom_quant5_s6[2,], col = 'blue')


#points(biom_quant5_s2P[1,], col = 'orange')
#points(biom_quant5_s2P[2,], col = 'orange')


points(biom_quant5_s3[1,], col = 'blue')
points(biom_quant5_s3[2,], col = 'blue')
points(biom_quant5_s4[1,], col = 'lightblue')
points(biom_quant5_s4[2,], col = 'lightblue')

```



```{r}
#####


#make an array of time variable effort for each species 
eff_arr = array(0, dim = c(tmax,17))
rowtest <- as.character(seq(from = 1, to = tmax))  # names of years if effort changes through time
#params@species_params$gear <- c("high", "medium", "low","high", "medium", "low","high", "medium", "low","high", "medium", "low","low")
dimnames(eff_arr) = list (rowtest, params@species_params$gear)

eff_arr[,] <- 0
eff_arr[,1] <- 0.1

#eff_arr[c(1:50),] <- 0
#for (i in 1:13) {
#  eff_arr[c(51:100),i] <- rnorm(50,0.4,0.1)
#}

tasm1ef <- project(params, t_max = tmax, effort=eff_arr, dt = 0.2, diet_steps = 0)
yield <- getYield(tasm1ef)
plot(yield[,1], type = 'l')



#remove initial condition rows that have NA biomasses
initial.rows <- which(is.na(accepted.result$relbiom_A_arctidens) == TRUE)
accepted.result <- accepted.result[-initial.rows,]

accepted.result <- ABCresult


```



### Initial biom scalar: DON'T RUN

This scalar is used to get initial biomasses to at least somewhat approximate levels compared to the observations. I don't use it once the model is tuned, because I save tuned final abundances as initial abundances



```{r, eval = F}

temp <- params@initial_n * params@dw # biomass in sizeclass
initBiom <- apply(temp, 1, sum) # total biomass

#compare to observed biomass per m2
mariaParams$BioM2/initBiom

init_scalar <- mariaParams$BioM2/initBiom #compare to observed biomass per m2

#temp2 <- params@initial_n*init_scalar
#bio2 <- apply(temp2,1,sum)
#mariaParams$BioM2/bio2

```


### Second round of selection (ran on clusters)

```{r}

rm(list=ls())
library(mizer, lib.loc = "/home/astaa/R/x86_64-pc-linux-gnu-library/3.5")

# Load tuned parameter files 
runname <- "BEST"
load(file = paste("mariaParams_", runname, ".RData", sep = ""))
load(file = paste("params_", runname, ".RData", sep = ""))
load(file = paste("inter_", runname, ".RData", sep = ""))
load(file = paste("abund_", runname, ".RData", sep = ""))
load(file = paste("npp_", runname, ".RData", sep = ""))
load(file = paste("nbb_", runname, ".RData", sep = ""))
load(file = paste("naa_", runname, ".RData", sep = ""))

load(file = "acceptedResult.RData")

#how many parameter values to search
#iterations = 20000
## setup run time 
tmax = 500
#onegsize <- max(which(params@w < 1)) + 1
#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.5
#test fishing mortality
fish.mort = 0.2

## resource params
kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
lambda = 2.15 #2.1 # 
w_pp_cutoff = 1 #g
r_pp = 1 #2 # rate of regeneration
min_w_pp = 1e-10 #g

kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
w_bb_cutoff = 5 #
r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
min_w_bb = 0.001 # 0.01

kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
w_aa_cutoff = 50 
r_aa = 2 #1 #something to be calibrated
min_w_aa = 0.001
###

#setup result array
#result_arr <- matrix(nrow = length(accepted.result[,1]), ncol = 17*3)

params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)

#parameters for senescence mortality as used in Law et al. 2009
k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)

sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
  
  sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
  
  for (i in 1: length(sppParams$species)) {
    
    mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
    
    sen.mort.m[i,] <- mu_Sen    
  }
  
  # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
  sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
  
  return(sen.mort.m)
  
}

#rmax_orig <- values[c(1:17)]
#gamma_orig <- values[c(18:34)]
#inter_orig <- values[c(35:37)]
#lambda_orig <- values[c(38:40)]

## Now the main loop

  mariaParams$r_max <- as.numeric(accepted.result[iter,c(1:17)])
  
  mariaParams$gamma <- as.numeric(accepted.result[iter,c(18:34)])
  
  availUr <- as.numeric(accepted.result[iter,35])
  availUrLob <- as.numeric(accepted.result[iter,36])
  availSchooling <- as.numeric(accepted.result[iter,37])
  
  # and overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  lambda <- as.numeric(accepted.result[i,38])
  lambda_ben <- as.numeric(accepted.result[i,39])
  lambda_alg <- as.numeric(accepted.result[i,40])
  
  ### setup again with new erepro
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances to correspond to mean abundance per m2 observed
  #params@initial_n <- (params@initial_n/mariaParams$initScalar)
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  
  relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
  biotrends <- getBiomass(tasm1)[tmax,]/getBiomass(tasm1)[100,]
  
  #report results
  result_arr[i,c(1:17)] <- round(relbio, 4)
  result_arr[i,c(18:34)] <- round(biotrends, 4)
  
  ## now fish everything at 0.2
  tasm1ef <- project(params, t_max = tmax, effort= 0.2, dt = dt)
  
  fishbiom <- getBiomass(tasm1ef)[tmax,]/getBiomass(tasm1)[tmax,]
  
  result_arr[i,c(35:51)] <- round(fishbiom, 4)
  
}


save(result_arr, file = "ABC_secondRound.RData")



```


### ABC2: response to fishing
Wrong, as biomases are absolute and not relative to unfished level

```{r}
## Now we wanted to have realistic responses to fishing of one species. We fished one species in PredFishBio, LobsFishBio, UrcFishBio, TraFishBio scenarios. 

abc_second <- abc_second_afterTrachF

## first we see how these four groups respond to their own individual fishing
hist(abc_second$PredFishBio_predator, breaks = 50)
hist(abc_second$LobsFishBio_lobsters, breaks = 50)
hist(abc_second$UrchFishBio_urchins, breaks = 50)
hist(abc_second$TraFishBio_T_caudimaculatus, breaks = 50)

length(which(abc_second$LobsFishBio_lobsters > 0.6 & abc_second$LobsFishBio_lobsters < 1 & abc_second$PredFishBio_predator > 0.3 & abc_second$UrchFishBio_urchins < 1.2 & abc_second$UrchFishBio_urchins > 0.7 & abc_second$TraFishBio_T_caudimaculatus > 0.7 & abc_second$TraFishBio_T_caudimaculatus < 1.2))

goodFishOne <- which(abc_second$LobsFishBio_lobsters > 0.6 & abc_second$LobsFishBio_lobsters < 1 & abc_second$PredFishBio_predator > 0.3 & abc_second$UrchFishBio_urchins < 1.2 & abc_second$UrchFishBio_urchins > 0.7 & abc_second$TraFishBio_T_caudimaculatus > 0.7 & abc_second$TraFishBio_T_caudimaculatus < 1.5)

#save only those runs that give reasonable responses to fishing

abc_second_full <- abc_second
abc_second <- abc_second[goodFishOne,]

```

### 194 scenarios with future 
Does not work; iter does not change param values

```{r}
load(file = "../modelParams/params194.RData")

#library(mizer, lib.loc = "/home/astaa/R/x86_64-pc-linux-gnu-library/3.5")
library(future.apply)
#library(furrr)
plan(multiprocess)

abcres <- function(...)  {
  
  # Load parameter files to initialise the runs. Presumably they will be available to all cores and I don't need to do it inside the function 
  runname <- "N19"
  load(file = paste("../modelParams/mariaParams_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/params_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/inter_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/abund_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/npp_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/nbb_", runname, ".RData", sep = ""))
  load(file = paste("../modelParams/naa_", runname, ".RData", sep = ""))
  load(file = "../modelParams/params194.RData")
  accepted1 <- as.data.frame(params194)
  
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  ## setup run time 
  tmax = 150
  #number of size groups 
  no_size_groups = 200
  #timestep used in the integration 
  dt = 0.5
  
  ## resource params
  kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
  lambda = 2.15 #2.1 # 
  w_pp_cutoff = 1 #g
  r_pp = 1 #2 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  kappa_ben = 6#2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
  lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
  w_bb_cutoff = 5 #
  r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
  min_w_bb = 0.001 # 0.01
  
  kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 #1 #something to be calibrated
  min_w_aa = 0.001
  
  
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, min_w_pp = min_w_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa)
  
  #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
  ## Now the main analysis
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence and juvenile mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) #+ juv_mort(mariaParams, params, juv.sm, juvsw, juv.e)
  
  #run the model
  tasm1 <- project(params, t_max = tmax, effort= 0, dt = dt)
  #get relative biomasses
  biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  #backgr <- c(tasm1@n_pp[tmax,], tasm1@n_bb[tmax,], tasm1@n_aa[tmax,])
  
  #ress<- list()
  #ress$biomass <- biomass
  #ress$numbers <- numbers
  #ress$backgr <- backgr
  
  return(biomass)
  
}

iter <- 4

set.seed(123)

baseline194 <- future_lapply(seq_len(iter), abcres, future.seed = TRUE)
#save(baseline194, file = "../altRuns/baseline194.RData")

## Use this great answer to extract list from lists in R
##https://stackoverflow.com/questions/23758858/how-can-i-extract-elements-from-lists-of-lists-in-r

base_biomass <- lapply(baseline194, '[', c('biomass'))
base_biomass <- data.frame(matrix(unlist(base_biomass), nrow = 194, byrow = T))
colnames(base_biomass) <- mariaParams$species

t1 <- unlist(baseline194[[1]]['biomass'])
t2 <- unlist(baseline194[[4]]['biomass'])
t2/t1

m2 <- lapply(test, '[', c('numbers'))

m1 <- test[[]]['biomass']




#future_map(iter, abcres, .progress = TRUE)

saveRDS(abc1, file = "abc1.rds")





```



### Second ABC round

In this second round I ran simulations with fishing of 0.2 applied to all species simultaneously. Not perfect but gives us some idea about potentially unrealistic responses 

```{r}
runname <- "BEST"
load(file = paste("data/savedParams/mariaParams_", runname, ".RData", sep = ""))

load(file = "acceptedABC1150values.RData")
paramsABC2 <- accepted.result

load(file = "ABC_secondRound.RData")
ABC2 <- result_arr

ABC2_full <-cbind(ABC2, paramsABC2)

#name columns 
cc1 <- paste("relbiom", mariaParams$species, sep="_")
cc2 <- paste("biomtrend", mariaParams$species, sep="_")
cc3 <- paste("fishedbiom", mariaParams$species, sep="_")
column <- c(cc1, cc2, cc3, colnames(paramsABC2))

ABC2_full <- as.data.frame(ABC2_full)
colnames(ABC2_full) <- column

#initialise result columns for the first criterion: relative biomass
ABC2_full$reject1 <- 0
ABC2_full$temp1 <- 0

ABC2_full$reject2 <- 0
ABC2_full$temp2 <- 0

#  I want to reject all results where relative biomass at the end of longer 500 year run are outside the limits
lower.rel.abun <- 0.5
upper.rel.abun <- 2

#  I want to reject all results with biomasses trends, so the biomass of year 500/100 is within 25%
lower.bio.trend <- 0.95
upper.bio.trend<- 1.05

#  I want to reject all results where biomass after fishing is too low or too high
#lower.fish.resp <- 0.5
#upper.fish.resp <- 2

#assess against the first criterion 
for (i in 1:length(mariaParams$species)) {
  #first use rel biom criterion
  temp <- which(ABC2_full[,i] < lower.rel.abun  | ABC2_full[,i] > upper.rel.abun) #relbiomasses are columns 1:17
  ABC2_full$temp1[temp] <- 1
  ABC2_full$reject1 <- ABC2_full$reject1 + ABC2_full$temp1
  
  temp <- which(ABC2_full[,(i+17)] < lower.bio.trend  | ABC2_full[,(i+17)] > upper.bio.trend)  #biomass trends are columns 18:34
  ABC2_full$temp2[temp] <- 1
  ABC2_full$reject2 <- ABC2_full$reject2 + ABC2_full$temp2
  
}

ABC2_crit1 <- ABC2_full[which(ABC2_full$reject1 == 0),] ## relative abundances are in the right range
ABC2_crit2 <- ABC2_full[which(ABC2_full$reject2 == 0),] ## no biomass trends after burnin
ABC2_crit12 <- ABC2_full[which(ABC2_full$reject2 == 0 & ABC2_full$reject1 == 0),] #both criteria used
# generally most runs satisfy both criteria 

#So let's look at how they respond to fishing. Biomasses at the end of fished simulation runs are saved in column 35:51
fish_resp <- ABC2_crit12[,c(35:51)] #select fishing response variables

## plot response to fishing
par(mfrow = c(4,5), mar = c(2,1,1,1))
for (i in 1:17) {
  
  hist(fish_resp[,i], breaks = 15, col = "grey", xlim = c((min(fish_resp[,i])- mean(fish_resp[,i])/2), (max(fish_resp[,i])+ (mean(fish_resp[,i])/2))), main = colnames(fish_resp)[i])

  }

#or look at correlated responses in biomass among some species
#pairs(fish_resp)

## remove some cases where response to overall 0.2 fishing for all species seems unrealistic
#remove cases where T_caudimaculatus resposne to fishing gives biom < 0.5
t3 <- ABC2_crit12[which(ABC2_crit12$fishedbiom_T_caudimaculatus > 0.5),] #Trachinops goes extict
t4 <- t3[which(t3$fishedbiom_P_laticlavius > 0.5),] #Pictilabrus goes extinct
t5 <- t4[which(t4$fishedbiom_lobsters < 1.5),] #lobsters too abundant
t6 <- t5[which(t5$fishedbiom_Notolabrus < 2),] #Notolabrus too abundant
t7 <- t6[which(t6$fishedbiom_L_forsteri > 0.4),] #L forsteri crashing

# and still looking at relative biomasses remove some cases
t8 <- t7[which(t7$relbiom_lobsters < 1.4),] #some combinations have too many lobsters
t9 <- t8[which(t8$relbiom_L_forsteri < 1.3),] #some combinations have too many lobsters
#t8 <- t7[which(t7$relbiom_lobsters < 1.4),] #some combinations have too many lobsters

#This gives 147 parameter combinations

temp_plot <- t9

#Now plot fishing response
par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(temp_plot[,(i+34)], breaks = 20, col = "grey", xlim = c((min(temp_plot[,(i+34)])- mean(temp_plot[,(i+34)])/2), (max(temp_plot[,(i+34)])+ (mean(temp_plot[,(i+34)])/2))), main = colnames(temp_plot)[(i+34)])
}

#Explore correlations in this reduced parameter set
scater <- temp_plot[,c(35:51)] #fishing response
#scater <- temp_plot[,c(1:17)] #relative biomasses
#scater <- temp_plot[,c(18:34)] #trends
pairs(scater)


### plot relative biomasses (compared to observed relative biomasses) in this reduced parameter set
relbio_plot <-t9

par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(relbio_plot[,i], breaks = 15, col = "grey", xlim = c((min(relbio_plot[,i])- mean(relbio_plot[,i])/2), (max(relbio_plot[,i])+ (mean(relbio_plot[,i])/2))), main = colnames(relbio_plot)[i])
}
## Note, for C_laticeps we only have one value left, relative biomass is always, as it is the highest biomass species

#What are the ranges of biomass trends in the reduced parameter set?
## trend plot
trend_plot <- t9
par(mfrow = c(4,5), mar = c(2,1,1,1))

for (i in 1:17) {
  
  hist(trend_plot[,(i+17)], breaks = 15, col = "grey", xlim = c(0.99,1.01), main = colnames(trend_plot)[(i+17)])
}

#Basically none of them show any trends

```



