---
title: "SEA_bentPelModel"
author: "Asta Audzijonyte et al."
date: "7 November 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

### READ ME: explanation

This code shows simulation setup for productivity x warming x fishing scenarios 
We have three types of productivity changes: increased amount (intercept), decreased total amount, and steeper slope
Each of these three changes are applied to pelagic and benthic resource spectrum separately. Together with the baseline this gives 7 scenarios 

For each of the seven scenarios we run two levels of fishing: no fishing and low fixed fishing 
And for all of these scenarios we run two levels of warming: no warming and warming by 2.5C as predicted in the RCP4.5 scenario. The high emission scenario (RCP85) predicts 4C of warming in SE Australia by 2100, which is scary and too hard to accept :(

The warming effect is modeled through changes in intake and metabolism rates, using activation energy of 0.63, according to the Brown et al. 2004 Metabolic theory of ecology. There are many ways how warming might affect species, but here we will use only a simple approach, that is used in many other models. 

Finally, I have 29 parameter combinations selected through the uncertainty evaluation procedure (running 2.2mln combinations and rejecting all runs that do not satisfy certain criteria). So all 28 scenarios are run 29 times to get uncertainty values around them. 

All runs usually stabilise over the 100 year time frame, so we are dealing here with equlibrium conditions, not with transient dynamics. In some parameter combinations some species go extinct with low plankton or low benthos scenarios. Further, in high plankton and high benthos scenarios we often get regular oscillation, especially when fishing is applied. 

For each run I save these outputs (average of the last 30 years to account for the possible effect of oscilations)
- biomasses of all species
- numbers at size for all species
- number at size for the three background spectra (plankton, benthos and algae)
- mean weight of fish above 2.5cm length. These can be used to see how our findings compare with the NEE findings about changing mean sizes of fish
- Community slopes for various species combinations: all species, fish only (exclude lobsters and urchins), and for four functional groups (benthivores, planktivores, predators, herbivores) - not used in the main manuscript
- Proportion of fish above the maturation size - not used
- Yields 

The output datafiles are available in three formats: 
1) the original data.frames saved from the simulations (29x17x28 or similar)
2) original dataframes turned into a long format for ANOVA analyses with added columns to identify treatment effect. The columns identify fishing (1,0), warming (1,0), benthos (1- some changes in benthos spectrum), plankton (1 - some changes in plantkon), kappaUp (1 - either plankton or benthos increase in abundance), kappaDown, slopes (1 - either plankton or benthos slope gets steeper)
3) difference between the first baseline scenario and all other scenarios for each parameter combination. So here we want to see how the scenarios differ. We don't plot all values for each parameter combination, but the difference from the baseline. This way, even if uncertainty in the original range is high, we want to know whether ALL parameter combinations behave in a same way. For example, they might ALL suggest that biomass goes up or down. This difference is what we want to use for plots. 

### ####################
### clear memory

```{r}

rm(list=ls())

```

### Load libraries

```{r warning=FALSE, message=FALSE, warning=FALSE, echo=F}
#list.files()

#remotes::install_github("astaaudzi/mizer", ref = "temp-model-comp")
library(mizerRewire)
list.of.packages <- c("tidyverse", "dplyr", "ggplot2", "ggmap", "vegan", "reshape2", "cowplot", "factoextra", "data.table", "cowplot", "ggeffects")

new.packages<- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
lapply(list.of.packages, require, character.only = TRUE)

#install.packages("viridis")
library(viridis)
library(knitr)
library(lattice)
library(effects)
library(MuMIn)
library(MASS)
#library(hrbrthemes)
library(emmeans)
library(lme4)
library(sjPlot)
library(merTools)
library(ggpubr)
#install.packages("fishualize")
library(fishualize)
#install.packages("glmmTMB")
library(glmmTMB)

library(tidyverse)

```

### ####################
### EXPLORING THE MODEL

The chunks below allow you to explore the model. You can load the main set of parameters as indicated below. If you want to explore other parameter sets (we have 29 combinations of gamma, rmax and interaction matrix parameters that are all considered suitable), you can load the dataframe modelParams/params28ms.RData (commented out below)

### Load params

```{r}
### Load params, data & senescence mort

  load(file = "modelParams/mariaParamsMs.RData") #species parameter file 
  load(file = "modelParams/paramsMs.RData") #built params file
  load(file = "modelParams/inter_N19.RData") #interaction matrix (it is also included in the params file)
  # now load stable numbers at size for all species. I start the runs from equilibrium abundances 
  load(file = "modelParams/abund_N19.RData")
  load(file = "modelParams/npp_N19.RData")
  load(file = "modelParams/nbb_N19.RData")
  load(file = "modelParams/naa_N19.RData")
  
  ## data for invertebrate abundances
  load(file = "modelParams/BenticInvAbund_Tasm.RData")

  #load empirical size spectra in underwater visual survey length bins. Species are grouped as in model groups. Their length-weight conversion is included, and weights per size bins are also calculated. Not sure this is the best way to compare observed spectra to model spectra. Either way we need to bin model size spectra into similar bins. How? 
  load(file = "modelParams/empSizes.RData")
  
## also load senescence mortality function (it is not currently in mizerRewire but is added separately)

 #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }

```


### Load background spectra

```{r warning=T, message=FALSE, echo=T}

#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

## resource params
kappa = 2#intercept assuming g/m2
lambda = 2.15 # 
w_pp_cutoff = 1 #g
r_pp = 1 # rate of regeneration
min_w_pp = 1e-10 #g

kappa_ben = 6 
lambda_ben = 1.9 # this slope does not include urchins and lobsters
w_bb_cutoff = 5 #
r_bb = 1 # 
min_w_bb = 0.001 #

kappa_alg = 16 #
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
w_aa_cutoff = 50 
r_aa = 2 #
min_w_aa = 0.001

```


### Basic run

```{r warning=FALSE, message=FALSE, echo=T}

### setup 
params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)

#update initial abundances to correspond to mean abundance per m2 observed
#params@initial_n <- (params@initial_n/mariaParams$initScalar)
params@initial_n <- stable_abund
params@initial_n_pp <- stable_pl
params@initial_n_bb <- stable_ben
params@initial_n_aa <- stable_alg
## add senescence mortality to background mortality 
params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e) 

## setup run time 
tmax = 100
tasm1 <- mizerRewire::project(params, t_max = tmax, effort= 0, dt = dt, diet_steps = 0)
plot(tasm1)

## comnpare model biomasses to observed biomasses 
getBiomass(tasm1)[tmax,]/mariaParams$BioM2

## check whether relative biomasses are similar to the observed relative biomasses
relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
relbio

#check observed invertebrate abundances
obsInvAb <- sum(InvData$meanAb[which(InvData$wgt > min_w_bb & InvData$wgt < w_bb_cutoff)])
modelInvAb <- sum(tasm1@n_bb[tmax,]*params@dw_full)
#ratio of model vs observed inv abundances (benthic spectrum) in the relevant range
modelInvAb/obsInvAb

### Lots more can be explored and checked 

```

### Alternative parameters 

Here we explore 29 parameter combinations, derived through sequential nudging (see TasmModel_RunningWithRewire.Rmd code)

```{r}
## Now if you want to look at all 29 parameter combinations, they are saved here 

  load(file = "modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)

  ## chose which combination of parameters you want to explore (first one is the same as the baseline)
  # for example I want to check parameter combination 2
  iter = 2
  
  #update Rmax params
  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  #update gamma params
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  
  #update 3 terms of the interaction matrix
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with updated params (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = F)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## add senescence mortality to background mortality 
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e)

  ## do runs as before ...


```

### Fig. S7: model and observed biomases

```{r}

# Observations 
load(file = "modelParams/AllSppStatisticsYear.RData")

#model outputs 
load(file = "outputs/biom.RData")

# observation data. Note for these results I assumed 
# MeanLobWeight = 150 #assume mean lobster weighs 150g
# MeanUrcWeight = 5 # mean urchin 5g
# the data frame has mean abundances, so could be easily recalculated with different mean weights 

plot_obs <- AllSppStatisticsYear %>% filter (year < 2000)  #only take the 1990s

### model results for the 29 parameter combinations 
plot_mod <- as.data.frame(t(biom_all[19,,])) # only take the baseline scenario with fishing; at this stage we do not work with no-fishing scenarios at all 
colnames(plot_mod) <- mariaParams$species
# reshape model data into long format
library(tidyr)
plot_mod_l <- plot_mod %>% gather(group, value)

#Plot 

plot90s <- ggplot(plot_mod_l, aes(x = group, y = value)) +
  geom_boxplot(notch = F, fill = "grey", outlier.colour = 'black', outlier.shape = 1, outlier.fill = 'black' , alpha = 0.5) + 
  geom_boxplot(data=plot_obs, aes(x = modelName, y = meanBio/500), notch = F, fill = "red", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
 # geom_boxplot(data=plot_obs20, aes(x = modelName, y = meanBio/500), notch = F, fill = "orange", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
    theme_bw() +
 # ylim(-1, 1.5) + 
     theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(angle = 90, vjust = 0.5), 
    legend.position="none",
    axis.text=element_text(size=14)
  ) +
  labs(x = "Model group", y = "Biomass, g/m2") 
#  ggtitle("Modelled and observed biomass") 

plot00s <- ggplot(plot_mod_l, aes(x = group, y = value)) +
  geom_boxplot(notch = F, fill = "grey", outlier.colour = 'black', outlier.shape = 1, outlier.fill = 'black' , alpha = 0.5) + 
  #geom_boxplot(data=plot_obs, aes(x = modelName, y = meanBio/500), notch = F, fill = "red", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
  geom_boxplot(data=plot_obs20, aes(x = modelName, y = meanBio/500), notch = F, fill = "red", outlier.colour = 'red', outlier.shape = 1, alpha = 0.5) + 
    theme_bw() +
 # ylim(-1, 1.5) + 
     theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(angle = 90, vjust = 0.5), 
    legend.position="none",
    axis.text=element_text(size=14)
  ) +
  labs(x = "Model group", y = "Biomass, g/m2") 
#  ggtitle("Modelled and observed biomass") 

#garrange(linearplot, logplot, labels = c("linear scale", "log10 scale"), ncol = 2, nrow = 1)
ggarrange(plot90s, plot00s, labels = c("1990s", "2000s"), ncol = 2, nrow = 1)

```

### ####################

### #### Fig. 3 and Fig. S7

code by Camilla Novaglio 
### Get data

```{r}

#rm(list=ls())
# library(ggplot2)
# library(dplyr)
# library(tidyverse)
library(patchwork)

# data 
load("modelParams/mariaParamsMs.RData") #species parameter file 
 load("plotData/biom_tozero.RData")
 load("plotData/size_tozero.RData")
 load("plotData/size_tozeroMat.RData")
# #load("plotData/prolarfish_tozero.RData")
 load("plotData/yield_tozero.RData")
# 
 biom<-biom_tozero 
 yield<-yield_tozero
 size<-size_tozero
 sizeMat<-size_tozeroMat
# #sizeMat<-prolarfish_tozero


# sp names 
#names<-read.csv("/Users/camillan/Dropbox/TasmanianProductivityChange/matchNames.csv")
names<-read.csv("plotData/matchNames.csv")
names<-names[,c(1,4,5)]
colnames(names)<-c("species", "plotName1", "plotName2")

# empircal values 
#empir<-read.csv("/Users/camillan/Dropbox/TasmanianProductivityChange/plotData/ObservedBio_SizeChanges_CN.csv")
empir<-read.csv("plotData/ObservedBio_SizeChanges_CN.csv")

# relativeBioLog and relative_size_change are the ones to use 
empir<-empir %>% 
  dplyr::select(Name, relativeBioLog, relative_size_change) %>% 
  `colnames<-`(c("species","bioEmp", "sizeEmp")) %>% 
  mutate(sizeEmp = round(sizeEmp, 2)) 

# add important info 
empir<- empir %>% 
  full_join(unique(dplyr::select(biom, c(funcgr, species)))) %>% 
  full_join(names)

empirBio1<-empir %>% 
  dplyr::select(species, bioEmp, funcgr, plotName1, plotName2) %>% 
  `colnames<-`(c("species","mean","funcgr", "plotName1", "plotName2")) %>% 
  mutate(scenario = "empirical",
         group_trait ="plankt_kappa") # if you only want to add these data to the 1st panel, otherwise you need to repeat these data for each of the 4 group_trait ("plankt_kappa", "plankt_slope", "benth_kappa", "benth_slope") and add them together ... as done below now 

# this works only for MS plots where you are adding empirical data to the kappa scenarios and not the slope ones, if you need to do the same for SI, you need to extend these dataset to include kappa AND slope 

empirBio2<-empir %>% 
  dplyr::select(species, bioEmp, funcgr, plotName1, plotName2) %>% 
  `colnames<-`(c("species","mean","funcgr", "plotName1", "plotName2")) %>% 
  mutate(scenario = "empirical",
         group_trait ="benth_kappa")

empirBio<-empirBio1 %>% 
  full_join(empirBio2)

empirSize1<-empir %>% 
  dplyr::select(species, sizeEmp, funcgr, plotName1, plotName2) %>% 
  `colnames<-`(c("species","mean","funcgr", "plotName1", "plotName2")) %>% 
  mutate(scenario = "empirical",
         group_trait ="plankt_kappa")

empirSize2<-empir %>% 
  dplyr::select(species, sizeEmp, funcgr, plotName1, plotName2) %>% 
  `colnames<-`(c("species","mean","funcgr", "plotName1", "plotName2")) %>% 
  mutate(scenario = "empirical",
         group_trait ="benth_kappa")

empirSize<-empirSize1 %>% 
  full_join(empirSize2)


```

### Plot biomass - scenarios

Scenarios grouping in notes: 
Less plankton = prodScen = 3 (plankt==1, kappaDown==1)
More plankton = prodScen = 1 (plankt==1, kappaUp==1)
Less benthos = prodScen = 4 (bent==1, kappaDown==1)
More benthos = prodScen = 2 (bent==1, kappaUp==1)
Less warming = warming = 0 (12)
More warming = warming = 1 (14)
Smaller plankton = prodScen = 5 (plankt==1, slopeUp==1)
Bigger plankton = prodScen = 1 (plankt==1, slopeDown==1)
Smaller benthos = prodScen = 5 (plankt==1, slopeUp==1)
Bigger benthos = prodScen = 1 (plankt==1, slopeDown==1)
no fishing = fishing = 0 (f0)
fishing = fishing = 1 (f1)

baselines: 
baseline_14_f0 # warming with no fishing  
baseline_14_f2 # warming with fishing  

### produce plots

```{r}

# add max size info for species ordering below

#Asta: this does not work for me, so taking max size from maria params file
#maxS<-unique(biom[,c("species","maxSize")])
load(file = "modelParams/mariaParamsMs.RData") #species parameter file 
maxS <- mariaParams[,c("species","Linf")]

biom<-biom %>% 
  #select(-maxSize) %>%  #Asta: maxSize is not in the biom file
  mutate(change = "Biomass change") %>% 
  full_join(names)
  
size<-size %>% 
  mutate(change = "Size change") %>% 
  full_join(names)
# 
sizeMat<-sizeMat %>%
  mutate(change = "Size change Mat") %>%
  full_join(names)
  
yield<-yield %>% 
  mutate(change = "Yield change") %>% 
  full_join(names)

# loop trough plot data data

plot_data<-list(biom = biom, yield = yield, size = size, sizeMat = sizeMat)
title<-list("Biomass change", "Yield change","Size change","Size Mat change")

# deal with empirical data to be plotted only on biomass and size (not yield)
labels1 <- c("Increase", "Decrease", "Increase & warming","Decrease & warming","Warming", "Field data")
labels2 <- c(c("Increase", "Decrease", "Increase & warming","Decrease & warming","Warming"))
labels<-list(biom = labels1, yield = labels2, size = labels1, sizeMat = labels1)
color1<-c("#9ecae1", "#3182bd", "#fdd0a2", "#fd8d3c", "red","black")
color2<-c("#9ecae1", "#3182bd", "#fdd0a2", "#fd8d3c", "red")
colors<-list(biom = color1, yield = color2, size = color1, sizeMat = color1) 
shape1<-c(19, 17, 19, 17, 18, 19) #instead of 18 we had 165 
shape2<-c(19, 17, 19, 17, 18)
shapes<-list(biom = shape1, yield = shape2, size = shape1, sizeMat = shape1) 

# set plots limits
lim<-list(biom = c(-1.2, 1.2), yield = c(-1.2, 1.2), size = c(-1.2, 1.2), sizeMat = c(-0.5, 0.5))

plot_list<-list()
data_list<-list()

for (i in 1:length(plot_data)){
  
  # i = 2
  a<-plot_data[[i]]

  # define baseline - IF FISHING use 14_f2
  baseline <- a %>% 
    filter(scenario == "baseline_14_f2")

  # remove baseline from main dataset
  remove_baseline<-unique(a$scenario)[grepl("baseline",unique(a$scenario))==TRUE]
  a<-a %>% 
    filter(!scenario %in% remove_baseline)

  # plankton kappa/slope, benthos kappa/slope  
  a$group_trait<-ifelse(grepl("benth",a$scenario), "benth", "plankt")
  a$group_trait2<-ifelse(grepl("large",a$scenario), "slope",
                         ifelse(grepl("small",a$scenario), "slope", 
                                ifelse(grepl("more",a$scenario), "kappa", "kappa")))

  a$group_trait<-paste(a$group_trait, a$group_trait2, sep= "_")

  a$scenario<-gsub("benth_", "",a$scenario) # used as main grouping variable
  a$scenario<-gsub("plankt_", "",a$scenario)

  # increase and decrease in plankton kappa/slope, benthos kappa/slope  
  a$scenario<-gsub("large_", "increase",a$scenario) # used as secondary grouping variable - scenarios dots
  a$scenario<-gsub("small_", "decrease",a$scenario)
  a$scenario<-gsub("less_", "decrease",a$scenario)
  a$scenario<-gsub("more_", "increase",a$scenario)

  # warming 
  a$scenario<-gsub("12_", "",a$scenario) # used as secondary grouping variable - scenarios dots
  a$scenario<-gsub("14_", "_warming",a$scenario)

  # fishing
  a$group_fishing<- ifelse(a$fishing==1, "fishing", "no fishing") # used as main grouping variable
  a$scenario<-gsub("f0", "",a$scenario)
  a$scenario<-gsub("f2", "",a$scenario)

  # it seems there is only fishing here - do we still want no fishing in SI?  
  #unique(a$group_fishing)
  
  # add baseline for each scenario (repeat)
  baseline$scenario<-"warming"
  w1<-baseline %>% 
    mutate(group_trait = unique(a$group_trait)[1],
           group_trait2 = NA,
           group_fishing = "fishing") # should this change according to 'fishing' or 'not fishing'? 
  w2<-baseline %>% 
      mutate(group_trait = unique(a$group_trait)[2],
           group_trait2 = NA,
           group_fishing = "fishing")
  w3<-baseline %>% 
      mutate(group_trait = unique(a$group_trait)[3],
           group_trait2 = NA,
           group_fishing = "fishing")
  w4<-baseline %>% 
      mutate(group_trait = unique(a$group_trait)[4],
           group_trait2 = NA,
           group_fishing = "fishing")

  # data re-arranging
  b<-a %>% 
    bind_rows(w1,w2,w3,w4) %>% 
    # filter(group_fishing == "fishing") %>% # decide on FISHING or NOT (not is in SI)
    # filter(group_fishing == "no fishing") %>%
    group_by(group_trait, scenario, funcgr, species, plotName1, plotName2) %>% 
    summarise(mean = mean(value), sd = sd(value)) %>% 
    ungroup()
  
  # add empirical data to biomass and size plot
  if(names(plot_data[i]) == "biom"){
    b<-b %>% 
    full_join(empirBio)
  }else if(names(plot_data[i]) == "size"){
    b<-b %>% 
    full_join(empirSize)
  }

  # reorder factors 
  # group trait - facetting factor 
  b$group_trait<-as.factor(b$group_trait)
  b$group_trait<-factor(b$group_trait, levels = c("plankt_kappa", "plankt_slope", "benth_kappa", "benth_slope"))

  # scenario - legend factor - need to add data for biomass and size 
  b$scenario<-as.factor(b$scenario)
  if(names(plot_data[i]) == "yield"){
   b$scenario<-factor(b$scenario, levels = c("increase","decrease","increase_warming", "decrease_warming","warming")) 
  }else{
    b$scenario<-factor(b$scenario, levels = c("increase","decrease","increase_warming", "decrease_warming","warming","empirical"))
  }

  # reorder species according to traits and maxS - but using plotName1: 
  # benthivores, planktivores, herbivores and predators from top to bottom
  b$funcgr<-as.factor(b$funcgr)
  b$funcgr<-factor(b$funcgr, levels = c("omni","plankt","herbi", "predat"))
  b<-merge(b,maxS)
  
  # removing hulafish for yield 
  # this is missing from yield data and it messes up the factor sorting below. if you want to keep these spp, you need to add all the missing info for this spp: 
  # filter(b, plotName1 == "hulafish")
  if(names(plot_data[i]) == "yield"){
    b<-b %>% 
      filter(species != "T_caudimaculatus")
  }
  
  b<-with(b, b[order(funcgr,Linf),])
  spOrder<-rev(unique(b$plotName1)) ## CHANGE NAMES plotName1 
  b$plotName1<-factor(b$plotName1, levels = spOrder) ## CHANGE NAMES plotName1 

  # new facet label names
  # temp.labs<- c("Plankton abundance", "Plankton slope","Benthos abundance", "Benthos slope") # for SI where you show them all 
  temp.labs<- c("PLANKTON", "Plankton slope","BENTHOS", "Benthos slope") # for MS where you show only kappa
  names(temp.labs) <- c("plankt_kappa", "plankt_slope", "benth_kappa", "benth_slope")
  
  # if MS 
  #b<-b %>% filter(!group_trait %in% c("plankt_slope","benth_slope"))
  #if Supplement
  b<-b %>% filter(!group_trait %in% c("plankt_kappa","benth_kappa"))

  pd<-position_dodge(0.5)
  
  ## CHANGE NAMES plotName1 
  plot<-ggplot(b, aes(x=mean, y=plotName1, group=scenario, color=scenario, shape = scenario))+
    geom_vline(xintercept = 0, linetype = "dashed")+
    # xlim(lim[[i]])+
    geom_errorbar(aes(xmin=mean-sd, xmax=mean+sd), width=0.5, position=pd)+
    geom_point(position=pd, size=2)+
    scale_x_continuous(name = title[[i]], limits = lim[[i]]) +
    scale_y_discrete(name = NULL)+
    scale_color_manual(values = colors[[i]],
                       name = "Scenario",
                       labels = labels[[i]])+  
    scale_shape_manual(values = shapes[[i]],
                       name = "Scenario",
                       labels = labels[[i]])+ 
    theme_bw()+
    theme(text = element_text(size=16),
          axis.title.y = element_text(vjust=0.4, size = 14),
          axis.title.x = element_text(vjust=0.3, size = 14),
          axis.text.x = element_text(hjust=0.5, size = 12),
          axis.text.y = element_text(size = 12),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(color = "black", fill = "white"))+
    
    # gray shadings ... better doing this outside the loop as yield has different min max to consider because of 1 spp is not included/caught. it will be OK to do the gray shading area here if that spp is included - see above.   
    
    facet_wrap(vars(group_trait),
               labeller = labeller(group_trait = temp.labs), 
               nrow = 1)

  plot_list[[i]]<-plot
  names(plot_list)[i]<-names(plot_data)[i]
  data_list[[i]]<-b
  names(data_list)[i]<-names(plot_data)[i]
  
}

```

### check limits

```{r}
lim
plot_list$biom
plot_list$yield 
plot_list$size
#plot_list$sizeMat

```

### Final plots 

```{r}

# add square and text to first plot - could do only first panel of first plot but requires more work 
ref<-data_list$biom
a<-plot_list$biom + 
  expand_limits(y = c(0, 18))+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 1, ymax = 4, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 5, ymax = 7, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 8, ymax = 9, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 10, ymax = 17, alpha = .15, fill = "grey40")+
  annotate("text", x = 0.8, y = 17.5, label = "Benthivores", color = "grey40",size = 4)+
  annotate("text", x = 0.8, y = 9.5, label = "Planktivores", color = "grey40",size = 4)+
  annotate("text", x = 0.8, y = 7.5, label = "Herbivores", color = "grey40",size = 4)+
  annotate("text",x = 0.8, y = 4.5, label = "Predators", color = "grey40", size = 4)
plot_list$biom<-a

ref<-data_list$yield
a<-plot_list$yield + 
  expand_limits(y = c(0, 17))+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 1, ymax = 4, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 5, ymax = 7, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 8, ymax = 8.3, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 9, ymax = 16, alpha = .15, fill = "grey40")+
  annotate("text", x = 0.8, y = 16.5, label = "Benthivores", color = "grey40",size = 4)+
  annotate("text", x = 0.8, y = 8.7, label = "Planktivores", color = "grey40",size = 4)+
  annotate("text", x = 0.8, y = 7.5, label = "Herbivores", color = "grey40",size = 4)+
  annotate("text",x = 0.8, y = 4.5, label = "Predators", color = "grey40", size = 4)
plot_list$yield<-a

# now need to do on size too as they become 2 plots 
ref<-data_list$size
a<-plot_list$size + 
  expand_limits(y = c(0, 18))+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 1, ymax = 4, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 5, ymax = 7, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 8, ymax = 9, alpha = .15, fill = "grey40")+
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = 10, ymax = 17, alpha = .15, fill = "grey40")+
  annotate("text", x = 0.8, y = 17.5, label = "Benthivores", color = "grey40",size = 4)+
  annotate("text", x = 0.8, y = 9.5, label = "Planktivores", color = "grey40",size = 4)+
  annotate("text", x = 0.8, y = 7.5, label = "Herbivores", color = "grey40",size = 4)+
  annotate("text",x = 0.8, y = 4.5, label = "Predators", color = "grey40", size = 4)
plot_list$size<-a

# ref<-data_list$sizeMat
# a<-plot_list$sizeMat + 
#   expand_limits(y = c(0, 18))+
#   annotate("rect", xmin = -Inf, xmax = Inf, ymin = 1, ymax = 4, alpha = .15, fill = "grey40")+
#   annotate("rect", xmin = -Inf, xmax = Inf, ymin = 5, ymax = 7, alpha = .15, fill = "grey40")+
#   annotate("rect", xmin = -Inf, xmax = Inf, ymin = 8, ymax = 9, alpha = .15, fill = "grey40")+
#   annotate("rect", xmin = -Inf, xmax = Inf, ymin = 10, ymax = 17, alpha = .15, fill = "grey40")+
#   annotate("text", x = 0.1, y = 17.5, label = "Benthivores", color = "grey40",size = 4)+
#   annotate("text", x = 0.1, y = 9.5, label = "Planktivores", color = "grey40",size = 4)+
#   annotate("text", x = 0.1, y = 7.5, label = "Herbivores", color = "grey40",size = 4)+
#   annotate("text",x = 0.1, y = 4.5, label = "Predators", color = "grey40", size = 4)
# plot_list$sizeMat<-a

# adjust legend 
plot_list$yield<-plot_list$yield + theme(legend.position = "none")
plot_list$size<-plot_list$size + theme(legend.position = "none")
#plot_list$sizeMat<-plot_list$sizeMat + theme(legend.position = "none")

# refine legend... 
# g_legend<-function(a.gplot){
#   tmp <- ggplot_gtable(ggplot_build(a.gplot))
#   leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
#   legend <- tmp$grobs[[leg]]
#   return(legend)}
# 
# mylegend<-g_legend(plot_list$biom)
# 
# plot_list$biom<-plot_list$biom + theme(legend.position = "none")

# plot1<-plot_list$biom / plot_list$yield +  plot_layout (nrow = 2)
# plot2<- plot1 + mylegend + plot_layout (nrow = 2)

#setwd("/Users/camillan/Dropbox/TasmanianProductivityChange/plots/20210309")
# fig 1 - biomass and Yield 
#pdf("BioYieldSize_slopes.pdf", height=13, width=10)
plot_list$biom / plot_list$yield /plot_list$size +  plot_layout (nrow = 3)
#dev.off()

# # fig 2 - Size 
# pdf("Size_fishing_name1.pdf", height=8, width=10)
# plot_list$size / plot_list$sizeMat  + plot_layout (nrow = 2)
# dev.off()

# old versions and names... 
# # paste the 4 plots vertically and print in 1 fig (no yield for the SI plot)
# setwd("/Users/nov017/Dropbox/TasmanianProductivityChange/plots")
# # setwd("/Users/nov017/Desktop")
# jpeg("Bio_CN_option5_Fishing.jpeg", height=13, width=12, units ='in', res=300)
# plot_list$biom / plot_list$size / plot_list$yield + plot_layout (nrow = 3)#, ncol = 2) #heights = c(1,1,1,1)
# dev.off()

# setwd("/Users/nov017/Dropbox/TasmanianProductivityChange/plots")
# # setwd("/Users/nov017/Desktop")
# jpeg("Bio_CN_option5_Fishing_SI.jpeg", height=13, width=18, units ='in', res=300)
# plot_list$biom / plot_list$size / plot_list$yield + plot_layout (nrow = 3)#, ncol = 2) #heights = c(1,1,1,1)
# dev.off()

```

### ###################### 
### ANOVA

### packages

```{r}
library(knitr)
library(lattice)
library(effects)
library(MuMIn)
library(MASS)
#library(hrbrthemes)
library(emmeans)
library(lme4)
library(sjPlot)
library(merTools)
library(ggpubr)
#install.packages("fishualize")
library(fishualize)
#install.packages("glmmTMB")
library(glmmTMB)

library(tidyverse)

```

### main analyses

After various explorations (see in the leftover section) it was found that mixed effect model with two-way anova is the way to go

```{r}
## these are the three response variable datasets:
load(file = "plotData/biom_relative.RData") # biomasses of species relative to the baseline scenario 
load(file = "plotData/yield_relative.RData") #mean weight of fish above the maturation weight - relative
load(file = "plotData/size_relative.RData") 

# function to make it easier to extract and re-filter the data, assume only kappas here but could easily add slope if needed

getData <- function(dat=biom_relative,resource="benthic",slopes=F) {
  df <- dat
 
   if (resource == "benthic" & slopes ==F) {
  df <- df %>% filter (prodScen == 0 | prodScen == 2 | prodScen == 4)   %>%
      filter (fishing == 1)
  df$backgr <- df$product
  }

  if (resource == "benthic" & slopes ==T) {
  df <- df %>% filter (prodScen == 0 | prodScen == 6 | prodScen == 8) %>% filter (fishing == 1)
  df$backgr <- df$slopeChange
  }

  if (resource == "plankton" & slopes ==F) {
  df <- df %>% filter (prodScen == 0 | prodScen == 1 | prodScen == 3)   %>%     filter (fishing == 1)
  df$backgr <- df$product
  }
  
   if (resource == "plankton" & slopes ==T) {
  df <- df %>% filter (prodScen == 0 | prodScen == 5 | prodScen == 7) %>% filter (fishing == 1)
  df$backgr <- df$slopeChange
  }
  
 df   
 
}

### FUNCTIONAL GROUPS -  MIXED EFFECTS MODEL

options(na.action = na.fail)

### kappas
# these data now all need separate anovas
df_be_bio<-getData(dat=biom_relative,resource="benthic")
df_pl_bio<-getData(dat=biom_relative,resource="plankton")

df_be_size<-getData(dat=size_relative,resource="benthic")
df_pl_size<-getData(dat=size_relative,resource="plankton")

df_be_yield<-getData(dat=yield_relative,resource="benthic")
df_pl_yield<-getData(dat=yield_relative,resource="plankton")

# We don't do lambdas at the moment
### lambdas
# these data now all need separate anovas
# df_be_bio<-getData(dat=biom_relative,resource="benthic",slopes=T)
# df_pl_bio<-getData(dat=biom_relative,resource="plankton",slopes=T)
# 
# df_be_size<-getData(dat=size_relative,resource="benthic",slopes=T)
# df_pl_size<-getData(dat=size_relative,resource="plankton",slopes=T)
# 
# df_be_yield<-getData(dat=yield_relative,resource="benthic",slopes=T)
# df_pl_yield<-getData(dat=yield_relative,resource="plankton",slopes=T)

####### benthic models

# to be consistent across groups and datatypes we use two-way anova with species as random effect 

#mbe_bio <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_be_bio, REML = T)
mbe_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_bio, REML = T)
#mbe_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_be_bio, REML = T)
#dredge(mbe_bio) # check
#plot_model(mbe_bio,type="diag") # check

t1 <- data.frame(coef(summary(mbe_bio)))
t2 <- data.frame(confint(mbe_bio))
t_mbe_bio <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

#write.table(t, file = "model_out.txt", sep = ", ", quote = FALSE, row.names = F)

anova(mbe_bio)
plot_model(mbe_bio,type="pred",terms=c("funcgr","backgr","warming")) # check
summary(mbe_bio)

# mbe_size <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_be_size, REML = F)
# mbe_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_size, REML = F)
 mbe_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_size, REML = F)
# mbe_sizeMat <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_sizeMat, REML = F)

#dredge(mbe_size) # check
#plot_model(mbe_size,type="diag") # check
#refit best model

plot_model(mbe_size,type="pred",terms=c("funcgr","backgr","warming")) 

t1 <- data.frame(coef(summary(mbe_size)))
t2 <- data.frame(confint(mbe_size))
t_mbe_size <- cbind(t1[,1], t2[-c(1,2),], t1[,3])



# mbe_yield <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_be_yield, REML = F)
 mbe_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_be_yield, REML = F)
# mbe_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_be_yield, REML = F)

#dredge(mbe_yield) # check
#plot_model(mbe_yield,type="diag")# check
#refit best model

plot_model(mbe_yield,type="pred",terms=c("funcgr","backgr","warming")) 
#plot_model(mbe_yield_2,type="pred",terms=c("funcgr","backgr","warming")) 

t1 <- data.frame(coef(summary(mbe_yield)))
t2 <- data.frame(confint(mbe_yield))
t_mbe_yield <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

knitr::kable(list(t_mbe_bio, t_mbe_yield, t_mbe_size), format = "simple", digits = 3, col.names = c("Estimate", "2.5%CI", "97.5%CI", "t-value"))
write.table(rbind(t_mbe_bio, t_mbe_yield, t_mbe_size), file = "temp.csv", sep = ",", quote = FALSE, row.names = F)

####### plankton models

#mpl_bio <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_pl_bio, REML = T)
mpl_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_bio, REML = T)
#mpl_bio <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_pl_bio, REML = T)
#dredge(mpl_bio) # check
#plot_model(mpl_bio,type="diag") # check
# refit best model
#mpl_bio <- lmer(value ~ 1 + funcgr*backgr*warming + (1|funcgr:species), data = df_pl_bio, REML = T)
anova(mpl_bio)
plot_model(mpl_bio,type="pred",terms=c("funcgr","backgr","warming")) # check

t1 <- data.frame(coef(summary(mpl_bio)))
t2 <- data.frame(confint(mpl_bio))
t_mpl_bio <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

#because urchins have weirdest mean sizes in less_plankton scenarios (because they collapse) we set this na.omit for this one case
options(na.action = na.omit)
#mpl_size <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_pl_size, REML = T)
mpl_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_size, REML = T)

#mpl_size <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_pl_size, REML = T)
#dredge(mpl_size) # check
#plot_model(mpl_size,type="diag") # check
#refit best model
#mpl_size <- lmer(value ~ 1 + backgr*funcgr + backgr*warming + (1|funcgr:species), data = df_pl_size, REML = T)
#anova(mpl_size)
plot_model(mpl_size,type="pred",terms=c("funcgr","backgr","warming")) # check
#plot_model(mpl_sizeN,type="pred",terms=c("funcgr","backgr","warming")) # check
#plot_model(mpl_sizeMat,type="pred",terms=c("funcgr","backgr","warming")) # check

t1 <- data.frame(coef(summary(mpl_size)))
t2 <- data.frame(confint(mpl_size))
t_mpl_size <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

options(na.action = na.fail)
#mpl_yield <- lmer(value ~ 1 + funcgr*backgr*warming + (1|species), data = df_pl_yield, REML = T)
mpl_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|species), data = df_pl_yield, REML = T)
#mpl_yield <- lmer(value ~ 1 + funcgr*backgr + funcgr*warming + backgr*warming + (1|funcgr:species), data = df_pl_yield, REML = T)
#dredge(mpl_yield) # check
#plot_model(mpl_yield,type="diag")# check
#refit best model
#mpl_yield <- lmer(value ~ 1 + backgr*funcgr*warming + (1|funcgr:species), data = df_pl_yield, REML = T)
#anova(mpl_yield)
plot_model(mpl_yield,type="pred",terms=c("funcgr","backgr","warming")) # check

t1 <- data.frame(coef(summary(mpl_yield)))
t2 <- data.frame(confint(mpl_yield))
t_mpl_yield <- cbind(t1[,1], t2[-c(1,2),], t1[,3])

knitr::kable(list(t_mpl_bio, t_mpl_yield, t_mpl_size), format = "simple", digits = 3, col.names = c("Estimate", "2.5%CI", "97.5%CI", "t-value"))


### combine model results into a table format
sstable<-rbind(anova(mpl_bio), anova(mpl_yield), anova(mpl_size), anova(mbe_bio), anova(mbe_yield), anova(mbe_size))

sstable <- anova(mbe_bio)

sstable$pes <- c(sstable$'Sum Sq'[-nrow(sstable)], NA)/(sstable$'Sum Sq' + sstable$'Sum Sq'[nrow(sstable)]) # SS for each effect divided by the last SS (SS_residual)
sstable
kable(sstable, digits = 2, knitr.kable.NA = " ") # the digits argument controls rounding

sstable$pes <- c(sstable$'Sum Sq'[-nrow(sstable)], NA)/(sstable$'Sum Sq' + sstable$'Sum Sq'[nrow(sstable)]) # SS for each effect divided by the last SS (SS_residual)

# 
# myTable <- dredge(m1)
# myTable$`(Intercept)`<-round(myTable$`(Intercept)`,digits = 2)
# myTable$logLik <- round(myTable$logLik, digits = 2)
# myTable$AICc <- round(myTable$AICc, digits = 2)
# myTable$delta <- round(myTable$delta, digits =2)
# myTable$weight <- round(myTable$weight, digits = 2)
# myTable <- myTable[1:10,]
# colnames(myTable)[2:8] <- c("fsh","prd","sp","fsh:prd","fsh:sp","prd:sp","f:p:s")
# saveRDS(myTable, file = "ModelSelectionTable.rds")
#  
# kable(dredge(m1), digits = 3,knitr.kable.NA = '') # the digits argument controls rounding


```

### Get and save model predictions

```{r,warnings=F}

### extract predictions ... predict works ok for this, because we dont need 95CIs for this plot (eg. fixed effects only)

library(ggeffects)
# get predicted values for each model

#### plankton models
pred <- rbind(
as.data.frame(ggpredict(mpl_bio, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mpl_size, terms = c("funcgr","backgr","warming"))),
#as.data.frame(ggpredict(mpl_sizeN, terms = c("funcgr","backgr","warming"))),
#as.data.frame(ggpredict(mpl_sizeMat, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mpl_yield, terms =c("funcgr","backgr","warming"))))

names(pred)<- c("funcgr"     ,    "fit", "stderror" ,"conflow" , "confhigh" ,"backgr"  ,   "warming")

#pred$index <- rep(c("bio","size","sizeN","sizeMat","yield"),each=24)
pred$index <- rep(c("bio","size","yield"),each=24)
predn <- pred

save(predn, file = "plotData/anova_plankton.RData")

#### benthic models
predb <- rbind(
as.data.frame(ggpredict(mbe_bio, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mbe_size, terms = c("funcgr","backgr","warming"))),
#as.data.frame(ggpredict(mbe_sizeN, terms = c("funcgr","backgr","warming"))),
#as.data.frame(ggpredict(mbe_sizeMat, terms = c("funcgr","backgr","warming"))),
as.data.frame(ggpredict(mbe_yield, terms =c("funcgr","backgr","warming"))))

names(predb)<-c("funcgr"     ,    "fit", "stderror" ,"conflow" , "confhigh" ,"backgr"  ,   "warming")
predb$index <- rep(c("bio","size","yield"),each=24)

predbn <- predb

save(predbn, file = "plotData/anova_benthos.RData")
```

### Fig 4: anova plot

```{r}

load(file = "plotData/anova_benthos.RData") #dataframe predbn
load(file = "plotData/anova_plankton.RData") #dataframe predn

head(predbn) #benthos
head(predn) #plankton

library(ggplot2)
library(tidyverse)
#Libraries for the final plot arrangement & pictures:
library(patchwork)
library(png)
library(grid)

plotThis<-function(predn){
  
  #predn<-predbn
  
  # functional group vs anova fit
  predn$index<-as.factor(predn$index)
  predn$index <- ordered(predn$index, levels = c("bio", "yield", "size"))
  # new facet label names
  temp.labs<- c("BIOMASS", "YIELD", "SIZE") # for MS where you show only kappa
  names(temp.labs) <- c("B","Y", "S")
  
  # y axis 
  predn$funcgr<-as.factor(predn$funcgr)
  predn$funcgr <- ordered(predn$funcgr, levels = c("predat", "herbi", "plankt","omni"))
  #labely = c("Predators","Herbivores", "Planktivores", "Benthivores")
  
  #Names list for the facet:
  names2 <- c('Predators','Herbivores','Planktivores','Benthivores')
  names(names2) <- c( 'predat', 'herbi', 'plankt','omni')
  
  # x axis  
  title<-"ANOVA fit"
  
  # legend
  predn <-predn %>% 
    mutate(backgr = ifelse(backgr == 0, "no change", ifelse(backgr == 1, "increase", "decrease")), 
           warming = ifelse(warming == 0, "no warming", "warming"), 
           new = as.factor(paste(backgr, warming, sep = " ")))
  
  predn$new <- ordered(predn$new, levels = c("increase no warming", "decrease no warming", "increase warming", "decrease warming", "no change warming", "no change no warming")) # plots 
  label1 <- c("Increase", "Decrease", "Increase & warming","Decrease & warming","Warming", "No changes")
  color1<-c("#9ecae1", "#3182bd", "#fdd0a2", "#fd8d3c", "red","black")
  shape1<-c(19, 17, 19, 17, 18, 19)
  
  predn2<-predn %>% 
    dplyr::filter(index %in% c("bio","size","yield")) %>% 
    dplyr::filter(new !=  "no change no warming") # this is just on the 1 line 
  
  # explore limits for each trophic group + index (min and max, for the arrows)
  # min(predn2$fit) # 0.24
  # max(predn2$fit) # 2.23
  
  #Create a dataframe for the arrows: 
  arrow_frame  <- data.frame(
                    y1 = c(0.65,0.65,0.65,0.65), #y axis (slightly left of the biomass y)
                    x1 = c(1,1,1,1), #starting point for the arrow
                    #end point of the arrow+direction:
                    x2 = c(max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='predat'&predn2$backgr=='increase']), max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='herbi'&predn2$backgr=='increase']), max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='plankt'&predn2$backgr=='increase']),max(predn2$fit[predn2$index=='bio'&predn2$funcgr=='omni'&predn2$backgr=='increase'])),
                    funcgr = (levels(predn2$funcgr))) #assign the functional group
  
  pd<-position_dodge(0.3)
  
  plot<-ggplot(predn2, aes(x=fit, y=index, group=new, colour=new, shape=new))+
    geom_vline(xintercept = 1, linetype = "dashed", color='darkgrey')+
    geom_hline(yintercept = 3.6, linetype = "dashed", color='grey85')+
    geom_errorbar(aes(xmin=conflow, xmax=confhigh), width=0.1, position=pd, alpha=0.5)+
    geom_point(position=pd, size=2)+
    
    #add arrows that indicate an increase in biomass, when benthos/plankton increases. From 1 to light blue dot. Positive when >0, negative when <0
    #each geom_segment creates own arrow for each facet (functional group in this case)
    geom_segment(data=arrow_frame,   
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05), 
                 lineend = "butt", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    geom_segment(data=arrow_frame,
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05),
                 lineend = "round", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    geom_segment(data=arrow_frame,
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05),
                 lineend = "round", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    geom_segment(data=arrow_frame, 
                 aes(x=x1,y=y1,yend=y1,xend=x2+0.05), 
                 lineend = "round", linejoin = "round", size=1.2,
                 arrow = arrow(length = unit(0.1, "inches")), colour = "black", inherit.aes=FALSE)+
    
    #no more missing values when set to 0.5 to 1.7 (only the two outliers from 1.9-2.4 for plankton + 2 from 0-0.5, all for Planktivores/Yield)
    scale_x_continuous(name = "Relative change", limit=c(0.5,1.7))+ # , breaks=c(0.6,1,1.6), labels=c("0.6"="-0.6","1"="0","1.6"="0.6")) +
    scale_y_discrete(name = NULL, labels = names(temp.labs))+
    scale_color_manual(values = color1,
                       name = "Scenario",
                       labels = label1)+
    scale_shape_manual(values = shape1,
                       name = "Scenario",
                       labels = label1)+ 
    theme_bw()+
    theme(text = element_text(size=10),
          legend.key.size = unit(0.4, "cm"),
          axis.title.y = element_text(vjust=0.4, size = 8),
          axis.title.x = element_text(vjust=0.5, size = 12),
          axis.text.x = element_text(hjust=0.5, size = 8),
          axis.text.y = element_text(size = 8),
          plot.margin = unit(c(0, 0, 0, 0), "cm"), #top, right, bottom, left
          strip.background = element_rect(color = "white", fill = "lightgrey"), 
          # Remove panel border
          panel.border = element_blank(),  
          # Remove panel grid lines
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          # Remove panel background
          panel.background = element_rect(fill = "grey99"),
          # Add axis line
          axis.line = element_line(colour = "grey"))+
     facet_wrap(~funcgr,
               labeller = labeller(funcgr = names2), 
               nrow = 1)+
    coord_flip() #flip the axes, having Anova fit on the x-axis for better readability

  return(plot = plot)
}

# plot2 <- plotPl
# plot1 <- plotB
# saveRDS(plot2, file = "plot2.rds")
# saveRDS(plot1, file = "plot1.rds")

plot1 <- plotThis(predbn) #benthos
plot2 <- plotThis(predn) #plankton

#3. plot showing the upper outliers (will get stagged on the other plot)
plot3 <- plot2 + 
          scale_x_continuous(name = "Relative change", limit=c(1.9,2.4), breaks=c(1.9,2.4)) + #adapting the scale for the staggered plot
          theme( #remove axis labels, text + line
            axis.title.x=element_blank(),
            axis.title.y=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank(),
            axis.line.x = element_blank(),
            plot.margin = unit(c(0, 0, 0.5, 0), "cm")) #add some space to the other plot

#remove the strip text for the facets, will only be on the second plot
plot1 <- plot1 + theme(
          strip.background = element_blank(),
          strip.text.x = element_blank())
plot2 <- plot2 + theme(
          strip.background = element_blank(),
          strip.text.x = element_blank())

#Load images and safe them as plots:

predat <- png::readPNG("plotData/herbivore2.png")
herbi <- png::readPNG("plotData/benthivore2.png")
plankt <- png::readPNG("plotData/planktivore2.png")
benthi <- png::readPNG("plotData/predator2.png")

plot_h <- ggplot()+ annotation_custom(rasterGrob(herbi,width = unit(1,"npc"), height = unit(1,"npc")),  -Inf, Inf, -Inf, Inf) 
plot_p <- ggplot()+ annotation_custom(rasterGrob(plankt, width = unit(1,"npc"), height = unit(1,"npc")), -Inf, Inf, -Inf, Inf) 
plot_b <- ggplot()+ annotation_custom(rasterGrob(benthi, width = unit(1,"npc"), height = unit(1,"npc")), -Inf, Inf, -Inf, Inf) 
plot_pred <-  ggplot()+ annotation_custom(rasterGrob(predat, width = unit(1,"npc"), height = unit(1,"npc")), -Inf, Inf, -Inf, Inf) 

#put all plots in one. Fish pictures in between the two plots. The legends are collected in one. Heights specified. 

patchwork <- (plot3/plot2/(plot_pred|plot_h|plot_p|plot_b)/plot1)+
             plot_layout(guides = 'collect', height=c(3,8,2,8,2))
#patchwork

pdf("Figure4.pdf",width=9)
patchwork
dev.off()


```


### ####################
### ACTUAL SCENARIO RUNS

### Load params, data & senescence mort

Don't change anything here, these are fixed parameters

```{r}
  load(file = "modelParams/mariaParamsMs.RData") #species parameter file 
  load(file = "modelParams/paramsMs.RData") #built params file
  load(file = "modelParams/inter_N19.RData") #interaction matrix (it is also included in the params file)
  # now load stable numbers at size for all species. I start the runs from equilibrium abundances 
  load(file = "modelParams/abund_N19.RData")
  load(file = "modelParams/npp_N19.RData")
  load(file = "modelParams/nbb_N19.RData")
  load(file = "modelParams/naa_N19.RData")
  
  #load(file = "../modelParams/params194.RData")
  load(file = "modelParams/params28ms.RData")
  accepted1 <- as.data.frame(params28)
  
#add another column to the parameter file defining weight above 5cm and weight above 10cm in case we want to study changes of mean size above a certain length
      
#weight at 5 cm - we will calculate mean weight of all fish above 5 cm length to compare with observed trends  
mariaParams$cm2 <- mariaParams$a * 2^mariaParams$b 
mariaParams$cm10 <- mariaParams$a * 10 ^mariaParams$b   

## Just in case a wrong parameter file is read, make sure we set mortality activation energy to 0
#mariaParams$ea_mor <- 0
mariaParams$ea_mor <- NA

## also load senescence mortality function (it is not currently in mizerRewire but is added separately)

 #parameters for senescence mortality as used in Law et al. 2009
  k.sm <- 0.1 #mortality per year at the threshold size (should be 0.5 originally)
  xsw <- 0.95 #proportion of w_inf at which mortality is at k.sm (should be 0.9)
  sen.e <- 3 #exponent of the senescence mortality (larger value will give steeper increase in the last few sizes) (should be 3)
  
  sen_mort = function(sppParams, params, k.sm, xsw, sen.e) {
    
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    
    for (i in 1: length(sppParams$species)) {
      
      mu_Sen = k.sm * 10^(sen.e*(log(params@w)-log(xsw*sppParams$w_inf[i])))
      
      sen.mort.m[i,] <- mu_Sen    
    }
    
    # For really small species, like Trachinops, Pictilabrus and urchins predation mortality will be so high that senescence mortality is unlikely to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    
    return(sen.mort.m)
    
  }
  
  ## we will need to apply temperature scaling to senescence mortality as well, so load the temperature function separatly
  tempFun <- function(temperature, t_ref, Ea, c_a, w) {
  # tempFun returns a matrix with w (size) as columns and temperature as rows

  temperature <- temperature + 273 # converting to Kelvin from Celcius
  t_ref <- t_ref + 273

  temperatureScalar <- t(sapply(w,FUN = function(x){x^(c_a*(temperature-(t_ref)))}) *exp((-Ea/8.617332e-5)*((1/temperature) - (1/(t_ref))))) 

                         return(temperatureScalar)
}


```

### Load scenarios

List of seven productivity scenarios. Each of them will be run 4 times: with and without fishing, with and without heating. 
Note, I used very approximate array of fishing mortality (shown below). This can be updated 

```{r}
#Notolabrus       L_forsteri       T_caudimaculatus C_rasor          D_lewini         leatherjack      C_spectabilis    C_laticeps       P_laticlavius    Boarfish   M_freycineti     P_bachus         O_cyanomelas     A_arctidens      predator         urchins          lobsters  

mariaParams$fishmort <- c(0.15, 0.15, 0, 0.05, 0.15, 0.05, 0.15, 0.1, 0.05, 0.15, 0.15, 0.15, 0.15, 0.15, 0.1, 0.15, 0.15)

#if no fishing is applied 
fish.mort.0 <- rep(0, times = 17)
#a vector of low fishing mortalities
fish.mort.v <- mariaParams$fishmort

  prod_scen<-list( 
  "baseline_12_f0"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "more_plankt_12_f0"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "less_plankt_12_f0"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "small_plankt_12_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "large_plankt_12_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "more_benth_12_f0"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "less_benth_12_f0"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.0), 
  "small_benth_12_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 12, "fmort" = fish.mort.0),
  "large_benth_12_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 12, "fmort" = fish.mort.0),
  
  "baseline_14_f0"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "more_plankt_14_f0"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "less_plankt_14_f0"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "small_plankt_14_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "large_plankt_14_f0"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "more_benth_14_f0"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "less_benth_14_f0"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.0), 
  "small_benth_14_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 14.5, "fmort" = fish.mort.0), 
  "large_benth_14_f0"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 14.5, "fmort" = fish.mort.0), 
  
  "baseline_12_f2"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "more_plankt_12_f2"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "less_plankt_12_f2"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "small_plankt_12_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "large_plankt_12_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "more_benth_12_f2"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "less_benth_12_f2"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 12, "fmort" = fish.mort.v), 
  "small_benth_12_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 12, "fmort" = fish.mort.v),
  "large_benth_12_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 12, "fmort" = fish.mort.v),
  
  "baseline_14_f2"=       c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "more_plankt_14_f2"=    c("kappa" =2.6, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "less_plankt_14_f2"=    c("kappa" =1.5, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "small_plankt_14_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.18, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "large_plankt_14_f2"=   c("kappa" =2, "kappa_ben"=6, "lambda"=2.12, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "more_benth_14_f2"=     c("kappa" =2, "kappa_ben"=9, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "less_benth_14_f2"=     c("kappa" =2, "kappa_ben"=4, "lambda"=2.15, "lambda_ben"=1.9, "temp" = 14.5, "fmort" = fish.mort.v), 
  "small_benth_14_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=2.0, "temp" = 14.5, "fmort" = fish.mort.v), 
  "large_benth_14_f2"=    c("kappa" =2, "kappa_ben"=6, "lambda"=2.15, "lambda_ben"=1.8, "temp" = 14.5, "fmort" = fish.mort.v)) 
 
   
```

### Setup run parameters 

We will heat the model by 2C.5, from tref 12 and constant temperature of 12, to increased temperature of 14.5

```{r}   

## do you want a plot for each run, while the simulations are going? This takes more time but is sometimes fun to watch and keep an eye if there are oscillating dynamics 

showplot = F

  ## setup run time 
  tmax = 100
  #number of size groups 
  no_size_groups = 200
  #timestep used in the integration 
  dt = 0.2
  #our reference temperature 
  temp_ref = 12
  
## fixed background params- THESE ARE NOT CHANGING IN SCENARIOS
  w_pp_cutoff = 1 #g
  r_pp = 1 # rate of regeneration
  min_w_pp = 1e-10 #g
  
  w_bb_cutoff = 5 #
  r_bb = 1 # 
  min_w_bb = 0.001 # 0.01
  
  #algae are not really size structured food resources, but are treated as such here for now 
  kappa_alg = 16 #intercept assuming g/m2
  lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
  w_aa_cutoff = 50 
  r_aa = 2 
  min_w_aa = 0.001

## IF calculating diet statistics and food web stats set diet_steps to 2 and storekernel to T. This makes runs MUCH Longer 
  ## Here we are not focusing on diet statistics so we don't use this functionality 

  diet_steps = 0 # this should be 0 or 2
  storekernel = F

```

### Setup arrays to store data 

We will store data on: 
1) Numbers at size to look at species spectra and so on
2) Numbers at size for all background spectra, just in case we need it
3) Proportion of Large fish indicator 
4) Mean weight above some thresholds: two thresholds used are MeanWeight of mature fish (maturation size is a threshold) and MeanWeight of fish above 2cm in length
5) Calculate community slopes: for all species, for fish only (exclude lobsters and urchins), and for four functional groups separately - benthivores, planktivores, herbivores (includes urchins) and predators (includes lobsters)

```{r, eval = F, echo = F, warning=F}  

#setup arrays to store results 

#number of scenarios in a list
scen_num <- length(lengths(prod_scen))
n_spp <- length(params@species_params$species)

numb_all <-array(data=NA,c(scen_num,n_spp,200,dim(params28)[1])) ## 200, 326 or 120 in these dataframes refers to the numbers of size groups in different arrays
biom_all <- array(data=NA, c(scen_num,n_spp, dim(params28)[1]))
plankt_all <- array(data=NA, c(scen_num,326, dim(params28)[1]))
bent_all <- array(data=NA, c(scen_num,120, dim(params28)[1]))
alg_all <- array(data=NA, c(scen_num,153, dim(params28)[1]))
PropLarFish_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
Yield_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
#Yield_all[c(1:14),,] <- 0 #no fishing scenarios will have zero yield naturally
MeanWgtMat_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
MeanWgtAbove2_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
MeanWgtAbove10_all <- array(data= NA, c(scen_num,n_spp, dim(params28)[1]))
CommSlope_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeFish_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeBent_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopePred_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopePlan_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))
CommSlopeHerb_all <- array(data= NA, c(scen_num,3,dim(params28)[1]))

## setup different species groups for community slope calcualtions
  fishonly <- as.character(mariaParams$species[c(1:15)])
  bentiv <- as.character(mariaParams$species[which(mariaParams$funcgr == "omni")])
  plankt <- as.character(mariaParams$species[which(mariaParams$funcgr == "plankt")])
  predat <- as.character(mariaParams$species[which(mariaParams$funcgr == "predat")])
  herbiv <- as.character(mariaParams$species[which(mariaParams$funcgr == "herbi")])


```

### All simulations

This will run 36 scenarios with 29 parameter combinations each and save outputs into data arrays

```{r, eval = F, echo = F, warning = F}
## loop through 36 scenarios

for (scen in 1:scen_num) {
  
## resource params
  kappa = as.numeric(prod_scen[[scen]][1])
  kappa_ben = as.numeric(prod_scen[[scen]][2])  
  lambda = as.numeric(prod_scen[[scen]][3])
  lambda_ben = as.numeric(prod_scen[[scen]][4])
  

#set up the effort array - NOT DONE yet
  fish.mort <- as.numeric(prod_scen[[scen]][6:22]) #the index here only takes fish mort values, the first five values are resource params
  eff_arr <- matrix(rep(fish.mort, times = tmax), nrow = tmax, byrow = TRUE)
  rowtest <- as.character(seq(from = 1, to = tmax))  #names of rows
  dimnames(eff_arr) = list (rowtest, params@species_params$gear)
  
## get temperature value for the scenario 
  temp_run <- as.numeric(prod_scen[[scen]][5])

## for each scenario loop through 29 parameter combinations   
    for (iter in 1:dim(params28)[1]) {

  print("scenario = ")
  print (scen)
  print(prod_scen[scen])
  print("iteration out of 29")
  print(iter)  
## update parameters

  mariaParams$r_max <- as.numeric(accepted1[iter,c(1:17)])
  mariaParams$gamma <- as.numeric(accepted1[iter,c(18:34)])
  availUr <- as.numeric(accepted1[iter,35])
  availUrLob <- as.numeric(accepted1[iter,36])
  availSchooling <- as.numeric(accepted1[iter,37])
  
  # overwrite default interaction values with this (only for predators that feed on fish, i.e. have values > 0)
  inter[c(which(inter[,which(mariaParams$species == "T_caudimaculatus")] >0)),which(mariaParams$species == "T_caudimaculatus")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "P_laticlavius")] >0)),which(mariaParams$species == "P_laticlavius")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "C_rasor")] >0)),which(mariaParams$species == "C_rasor")] <- availSchooling
  inter[c(which(inter[,which(mariaParams$species == "urchins")] >0)),which(mariaParams$species == "urchins")] <- availUr
  inter[which(mariaParams$species == "lobsters"), which(mariaParams$species == "urchins")] <- availUrLob
  
  ### setup again with new parameter values
  params <- mizerRewire::MizerParams(mariaParams, interaction = inter, no_w = no_size_groups, kappa = kappa, lambda = lambda, min_w_pp = min_w_pp, w_pp_cutoff = w_pp_cutoff, r_pp = r_pp, kappa_ben = kappa_ben, lambda_ben = lambda_ben, w_bb_cutoff = w_bb_cutoff, r_bb = r_bb, min_w_bb = min_w_bb, kappa_alg = kappa_alg, lambda_alg = lambda_alg, w_aa_cutoff = w_aa_cutoff, r_aa = r_aa, min_w_aa = min_w_aa, store_kernel = storekernel, t_ref = temp_ref)
  
  #update initial abundances 
  params@initial_n <- stable_abund
  params@initial_n_pp <- stable_pl
  params@initial_n_bb <- stable_ben
  params@initial_n_aa <- stable_alg
  
  ## because senescence mortality is not in the actual code, but we add it separately, we also need to scale it with temperature manually. Here we assume that all processes scale identically across species and sizes, so we only need to get one scalar value for the activation energy of 0.63. In reality the scaling should probably be size dependent, but we will explore it in future studies. Therefore size dependency of temperature scaling (c_a) is set to 0
  
  senMortScalar <- tempFun(temperature = temp_run, t_ref = temp_ref, Ea = 0.63, c_a = 0, w = params@w)[1,1]
  
  params@mu_b <- params@mu_b + sen_mort(mariaParams, params, k.sm, xsw, sen.e)*senMortScalar 

  #run the model
  tasm1 <- mizerRewire::project(params, t_max = tmax, effort= eff_arr, dt = dt, temperature = rep(temp_run, 100), diet_steps = diet_steps)

  ### Calculate various statistics inside the run to avoid saving massive model objects
  if (showplot == T) {
      plot(tasm1)
    }
  #get relative biomasses 
  #need to take an average of the last 30 years because it is oscilating
  biomass <- apply((mizerRewire::getBiomass(tasm1)[c((tmax-29):tmax),]),2,mean)
  #biomass <- getBiomass(tasm1)[tmax,]
  #numbers <- tasm1@n[tmax,,] 
  numbers <- apply((tasm1@n[c((tmax-29):tmax),,]),c(2,3),mean)
  
  PropLarFish <- rep(NA,17)
  MeanWgtMat <- rep(NA,17)
  MeanWgtAbove2 <- rep(NA,17)
  MeanWgtAbove10 <- rep(NA,17)

      for (xx in 1:length(mariaParams$species)) {
        PropLarFish[xx] <- mean(mizerRewire::getProportionOfLargeFish(tasm1,species = xx, threshold_w = mariaParams$w_mat[xx])[(tmax-29):tmax])
        MeanWgtMat[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, species = xx, min_w = mariaParams$w_mat[xx])[(tmax-29):tmax])
        MeanWgtAbove2[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, species = xx, min_l = 2)[(tmax-29):tmax])
        MeanWgtAbove10[xx]  <- mean(mizerRewire::getMeanWeight(tasm1, species = xx, min_l = 10)[(tmax-29):tmax])
      }

    
    
  #get mean values of various statistics over the last 30 years and save them in arrays 
  ttemp <- tasm1@n_pp[c((tmax-29):tmax),which(params@w_full > min_w_pp & params@w_full < w_pp_cutoff)]
  plankt_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_bb[c((tmax-29):tmax),which(params@w_full > min_w_bb & params@w_full < w_bb_cutoff)]
  bent_all[scen,,iter] <- apply(ttemp, 2, mean)
  ttemp <- tasm1@n_aa[c((tmax-29):tmax),which(params@w_full > min_w_aa & params@w_full < w_aa_cutoff)]
  alg_all[scen,,iter] <- apply(ttemp, 2, mean)
  numb_all[scen,,,iter] <- numbers
  biom_all[scen,,iter] <- biomass
  PropLarFish_all[scen,,iter] <- PropLarFish
  MeanWgtMat_all[scen,,iter] <- MeanWgtMat
  MeanWgtAbove2_all[scen,,iter] <- MeanWgtAbove2
  MeanWgtAbove10_all[scen,,iter] <- MeanWgtAbove10
  Yield_all[scen,,iter] <- as.numeric(apply((mizerRewire::getYield(tasm1)[c((tmax-29):tmax),]),2,mean))
  CommSlope_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1)[c((tmax-29):tmax),]),2,mean))
  CommSlopeFish_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = fishonly)[c((tmax-29):tmax),]),2,mean))
  CommSlopeBent_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = bentiv)[c((tmax-29):tmax),]),2,mean))
  CommSlopePlan_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = plankt)[c((tmax-29):tmax),]),2,mean))
  CommSlopeHerb_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = herbiv)[c((tmax-29):tmax),]),2,mean))
  CommSlopePred_all[scen,,iter] <- as.numeric(apply((mizerRewire::getCommunitySlope(tasm1, species = predat)[c((tmax-29):tmax),]),2,mean))
  
      if (storekernel == T) {
        foodWebStats <- getFoodWebStats(tasm1, diet_steps = diet_steps)
        filename <- paste("fw_sc",scen,"par", iter, ".rds", sep = "")
        saveRDS(foodWebStats, file = filename)
#        foodWebStats <- append(foodWebStats, food.t)
        }
  
  }

}


```

### Save results

commented out, so that not to overwrite saved results accidentally

```{r}

# save(numb_all, file = "outputs/numb.RData")
# save(biom_all, file = "outputs/biom.RData")
# save(plankt_all, file = "outputs/plankt.RData")
# save(bent_all, file = "outputs/bent.RData")
# save(alg_all, file = "outputs/alg.RData")
# save(PropLarFish_all, file = "outputs/PropLargFish.RData")
# save(MeanWgtMat_all, file = "outputs/MeanWgtMat.RData")
# save(MeanWgtAbove2_all, file = "outputs/MeanWgtAbove2.RData")
# save(MeanWgtAbove10_all, file = "outputs/MeanWgtAbove10.RData")
# save(Yield_all, file = "outputs/Yield.RData")
# save(CommSlope_all, file = "outputs/CommSlope.RData")
# save(CommSlopeFish_all, file = "outputs/CommSlopeFish.RData")
# save(CommSlopeBent_all, file = "outputs/CommSlopeBent.RData")
# save(CommSlopePlan_all, file = "outputs/CommSlopePlan.RData")
# save(CommSlopeHerb_all, file = "outputs/CommSlopeHerb.RData")
# save(CommSlopePred_all, file = "outputs/CommSlopePred.RData")

#saveRDS(foodWebStats, file = "../altRuns28/foodwebstats.rds")

```

### ####################
### DATA TRANSFORMATION

this is auxilary code to produce scaled model outputs 

what kind of outputs to show 
1. Relative changes in biomasses 
2. Total fish community biomass? 
3. Relative changes in size-at-age 
4. Relative changes in mean size (above 2 cm in length)
5. Entire community size spectrum 
6. Production to biomass ratio

### Load saved results 

```{r}

# load(file = "outputs/numb.RData")
# load(file = "outputs/biom.RData")
# load(file = "outputs/plankt.RData")
# load(file = "outputs/bent.RData")
# load(file = "outputs/alg.RData")
# load(file = "outputs/PropLargFish.RData")
# load(file = "outputs/MeanWgtMat.RData")
# load(file = "outputs/MeanWgtAbove5.RData")
# load(file = "outputs/MeanWgtAbove10.RData")
# load(file = "outputs/CommSlope.RData")
# load(file = "outputs/CommSlopeFish.RData")
# load(file = "outputs/CommSlopeBent.RData")
# load(file = "outputs/CommSlopePlan.RData")
# load(file = "outputs/CommSlopeHerb.RData")
# load(file = "outputs/CommSlopePred.RData")

## if starting from this chunk also load mariaParams to have species information 
load(file = "modelParams/mariaParamsMs.RData")

scenarios<-c("baseline_12_f0", "more_plankt_12_f0", "less_plankt_12_f0","small_plankt_12_f0","large_plankt_12_f0", "more_benth_12_f0","less_benth_12_f0", "small_benth_12_f0","large_benth_12_f0", "baseline_14_f0", "more_plankt_14_f0", "less_plankt_14_f0", "small_plankt_14_f0","large_plankt_14_f0", "more_benth_14_f0","less_benth_14_f0","small_benth_14_f0","large_benth_14_f0","baseline_12_f2", "more_plankt_12_f2", "less_plankt_12_f2","small_plankt_12_f2","large_plankt_12_f2", "more_benth_12_f2","less_benth_12_f2", "small_benth_12_f2","large_benth_12_f2", "baseline_14_f2", "more_plankt_14_f2", "less_plankt_14_f2", "small_plankt_14_f2","large_plankt_14_f2", "more_benth_14_f2","less_benth_14_f2","small_benth_14_f2", "large_benth_14_f2")

species <- as.character(mariaParams$species)
func_group <- as.character(mariaParams$funcgr)

#identify various scenarios
warm_sc <- scenarios[c(10:18, 28:36)] #scenarios with warming
fish_sc <- scenarios[c(19:36)] #scenarios with fishing
pla_sc <- scenarios[c(2,3,4,5, 11,12,13,14, 20,21,22,23, 29,30,31,32 )] #those that involve changes in plankton (all changes)
ben_sc <- scenarios[c(6,7,8,9, 15,16,17,18, 24,25,26,27, 33,34,35,36)] #those that involve changes in benthos (all changes)
kappaUp_sc <- scenarios[c(2,6,11,15,20,24,29,33)] #kappa going up - for either plankton or benthos
kappaDown_sc <- scenarios[c(3,7,12,16,21,25,30,34)] #kappa going down - for either plankton or benthos
slopeUp_sc <- scenarios[c(4,8,13,17,22,26,31,35)] #plankton or benthos slopes getting steeper
slopeDown_sc <- scenarios[c(5,9,14,18,23,27,32,36)] #plankton or benthos slopes getting less shallow

```

### Make dataframes without scaling

melt saved dataframes into a long format, but include the original values, NOT the difference between baseline and changed scenario

#### dataframes 29x17x28

```{r}

temp <- reshape2::melt(input_data, id =1) # reshape into a long format
temp <- cbind(temp, rep(scenarios, length.out = length(temp[,1]))) #add scneario names
temp <- cbind(temp, rep(rep(species, each = length(scenarios)), times = 29)) #add species names
temp <- cbind(temp, rep(rep(func_group, each = length(scenarios)), times = 29)) #add functional group names

#temp <- temp[,-c(1:2)]
colnames(temp) <- c("scen_num", "spp_num", "paramset", "value", "scenario","species", "funcgr")

## add qualifyers

temp$warming <- 0
temp$warming[which(temp$scenario %in% warm_sc)] <- 1
temp$fishing <- 0
temp$fishing[which(temp$scenario %in% fish_sc)] <- 1
temp$plankt <- 0
temp$plankt[which(temp$scenario %in% pla_sc)] <- 1
temp$bent <- 0
temp$bent[which(temp$scenario %in% ben_sc)] <- 1
temp$kappaUp <- 0
temp$kappaUp[which(temp$scenario %in% kappaUp_sc)] <- 1
temp$kappaDown <- 0
temp$kappaDown[which(temp$scenario %in% kappaDown_sc)] <- 1
temp$slopesUp <- 0
temp$slopesUp[which(temp$scenario %in% slopeUp_sc)] <- 1
temp$slopesDown <- 0
temp$slopesDown[which(temp$scenario %in% slopeDown_sc)] <- 1

temp$product <- 0
temp$product[which(temp$kappaUp == "1")] <- 1
temp$product[which(temp$kappaDown == "1")] <- -1

temp$slopeChange <- 0
temp$slopeChange[which(temp$slopesUp == "1")] <- 1
temp$slopeChange[which(temp$slopesDown == "1")] <- -1

#define productivity scenarios - we have 7 of them, so it is a question on how to rank them
temp$prodScen <- 0
temp$prodScen[which(temp$kappaUp == "1" & temp$plankt == 1)] <- 1
temp$prodScen[which(temp$kappaDown == "1" & temp$plankt == 1)] <- 3
temp$prodScen[which(temp$slopesUp == "1" & temp$plankt == 1)] <- 5
temp$prodScen[which(temp$slopesDown == "1" & temp$plankt == 1)] <- 7
temp$prodScen[which(temp$kappaUp == "1" & temp$bent == 1)] <- 2
temp$prodScen[which(temp$kappaDown == "1" & temp$bent == 1)] <- 4
temp$prodScen[which(temp$slopesUp == "1" & temp$bent == 1)] <- 6
temp$prodScen[which(temp$slopesDown == "1" & temp$bent == 1)] <- 8

temp$prodScen <- as.factor(temp$prodScen)
temp$warming <- as.factor(temp$warming)
temp$product <- as.factor(temp$product)
temp$fishing <- as.factor(temp$fishing)
temp$slopeChange <- as.factor(temp$slopeChange)


```

### Make scaled dataframes 

here we want to get the difference from the baseline

#### dataframes 29x17x28: by species

```{r}

# load(file = "outputs/biom.RData")
# load(file = "outputs/PropLargFish.RData")
# load(file = "outputs/MeanWgtMat.RData")
 load(file = "outputs/MeanWgtAbove2.RData")
# load(file = "outputs/MeanWgtAbove10.RData")
# load(file = "outputs/Yield.RData")

#turn biom plot into a long data frame
#input_data <- biom_all[c(19:36),,] # only use scenarios with fishing 
# input_data <- Yield_all[c(19:36),,] # only use scenarios with fishing
 input_data <- MeanWgtAbove2_all[c(19:36),,] # only use scenarios with fishing

 ind.t <- which(input_data[3,16,] > 20) 
input_data[3,16,ind.t] <- NA
 ind.t <- which(input_data[12,16,] > 20) 
input_data[12,16,ind.t] <- NA 

# input_data <- PropLarFish_all[c(19:36),,] # only use scenarios with fishing
# input_data <- MeanWgtMat_all[c(19:36),,] # only use scenarios with fishing

#input_data <- MeanWgtAbove10_all[c(19:36),,] # only use scenarios with fishing
```

```{r}
temp <- data.frame()
#for (scen in 1:length(scenarios)) {
for (scen in 1:length(fish_sc)) {   #if using yield data
  
  #if scaled to zero  
  #tt <- (input_data[scen,,] - input_data[1,,])/input_data[1,,]
  
  #if relative
  tt <- input_data[scen,,] / input_data[1,,]
  
  #log minus (https://www.bmj.com/content/358/bmj.j3683) 
  #tt <- log(input_data[1,,]) - log(input_data[scen,,])
  
  temp2 <- reshape2::melt(tt, id =1)
#  temp3 <- cbind(temp2, rep(scenarios[scen], times = length(temp2[,1])))
    temp3 <- cbind(temp2, rep(fish_sc[scen], times = length(temp2[,1])))    #for fishing scenarios only
    temp <- rbind(temp, temp3)
}

#temp <- cbind(temp, rep(species, times = 29*length(scenarios)), rep(func_group, times = 29*length(scenarios)))
#or for fished scenarios only
temp <- cbind(temp, rep(species, times = 29*length(fish_sc)), rep(func_group, times = 29*length(fish_sc)))

temp <- temp[,-1]
colnames(temp) <- c("paramset", "value", "scenario","species", "funcgr")

#if using yield data remove T_caudimaculatus species, as it is not fished 
#temp <- temp %>% filter (species != "T_caudimaculatus")

## add various qualifyers
temp$warming <- 0
temp$warming[which(temp$scenario %in% warm_sc)] <- 1
temp$fishing <- 0
temp$fishing[which(temp$scenario %in% fish_sc)] <- 1
temp$plankt <- 0
temp$plankt[which(temp$scenario %in% pla_sc)] <- 1
temp$bent <- 0
temp$bent[which(temp$scenario %in% ben_sc)] <- 1
temp$kappaUp <- 0
temp$kappaUp[which(temp$scenario %in% kappaUp_sc)] <- 1
temp$kappaDown <- 0
temp$kappaDown[which(temp$scenario %in% kappaDown_sc)] <- 1
temp$slopesUp <- 0
temp$slopesUp[which(temp$scenario %in% slopeUp_sc)] <- 1
temp$slopesDown <- 0
temp$slopesDown[which(temp$scenario %in% slopeDown_sc)] <- 1

temp$product <- 0
temp$product[which(temp$kappaUp == "1")] <- 1
temp$product[which(temp$kappaDown == "1")] <- -1

temp$slopeChange <- 0
temp$slopeChange[which(temp$slopesUp == "1")] <- 1
temp$slopeChange[which(temp$slopesDown == "1")] <- -1

#define productivity scenarios - we have 7 of them, so it is a question on how to rank them
temp$prodScen <- 0
temp$prodScen[which(temp$kappaUp == "1" & temp$plankt == 1)] <- 1
temp$prodScen[which(temp$kappaDown == "1" & temp$plankt == 1)] <- 3
temp$prodScen[which(temp$slopesUp == "1" & temp$plankt == 1)] <- 5
temp$prodScen[which(temp$slopesDown == "1" & temp$plankt == 1)] <- 7
temp$prodScen[which(temp$kappaUp == "1" & temp$bent == 1)] <- 2
temp$prodScen[which(temp$kappaDown == "1" & temp$bent == 1)] <- 4
temp$prodScen[which(temp$slopesUp == "1" & temp$bent == 1)] <- 6
temp$prodScen[which(temp$slopesDown == "1" & temp$bent == 1)] <- 8

temp$prodScen <- as.factor(temp$prodScen)
temp$warming <- as.factor(temp$warming)
temp$product <- as.factor(temp$product)
temp$fishing <- as.factor(temp$fishing)
temp$slopeChange <- as.factor(temp$slopeChange)

```

```{r}
# biom_relative <- temp
# save(biom_relative, file = "plotData/biom_relative.RData")
# biom_tozero <- temp
# save(biom_tozero, file = "plotData/biom_tozero.RData")
# biom_log <- temp
# save(biom_log, file = "plotData/biom_log.RData")

 
# yield_relative <- temp
# save(yield_relative, file = "plotData/yield_relative.RData")
# yield_tozero <- temp
# save(yield_tozero, file = "plotData/yield_tozero.RData")
# yield_log <- temp
# save(yield_log, file = "plotData/yield_log.RData")

# size_tozero <- temp
# save(size_tozero, file = "plotData/size_tozero.RData")
 size_relative <- temp
 save(size_relative, file = "plotData/size_relative.RData")
# size_log <- temp
# save(size_log, file = "plotData/size_log.RData")

# prolarfish_tozero <- temp
# save(prolarfish_tozero, file = "plotData/prolarfish_tozero.RData")
# prolarfish_relative <- temp
# save(prolarfish_relative, file = "plotData/prolarfish_relative.RData")
# prolarfish_log <- temp
# save(prolarfish_log, file = "plotData/prolarfish_log.RData")

# size_tozeroMat <- temp
# save(size_tozeroMat, file = "plotData/size_tozeroMat.RData")
# size_relativeMat <- temp
# save(size_relativeMat, file = "plotData/size_relativeMat.RData")
# size_logMat <- temp
# save(size_logMat, file = "plotData/size_logMat.RData")


```

#### dataframes 29x17x200x28 - size spectra
not sure any of these will be used but the option is here 

Remember we only scale to the baseline scenario WITH fishing
Runs without fishing are not used at the moment at all

```{r}
load(file = "outputs/numb.RData")

## numbers at weight difference 
dim(numb_all)

input_data <- numb_all[c(19:36),,,]

### if transforming into a long format
temp <- data.frame()
for (scen in 1:length(fish_sc)) {

  #tt <- (input_data[scen,,,] - input_data[1,,,])/input_data[1,,,]
  tt <- input_data[scen,,,]/input_data[1,,,]
  temp2 <- reshape2::melt(tt, id =1)
  #temp3 <- cbind(temp2, rep(scenarios[scen], times = length(temp2[,1])))
  temp3 <- cbind(temp2, rep(fish_sc[scen], times = length(temp2[,1])))
  temp <- rbind(temp, temp3)
}


# ## or if just scaling by first scenario
# new_data <- array(data= NA, c(18,17,200,29))
# 
# for (scen in 1:length(fish_sc)) {
# 
#   #tt <- (input_data[scen,,,] - input_data[1,,,])/input_data[1,,,]
#   new_data[scen,,,] <- input_data[scen,,,]/input_data[1,,,]
#  
# }
# rel_numb <- new_data
# save(rel_numb, file = "plotData/rel_numb.RData")

#temp <- temp[,-1]
colnames(temp) <- c("sppnum", "sizegroup", "paramset", "value", "scenario","species", "funcgr")


## add various qualifiers
temp$warming <- 0
temp$warming[which(temp$scenario %in% warm_sc)] <- 1
temp$fishing <- 0
temp$fishing[which(temp$scenario %in% fish_sc)] <- 1
temp$plankt <- 0
temp$plankt[which(temp$scenario %in% pla_sc)] <- 1
temp$bent <- 0
temp$bent[which(temp$scenario %in% ben_sc)] <- 1
temp$kappaUp <- 0
temp$kappaUp[which(temp$scenario %in% kappaUp_sc)] <- 1
temp$kappaDown <- 0
temp$kappaDown[which(temp$scenario %in% kappaDown_sc)] <- 1
temp$slopesUp <- 0
temp$slopesUp[which(temp$scenario %in% slopeUp_sc)] <- 1
temp$slopesDown <- 0
temp$slopesDown[which(temp$scenario %in% slopeDown_sc)] <- 1

temp$product <- 0
temp$product[which(temp$kappaUp == "1")] <- 1
temp$product[which(temp$kappaDown == "1")] <- -1

temp$slopeChange <- 0
temp$slopeChange[which(temp$slopesUp == "1")] <- 1
temp$slopeChange[which(temp$slopesDown == "1")] <- -1

#define productivity scenarios
temp$prodScen <- 0
temp$prodScen[which(temp$kappaUp == "1" & temp$plankt == 1)] <- 1
temp$prodScen[which(temp$kappaDown == "1" & temp$plankt == 1)] <- 3
temp$prodScen[which(temp$slopesUp == "1" & temp$plankt == 1)] <- 5
temp$prodScen[which(temp$slopesDown == "1" & temp$plankt == 1)] <- 7
temp$prodScen[which(temp$kappaUp == "1" & temp$bent == 1)] <- 2
temp$prodScen[which(temp$kappaDown == "1" & temp$bent == 1)] <- 4
temp$prodScen[which(temp$slopesUp == "1" & temp$bent == 1)] <- 6
temp$prodScen[which(temp$slopesDown == "1" & temp$bent == 1)] <- 8

temp$prodScen <- as.factor(temp$prodScen)
temp$warming <- as.factor(temp$warming)
temp$product <- as.factor(temp$product)
temp$fishing <- as.factor(temp$fishing)
temp$slopeChange <- as.factor(temp$slopeChange)

# numb_relative <- temp
# save(numb_relative, file = "plotData/numb_relative.RData")

# numb_tozero <- temp
# save(numb_tozero, file = "plotData/numb_tozero.RData")


```

