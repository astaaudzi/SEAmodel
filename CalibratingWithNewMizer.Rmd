---
title: "Calibration"
author: "Gustav, Asta"
date: "2021 Sep 22"
output: html_document
---
### clear memory

```{r}

rm(list=ls())

```

### Install mizer, load libraries 

For this model we are using an extended version of mizer which includes some experimental features
See https://github.com/sizespectrum/mizerExperimental
Standard mizer does not have starvation mortality included. This model uses starvation
https://github.com/sizespectrum/mizerStarvation

And finally a critical aspect of this model is multiple background resources, now implemented in mizerMR
https://github.com/sizespectrum/mizerMR

```{r warning=F, message=FALSE, echo=T}
#rm(list=ls())
#library(devtools)
#install.packages(vegan)
#devtools::install_github("astaaudzi/mizer", ref = "rewire-temp")
#library(mizerRewire)


library(mizer)
# remotes::install_github("sizespectrum/mizerExperimental")
# remotes::install_github("sizespectrum/mizerStarvation")
# remotes::install_github("sizespectrum/mizerMR")
library(tidyverse)
library(mizerExperimental)
library(mizerStarvation)
library(mizerMR)

```

### Background spectra

The slope for the plankton spectrum is assumed to be 2.1. 
For the benthic spectrum I use AbNoUr <- 0.8 - 0.85*log10(InvDataBinned$wgtGroup) equation and calibrate the kappa to ensure initial abundances are within the range of observed abundances per m2 (Freddie's and Kate's data used to get equation, see above)
May2 optimisation: 
after optim parallel runs I still can't get Trachinops to exist and predators don't get enough food. Decreasing kappa_ben from 4 to 2 actually helps, predators grow better and there is more Trachinops (increasing kappa_ben makes things worse)

```{r warning=T, message=FALSE, echo=T}

#number of size groups 
no_size_groups = 200
#timestep used in the integration 
dt = 0.2

## resource params
kappa = 2#1 #2 # 20 # 20 # intercept assuming g/m2
lambda = 2.15 #2.1 # 
w_pp_cutoff = 1 #g
r_pp = 1 #2 # rate of regeneration
min_w_pp = 1e-10 #g

kappa_ben = 6 #2 #8#4 # 8 #80 #80 # intercept assuming g/m2  
lambda_ben = 1.9 # 1.85 #this slope does not include urchins and lobsters
w_bb_cutoff = 5 #
r_bb = 1 # 1.5 # something to be calibrated. Default mizer option is 10
min_w_bb = 0.001 # 0.01

kappa_alg = 16#8 # 100 # 100 #intercept assuming g/m2
lambda_alg = 1.6 #slope is much more shallow, to allow for lots of large kelp, but size structure does not really make much sense here
w_aa_cutoff = 50 
r_aa = 2 #1 #something to be calibrated
min_w_aa = 0.001

```

### setup mizer to run with Tasmanian model

 In this file we are setting up the functions for
 - the dynamics of the resources
 - the contribution of the resources to the encounter rate
 - the senescence mortality
 and provide a function for setting up Tasmanian model with  benthos and algae.

TODO - can we make sure parameters are set separately and not hardcoded in functions 

```{r, eval = T, echo = F}
#
# This file is sourced by the file run.R that runs the 
# climate change scenarios

#parameters for senescence mortality as used in Law et al. 2009
k.sm <- 0.1 # mortality per year at the threshold size (should be 0.5 originally)
xsw <- 0.95 # proportion of w_inf at which mortality is at k.sm (should be 0.9)
sen.e <- 3  # exponent of the senescence mortality (larger value will give 
# steeper increase in the last few sizes) (should be 3)

sen_mort <- function(sppParams, params, k.sm, xsw, sen.e) {
    sen.mort.m = array(0, dim = c(length(sppParams$species),length(params@dw)))
    for (i in 1:length(sppParams$species)) {
        mu_Sen = k.sm * 10^(sen.e*(log(params@w) - log(xsw*sppParams$w_inf[i])))
        sen.mort.m[i,] <- mu_Sen    
    }
    # For really small species, like Trachinops, Pictilabrus and urchins 
    # predation mortality will be so high that senescence mortality is unlikely 
    # to be the case and perhaps should not even be applied
    sen.mort.m[which(params@species_params$w_inf < 400),] <- 0
    return(sen.mort.m)
}

newAstaParams <- function(sp, interaction, 
                          temperature = 12,
                          Ea = 0.63,
                          t_ref = 12,
                          no_w = 200, 
                          kappa = 2,
                          lambda = 2.15,
                          kappa_ben = 6, 
                          lambda_ben = 1.9,
                          stable_abund,
                          stable_pl,
                          stable_ben,
                          stable_alg) {
    # temperature factor
    temperature <- temperature + 273 # converting to Kelvin from Celsius
    t_ref <- t_ref + 273
    temperatureScalar <- exp(-Ea / 8.617332e-5 * (1/temperature - 1/t_ref))
    
    # We rescale rates. Mortality is rescaled further down
    sp$ks <- sp$ks * temperatureScalar
    sp$h <- sp$h * temperatureScalar
    sp$gamma <- sp$gamma * temperatureScalar
    
    # We are choosing the smallest plankton size to agree with what Asta's
    # setup function produces
    min_w_pp <- 0.95e-10
    
    params <- newMultispeciesParams(
        sp, interaction = interaction, no_w = no_w, min_w_pp = min_w_pp,
        n = 2/3)
    
    # Add starvation mortality with default parameter
    params <- setStarvation(params)
    
    # Add senescence mortality and rescale with temperature factor 
    z0 <- getExtMort(params) + 
        sen_mort(mariaParams, params, k.sm, xsw, sen.e)
    params <- setExtMort(params, z0 = z0 * temperatureScalar)
    
    # Set up resources
    resource_params(params) <- data.frame(
        resource = c("pl", "aa", "bb"),
        lambda = c(lambda, 1.6, lambda_ben),
        kappa = c(kappa, 16, kappa_ben),
        r_pp = c(1, 2, 1),
        w_min = c(NA, 1e-3, 1e-3),
        w_max = c(1, 50, 5)
    )
    resource_interaction(params)[, 1] <- sp$avail_PP
    resource_interaction(params)[, 2] <- sp$avail_AA
    resource_interaction(params)[, 3] <- sp$avail_BB
    
    # Update initial abundances 
    # initialN(params) <- stable_abund
    # initialNResource(params)[1, ] <- stable_pl
    # initialNResource(params)[2, ] <- stable_alg
    # initialNResource(params)[3, ] <- stable_ben
    
    params
}



```

### Load params and update for standard mizer

Previously runs were done with mizer rewiring fork. 
To adapt them to standar mizer we adjust a few parameters. 

First, Tasmanian model follows DEB and optimal allocation models and assumes a cost of growth, i.e. growth inefficiency. This means that in addition to assimilation efficiency parameter (0.6), converting net energy to growth also incurs growth cost. Such growth cost is most sensible in two pool models (e.g. Audzijonyte & Richards, 2018) where allocation to growth incurs costs while allocation to reserve does not. In standard mizer, which only tracks total weight this is now incorporated in other parameters. 
We also update reproductive allocation function 

```{r}
# The code is mostly copied from the "Actual scenario runs" section of
# Asta's "BenPel_SEAmodel_dbV2.Rmd" file, just slightly adjusted to run
# with standard mizer. Places where I made importantchanges are marked with 
# comments starting with GWD

# Species params ----
load(file = "modelParams/mariaParamsMs.RData") #species parameter file 

# We load interaction matrix and add rownames
load(file = "modelParams/inter_N19.RData")
dimnames(inter)[[1]] <- dimnames(inter)[[2]]

# Load initial values
load(file = "modelParams/naa_N19.RData")
load(file = "modelParams/nbb_N19.RData")
load(file = "modelParams/abund_N19.RData")
load(file = "modelParams/npp_N19.RData")
## data for invertebrate abundances
load(file = "modelParams/BenticInvAbund_Tasm.RData")


# GWD: We have to make some changes to Asta's species parameter file
# to absorb the growth efficiency into the existing parameters
# Growth inefficiency is assumed in the mod

mariaParams <- mariaParams %>% 
    # get rid of separate growth efficiency
    mutate(alpha = alpha * alpha_g,
           ks = ks * alpha_g,
           erepro = erepro / alpha_g)

# GWD: We change the maturity curve to correspond to an exponent u = 5 
mariaParams$w_mat25 <- mariaParams$w_mat/3^(1/5)

# Make a run with the base scenario just to check that things are working
# params <- newAstaParams(mariaParams, interaction = inter,
#                         stable_abund = stable_abund,
#                         stable_pl = stable_pl,
#                         stable_ben = stable_ben,
#                         stable_alg = stable_alg)

### or create a new mariaParams without Rmax and erepro
mariaNew <- mariaParams
mariaNew$r_max <- NULL
mariaNew$erepro <- NULL

maria2 <- mariaParams

maria2$erepro <- 0.5 * maria2$w_inf^(-0.5)
mean_lam = mean(lambda, lambda_ben, lambda_alg)
mean_kappa = mean(kappa, kappa_ben, kappa_alg)
maria2$r_max = 1000 * mean_kappa * maria2$w_inf^(-1.5)

```

### calibration steps 

```{r}

#create params file 
p <- newAstaParams(maria2, interaction = inter,
                        stable_abund = stable_abund,
                        stable_pl = stable_pl,
                        stable_ben = stable_ben,
                        stable_alg = stable_alg)

species_params(p)$biomass_observed <- mariaParams$BioM2
species_params(p)$biomass_cutoff <- mariaParams$a * 2 ^ mariaParams$b

## scaling initial values 
initialN(p) <- initialN(p)/(maria2$initScalar*10000)
plotBiomassObservedVsModel(p)


#set fishing
fish.mort.spp <- c(0.15, 0.15, 0, 0.1, 0.15, 0.1, 0.15, 0.1, 0.1, 0.15, 0.15, 
                  0.15, 0.15, 0.15, 0.1, 0.15, 0.15)

## we will calibrate with fishing, so setting up catchability to the F vector and effort to 1
gear_params(p)$catchability <- fish.mort.spp
initial_effort(p) <- 1

## now - magic calibration
p <- steady(p, t_max = 200, return_sim = F)

#if return_sim = T
#plotBiomass(p)

p@species_params$erepro
p@species_params$R_max


plotSpectra(p)
sim1 <- project(p, t_max = 100)
plot(sim1)

plotBiomass(sim1)
round(p@species_params$erepro,3)



p <- calibrateBiomass(p)
plotSpectra(p)
p <- tuneGrowth(p)

plotlyBiomassObservedVsModel(p)
p <- matchBiomasses(p)
sim <- steady(p, return_sim = TRUE)
plotBiomass(sim)



 initial_effort(params) <- 1

plotYieldVsF(params, "L_forsteri")

load(file = "../outputs/yield001to095.RData")

getReproductionLevel(getParams(tasm1))

params2 <- setBevertonHolt(params, reproduction_level = c("L_forsteri" = 0.6))


p <- tuneParams(p, tabs = c("Spectra", "Growth", "Repro", "Catch", "Diet", "Death", "Rates",
     "Sim"), controls = c("abundance", "predation", "fishing", "reproduction", "other")
 )




```


### Baseline run

```{r}
tmax  = 100
dt = 0.2

tasm1 <- project(params, t_max = tmax, effort = 0, dt = dt)

plot(tasm1)
plotSpectra(tasm1)


## some general statistics 
# final relative biomass was tuned to be within 20% of the observed average scaled biomass
 relbio <- (getBiomass(tasm1)[tmax,]/max(getBiomass(tasm1)[tmax,]))/mariaParams$scaledBio
 round (relbio,3)
 
# 
# obsInvAb <- sum(InvData$meanAb[which(InvData$wgt > min_w_bb & InvData$wgt < w_bb_cutoff)])
# modelInvAb <- sum(tasm1@n_bb[tmax,]*params@dw_full)
# #ratio of model vs observed inv abundances (benthic spectrum) in the relevant range
# modelInvAb/obsInvAb

fish.mort.spp <- c(0.15, 0.15, 0, 0.1, 0.15, 0.1, 0.15, 0.1, 0.1, 0.15, 0.15, 
                  0.15, 0.15, 0.15, 0.1, 0.15, 0.15)

gear_params(params)$catchability <- fish.mort.spp

tasm1ef <- project(params, t_max = tmax, effort=1, dt = dt) 
tasm1ef2 <- project(params2, t_max = tmax, effort=1, dt = dt) 
plot(tasm1ef)

getBiomass(tasm1ef)[mean((tmax-10):tmax),]/getBiomass(tasm1)[tmax,]

getBiomass(tasm1ef)[mean((tmax-10):tmax),]/getBiomass(tasm1ef2)[mean((tmax-10):tmax),]

tasm1 <- project(params, t_max = tmax, effort=0, dt = dt) 
tasm1_2 <- project(params2, t_max = tmax, effort=0, dt = dt) 
getBiomass(tasm1)[mean((tmax-10):tmax),]/getBiomass(tasm1_2)[mean((tmax-10):tmax),]
plot(tasm1_2)

```


